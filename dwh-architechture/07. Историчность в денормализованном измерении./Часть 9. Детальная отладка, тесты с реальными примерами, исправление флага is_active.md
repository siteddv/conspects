### 9.1 Столкновение с неожиданными результатами

1. **Симптом: все `is_active = false`**
    
    - В какой-то момент тестирования обнаруживается, что у нескольких записей в `dim_inventory` поле `is_active` внезапно оказывается `false`, хотя логически оно не должно было меняться.
    - Причина обычно связана с тем, что в `UPDATE`-запросе, где мы «закрываем» старые строки, неточно прописано условие `JOIN` или `WHERE`. Например, мы используем слишком широкую выборку, и итогом становится массовое обновление всех строк.
2. **Не создаются новые версии**
    
    - Бывает, что не происходит `INSERT` новой строки при изменении полей фильма — значит, фильтр (или JOIN) на шаге вставки не находит соответствующей пары `(film_id, inventory_id)`.
    - Нужно проверить: правильно ли передаются даты изменения, корректно ли соединяются таблицы `dim_inventory` и список «изменённых фильмов».

---

### 9.2 Пошаговый дебаг

1. **Использование конкретного `film_id`**
    
    - Автор берёт фильм с ID, скажем, `998` или `997`, где поле `rental_duration` меняется с 3 на 5.
    - В **источнике** выполняется `UPDATE film SET rental_duration = 5 WHERE film_id = 998`.
    - Затем запускается процедура ETL, которая должна подтянуть изменение.
    - Проверяют, что в `dim_inventory` добавилась новая строка (с новым периодом), а старая «закрылась».
2. **Проверка временных таблиц**
    
    - На каждом шаге (до `INSERT`/`UPDATE`) делают `SELECT * FROM temp_table`, чтобы удостовериться, какие именно строки попали в неё.
    - Если в ней нет нужных ID, значит, фильтр написан неверно.
    - Если, наоборот, там слишком много строк, значит, недостаточно узкие условия.
3. **Просмотр полей дат**
    
    - Особенно важны поля `date_from`, `date_to`, `last_update`.
    - Проверяют, корректно ли совпадают даты начала и конца действия для «разбитых» строк: не образуется ли «дыра» или «перекрытие» во временных периодах, когда фильм считался и активным, и неактивным одновременно.

---

### 9.3 Исправление ошибок в SQL-запросах

1. **Неверная логика в `UPDATE`**
    
    - Часто встречающаяся ошибка: писать условие `UPDATE dim_inventory SET is_active = false ... JOIN изменённые_фильмы ...` без должного `ON`-условия, которое сужает выборку по `inventory_pk`.
    - Или ещё хуже — использовать `WHERE film_id IN (SELECT film_id FROM изменённые_фильмы)`, что приводит к обновлению **всех** строк, у которых фильм совпал, даже если период действия к тому моменту был уже закрыт.
2. **Перенос нужных полей в разные таблицы**
    
    - Нередко нужно дополнительно запрашивать `date_from`, `date_to` и сравнивать их с `film.last_update` в самом `JOIN`, уточняя:
        
        ```sql
        ON dim_inventory.film_id = changed_films.film_id
           AND changed_films.last_update BETWEEN dim_inventory.date_from AND dim_inventory.date_to
        ```
        
    - Если промахнуться с `BETWEEN`, можно либо пропустить нужные строки, либо перезаписать лишние.
3. **Установка `is_active`**
    
    - Нужно внимательно сделать так, чтобы **только** та строка, которая «пересекается» с датой изменения, стала `false`. А новая строка в этот же момент времени становится `true`.

---

### 9.4 Промежуточные итоги отладки

1. **Убедились, что алгоритм работает**
    
    - После нескольких итераций корректировок и проверок видно, что при изменении фильма в источнике действительно появляются новые строки в `dim_inventory`, старая «закрывается» аккуратно по нужному времени.
    - Флаг `is_active` корректно показывает, где текущая версия, а где историческая.
2. **Осталась сложность «двойного изменения»**
    
    - Если, например, на том же диске в тот же период **меняли `film_id`**, а потом **менялся** и сам фильм, возникает небольшое усложнение: получается, нужно **два** раза «разрезать» период.
    - Но автор подчёркивает, что это учится реализовывать в том же алгоритме; главное иметь **детальные** timestamps, чтобы чётко различать порядок изменений, или договориться, что одно изменение «перезаписывает» другое, если не было факта аренды между ними.
3. **Практическое значение**
    
    - В реальном проекте подобная детализация может быть избыточной (приводит к лавинообразному росту исторических строк). Возможно, на уровне бизнеса решают «не хранить мелкие доработки» фильма, если в промежутке не было факта аренды. Но учебный пример полезен, чтобы отработать все тонкости SCD Type 2.

---

### 9.5 Выводы по итогам тестирования

- **Корректный SQL**: важна очень точная логика в условиях JOIN и WHERE, чтобы не изменять не те записи, которые не должны были меняться.
- **Особенности времени**: если изменения совпадают по дате (но не по времени), нужно аккуратно расставлять метки, чтобы у нас не было «нулевых» промежутков или конфликтов.
- **Отладка**: на практике часто приходится запускать частичные запросы, смотреть во временные таблицы, сравнивать результаты и постепенно устранять неточности.

> **Резюме Часть 9**:
> 
> 1. Почти половина обсуждения посвящена практической отладке SQL-кода для SCD Type 2 по полям фильма.
> 2. Авторы видят типичные ошибки: неверно обновляются все строки, не вставляются новые версии. Исправляют, приводя код в соответствие с логикой «только затронутые строки».
> 3. В итоге приходит к рабочему варианту, который корректно создаёт исторические версии при изменении параметров фильма.