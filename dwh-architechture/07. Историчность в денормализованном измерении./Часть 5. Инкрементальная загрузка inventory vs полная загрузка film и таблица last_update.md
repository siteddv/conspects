### 5.1 Инкрементальная загрузка для `inventory`

1. **Общая логика**
    
    - Для таблицы `inventory` в источнике мы можем **инкрементально** забирать только записи, которые были изменены, удалены или добавлены с последней загрузки.
    - Причина:
        - `inventory` обычно содержит уже «активные» диски, и мы регулярно отслеживаем, что поменялось (новые диски, снятые с учёта, изменённые `film_id` и т.д.).
        - Поле `last_update` в исходной таблице (или системный триггер/журнал) позволяет точечно выбирать только те строки, у которых `last_update` больше времени предыдущей загрузки.
2. **Преимущества инкрементальной загрузки**
    
    - **Экономия времени** и трафика: при больших объёмах `inventory` мы не хотим каждый раз перетаскивать все записи, если изменились лишь десятки/сотни.
    - Уменьшение нагрузки на систему-источник и на DWH во время ETL-процесса.
3. **Как это делается технически**
    
    - Обычно в `staging`-слой загружают только изменённые/добавленные/удалённые записи (по `last_update`).
    - Затем в DWH (кор-слой) «закрывают» старые версии, вставляют новые строки в `dim_inventory`, и так происходит SCD Type 2 по компакт-дискам.

---

### 5.2 Полная загрузка для `film`

1. **Почему нельзя (или сложно) делать инкремент**
    
    - В таблице `film` (источник) могут существовать фильмы, для которых ещё **нет ни одного диска** (`inventory`). В таком случае у нас в DWH **нет** записи в `dim_inventory`.
    - Но при появлении нового `inventory` (с `film_id`, которого раньше не было в DWH), нам **нужны** характеристики фильма (title, rating, rental_duration и т.д.).
    - Если бы мы загружали `film` **только инкрементально**, то могли бы упустить фильмы, которые изменились или завелись в источнике раньше, но **не создали** `inventory` до нынешнего момента. Когда этот фильм **вдруг** привязывается к новому `inventory_id`, в DWH нет свежих данных о нём.
2. **Решение**
    
    - Проще **каждый раз** загружать всю таблицу `film` целиком (особенно если она относительно небольшая — сотни или тысячи фильмов, а не миллионы).
    - Таким образом, в `staging` всегда будет актуальная версия **всех** фильмов, и мы легко можем «подтянуть» необходимые поля при обновлении/вставке строк в `dim_inventory`.
3. **Дополнительные соображения**
    
    - Если таблица `film` **очень большая**, на практике могут применять продвинутые механизмы (CDC — Change Data Capture), хранить журнал изменений и т.д. Но в учебном примере проще взять «полную загрузку» как допустимый подход.
    - Главное — **последовательность**: когда мы берём обновления по `inventory` и видим новый или изменённый `film_id`, у нас уже есть полная сводка о фильме в `staging film`.

---

### 5.3 Таблица `last_update` для управления загрузками

1. **Что такое `last_update`**
    
    - В примере реализована таблица (или поля) с именем `last_update`, которая хранит время (timestamp) **последней** успешно завершённой загрузки в `staging` или в `core`.
    - Данный механизм помогает понять, **с какого момента** забирать обновлённые записи (`WHERE film.last_update > last_update_time`).
2. **Сложность точек во времени**
    
    - Если делать запись о «последней загрузке» **после** самого процесса загрузки, возникает риск, что какие-то изменения, произошедшие **в ходе** этого процесса, уже будут иметь время обновления больше метки и мы их «пропустим».
    - Часто берут время до начала фактической выгрузки из источника (например, `timestamp` в момент запуска процесса) и **только потом** производят копирование. Таким образом, всё, что изменится после этого «штампа», попадёт уже в **следующую** загрузку.
3. **Использование оконных функций**
    
    - Для определения «предыдущей» загрузки (в случае, если таблица `last_update` хранит **все** даты загрузок), можно использовать оконную функцию `lag()` — это позволяет найти предпоследнюю запись и взять её `timestamp`.
    - Так ETL-процесс понимает: «С прошлого раза в источнике есть изменения после времени Х, но до текущего момента Y».

---

### 5.4 Кодовые детали и пример

1. **Процедуры `film_load` и `inventory_load`**
    
    - В примере есть SQL-процедуры, которые:
        1. Удаляют старые данные из `staging`,
        2. Заливают свежие данные либо из источника, либо всю таблицу `film` (в случае `film_load`),
        3. Обновляют/вставляют строку в `last_update` с текущим временем (или временем начала процедуры),
        4. В `core` (DWH) используют этот `last_update` для нахождения строк, которые надо обновить по SCD Type 2.
2. **Проверка работоспособности**
    
    - После написания кода авторы запускают процедуру, смотрят, что `last_update` обновилось, и при новой загрузке уже используются новые метки.
    - В случае таблицы `film` подтверждают, что загружаются все фильмы (не только изменённые). В случае `inventory` — лишь те, у кого `last_update` «посвежее» старого штампа.

---

### 5.5 Вывод по стратегии загрузки и учёту изменений

- **Резюме**:
    
    1. **`inventory`**: инкрементальная логика на основе `last_update`. Объём обычно большой, поэтому берём только «дифф» изменений.
    2. **`film`**: полная загрузка, чтобы иметь все фильмы под рукой в `staging`. При появлении нового `film_id` в `inventory` мы уже можем «смёржить» его данные.
    3. **`last_update`**: хранит моменты завершённых/начатых загрузок, важен для определения «окна» инкрементального забора.
- **Практическая польза**:
    
    - Упрощает ETL, исключает риск пропуска новых фильмов, которые могли быть добавлены раньше, чем появился соответствующий диск.
    - Позволяет гибко обрабатывать именно те изменения, что произошли между двумя загрузочными циклами.

Таким образом, в дальнейшем показывается, как **в рамках этих процедур** в DWH аккуратно вставлять/обновлять строки для учёта историчности не только по `inventory`, но и по полям из `film`.