### 8.1 Подход к коду SCD Type 2 для полей фильма

1. **Разделение алгоритма на несколько шагов**
    
    - **Шаг 1**: получить список всех фильмов, которые менялись с прошлого раза (у них `last_update` в источнике больше, чем момент предыдущей загрузки).
    - **Шаг 2**: найти в `dim_inventory` все строки, которые **актуальны** в момент изменения этих фильмов (т.е. их период действия [date_from, date_to) пересекается с датой изменения).
    - **Шаг 3**: для каждого найденного диска (строки в `dim_inventory`) вставить новую запись — «новая версия», а старую «закрыть», проставив `date_to` = момент изменения.
2. **Роль временных таблиц**
    
    - Для удобства делают одну временную таблицу с «изменёнными фильмами», другую — со «строками dim_inventory, которые нужно обновить».
    - После заполнения временных таблиц запускают `INSERT` (добавляя новые записи) и `UPDATE` (закрывая старые).
3. **Важный момент**: `is_active`
    
    - У новой записи в `dim_inventory` `is_active = true`.
    - У старой записи после изменения `is_active = false`.

---

### 8.2 Вставка (INSERT) новых строк

1. **Копирование нужных полей**
    
    - При `INSERT INTO dim_inventory` выбираются данные из старой строки `dim_inventory` (например, `inventory_id`, `store_id` и т.п.), но **поля, относящиеся к самому фильму** (title, rating, rental_duration etc.) — уже из обновлённой версии из `staging film`.
    - Дата начала действия (`date_from`) ставится равной `last_update` (или точному моменту изменения) из таблицы фильмов.
    - Дата окончания (`date_to`) — будущее (например, `'9999-12-31'`), если принято так хранить актуальную версию без конечной даты.
2. **Фильтрация строк**
    
    - В `SELECT ... FROM dim_inventory JOIN <temp_table>` указывают нужные условия, чтобы браться только те строки, которые действительно подлежат разрезанию.
    - Дополнительно могут быть условия, чтобы не вставлять дубли, если время совпадает с `date_from` следующей строки и т.п.
3. **Генерация surrogate key**
    
    - Поскольку `dim_inventory` использует surrogate key (например, `inventory_pk`), при вставке генерируется новый ключ для каждой новой версии строки.
    - В демонстрации автор может показывать либо autoincrement столбец, либо sequence, либо `uuid`. Главное, чтобы каждая новая строка имела уникальный primary key.

---

### 8.3 Обновление (UPDATE) старых строк

1. **Обновление поля `date_to`**
    
    - После вставки новой строки для изменённого фильма, **старая запись** (которая раньше была «активной») должна быть закрыта по времени изменения.
    - `date_to` = `film.last_update`, чтобы вплоть до момента изменения эта строка считалась валидной, а после этого момента — нет.
2. **Смена флага `is_active`**
    
    - Ставится `is_active = false`, чтобы явно отделить закрытую версию от актуальной.
    - При будущих аналитических запросах, если нужно «актуальное» состояние, берётся `WHERE is_active = true`. Если нужно историческое, учитываются и неактивные версии, фильтруя по нужному диапазону дат.
3. **Точность времени**
    
    - Если `film.last_update` хранит и дату, и время, то используется полная метка (например, `2025-01-31 12:00:05`).
    - Если только дата, то могут быть ситуации, где за одну календарную дату произошло несколько изменений. Тогда приходится аккуратно обрабатывать порядок обновлений (или вести дополнительный timestamp).

---

### 8.4 Тестирование на конкретных примерах

1. **Демонстрация изменения фильма**
    
    - Автор ролика берёт конкретный `film_id = 1000`, меняет поле `rental_duration` в источнике.
    - Затем **запускает** ETL-процесс и смотрит, что в `dim_inventory` появилась **новая** строка (с более новой датой начала действия) для всех `inventory_id`, где `film_id = 1000`.
    - Проверяет: старая строка закрыта (`is_active = false`, `date_to =` момент изменения).
2. **Проверка «сложных» случаев**
    
    - Если у фильма 9999 несколько дисков, то **каждый** такой `inventory_id` получает новую строку.
    - Если диск сменил `film_id` _и_ сам фильм тоже поменял параметр, появляется сразу **две** новые строки (одна — при смене диска, другая — при обновлении полей фильма), если они действительно произошли в разные моменты времени.
    - Автор ролика может показывать, что всё корректно работает, хотя и выглядит сложно.
3. **Отладка и устранение ошибок**
    
    - В видео показываются синтаксические ошибки, ситуация, когда у всех строк вдруг стало `is_active = false` из-за неверного JOIN и т.п.
    - Постепенно код доводится до корректной логики: обновляются **только** нужные строки, вставляются **только** нужные новые версии.

---

### 8.5 Итоговая схема действий по SCD Type 2 для полей фильма

1. **Проверить изменённые фильмы** → **Сопоставить** их с `dim_inventory` → **Закрыть** старые строки → **Вставить** новые.
2. Убедиться, что даты и флаги `is_active` выставлены корректно.
3. При аналитике смотрим на `dim_inventory` (и, например, `fact_rental`), чтобы для каждой аренды знать, какой был `rental_rate` и т.п. «на тот момент».

> **Резюме Часть 8**:
> 
> - Пошагово разбирается SQL-код вставки (INSERT) новых версий строк и обновления (UPDATE) старых версий при изменениях в полях `film`.
> - Подчёркивается важность аккуратной логики JOIN, чтобы затронуть только те строки, которые действительно нужно «разрывать» по датам.
> - На примерах показано, что каждая правка полей фильма потенциально генерирует новую строку в `dim_inventory` для всех дисков, на которых этот фильм был прописан в период изменения.