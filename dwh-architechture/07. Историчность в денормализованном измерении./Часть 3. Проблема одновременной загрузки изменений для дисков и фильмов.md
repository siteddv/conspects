### 3.1 Сценарии множественных изменений между загрузками

1. **Изменения на одном компакт-диске**
    
    - За время, пока не было очередной загрузки в DWH (например, в течение суток), в источнике могло произойти несколько событий:
        1. Сменили фильм на диске (перезаписали `film_id`),
        2. Сам указываемый на диске фильм был отредактирован (например, поменялась `rental_duration` или название).
    - При следующей загрузке эти события **могут выглядеть «одновременными»**, если смотрим только на дату последнего обновления, но на самом деле у них был свой **порядок** (сначала одно изменение, потом другое).
2. **Изменения сразу на нескольких дисках**
    
    - Одновременно может затронуться несколько `inventory_id`. Например, диск №1 перезаписывают на фильм 2, а диск №2 меняет с фильмом 2 какую-то характеристику… Затем на диск №2 вообще записывается фильм 3 и т.д.
    - При пакетной загрузке в DWH (раз в сутки/неделю) всё это поступает одним «пакетом» изменений, и нужно разобраться, как восстановить хронологию.

---

### 3.2 Необходимость учёта порядка изменений

1. **Почему порядок событий важен**
    
    - SCD Type 2 подразумевает, что каждая запись в измерении имеет временной период действия. Если у нас есть два изменения подряд в течение одного дня, мы должны корректно «разделить» период на две части, а не «слить» их в одну запись.
    - Например:
        - **Случай A**: 22 августа в 12:00 на диск записали фильм №2 (заменив фильм №1), а **через 2 часа** изменили у фильма №2 поле `rental_rate`.
        - Если мы видим лишь «две» точки данных (до загрузки и после) без точного порядка, есть риск, что в DWH появится либо **неверная** (слишком короткая) историческая запись, либо пропустится одно из изменений.
2. **Разовая загрузка «сразу нескольких» апдейтов**
    
    - Если мы загружаем данные **раз в день**, а в течение дня было несколько корректировок, важно решить, нужно ли **все** изменения отражать исторически или лишь итоговое состояние.
    - Зависит от бизнес-логики:
        - Если **никто не взял** диск в аренду между изменениями, возможно, промежуточные состояния не важны.
        - Если же каждое изменение потенциально влияет на факты (аренда, оплата), то надо учитывать все, вплоть до точных времён.

---

### 3.3 Оптимизация: когда можно не фиксировать все изменения

1. **Реальный цикл проката**
    
    - Чаще всего диск не выдают в аренду много раз подряд **в один и тот же день** (или за короткий промежуток). Поэтому множественные изменения могут быть «техническими», не влияющими на аналитику реальных сдач в аренду.
    - Авторы подчёркивают, что на практике можно **не сохранять** каждое мелкое изменение, если **не было** связанного факта аренды.
2. **Упрощённая логика**
    
    - В уроке предполагается, что мы **всегда** ведём полную историю (чтобы продемонстрировать возможности SCD Type 2), но реальный проект может свести число версий к минимуму.
    - Грануляция «раз в сутки» или «раз в неделю» сама по себе уже **агрегирует** часть изменений.

---

### 3.4 Проблематика временных меток

1. **Нужны ли точные Timestamp**
    
    - Если доступна точная дата-время изменения (например, `last_update` хранит не только дату, но и часы, минуты, секунды), можно восстановить приблизительный **порядок** событий.
    - Если в источнике хранится только дата без времени, становится сложнее понять, какое именно событие было первым.
2. **Совпадение временных меток**
    
    - Случается, что у двух изменений одинаковая метка (например, 2022-08-25 12:00:00), хотя между ними минутная разница. В DWH придётся либо:
        - Решать, что оба изменения произошли в одну «микросекунду», и тогда может получиться «нулевой» промежуток,
        - Или вводить дополнительные правила (при одинаковом `last_update` считать, что смена `film_id` идёт раньше, а смена характеристик — позже).

---

### 3.5 Предварительный вывод: как подходить к обработке

1. **Логический разбор изменений**
    
    - По сути, нужно **инкрементально** забирать данные из `inventory` (новые, изменённые, удалённые) + **все** данные из `film` (или тоже инкрементально, если возможно).
    - Затем совместно анализировать, как эти изменения пересекаются:
        - Если `film_id` сменился для `inventory`, создаём новую версию в `dim_inventory`.
        - Если в тот же период сам фильм (теперь уже новый `film_id`) тоже обновлён, добавляется ещё одна версия.
2. **Результирующая историчность**
    
    - В DWH могут появляться несколько строк для одного `inventory_id` в течение одного дня, если действительно есть несколько различных «промежуточных» состояний.
    - Иногда достаточно показывать **только одно** обновление за день, чтобы сократить детализацию.
3. **Подготовка к кодированию**
    
    - Авторы переходят к тому, что нужно в ETL-процедуре (в SQL или другом инструменте) явно обрабатывать **два** набора изменений (из `inventory` и из `film`), смотреть на даты и **решать**, как формировать новые версии строк.

---

### 3.6 Промежуточные итоги

- **Проблема «порядка событий»**: при пакетной загрузке (раз в день/неделю) легко получить несколько изменений, сделанных в разное время, но **увиденных** DWH одновременно.
- **Степень детализации** зависит от того, насколько бизнесу важно каждое микрособытие. Если важна точность, нужно хранить все изменения и аккуратно разделять интервалы.
- **Техническая реализация**: в последующих частях будет показано, как в ETL-сценариях находить «точку» изменения, разбивать строки `dim_inventory` на две части (до изменения и после), а также вставлять новые записи с учётом изменений полей фильма.

> **Резюме Часть 3**:
> 
> 1. Одновременные (или почти одновременные) изменения в `inventory` и `film` создают сложность — нужно корректно восстанавливать порядок и дату изменения.
> 2. Если нет точных временных меток, придётся либо догадываться, либо принимать соглашения (например, опираться на «логический приоритет» изменения `film_id` над характеристиками фильма).
> 3. В реальных проектах не всегда нужно сохранять все промежуточные состояния, особенно если **фактов аренды** между этими состояниями не было.
> 4. Далее авторы переходят к конкретному алгоритму в SQL, который будет учитывать и смену диска, и обновление информации в фильме.