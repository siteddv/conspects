### 7.1 Общая идея: «разбить» существующую строку на две

1. **Когда это требуется**
    
    - Ранее мы делили строку (старую и новую) **только** если `film_id` у диска поменялся. Теперь же **любой** ключевой параметр фильма (`title`, `rental_rate`, `rental_duration` и т.д.), если он изменился, должен вызывать появление **новой** версии строки в `dim_inventory`.
    - Для этого нужно в коде ETL отлавливать все фильмы, которые поменяли **хотя бы одно** из критичных полей, и смотреть, **на каких дисках** (в `dim_inventory`) эти фильмы были актуальны на момент изменения.
2. **SCD Type 2**: «закрыть старую, открыть новую»
    
    - Срок действия старой строки (`date_from` – `date_to`) **обрезается** по дату изменения, и `is_active` ставится в `false`.
    - Создаётся новая строка, в которой (1) те же `inventory_id` и `film_id`, (2) обновлённые поля фильма, (3) `date_from` = момент изменения, (4) `date_to` = «9999-12-31» (или эквивалент), (5) `is_active = true`.

---

### 7.2 Этапы алгоритма в ETL (SQL-процедуре)

1. **Подготовка данных о «изменённых фильмах»**
    
    - Сначала определяем, **какие** фильмы менялись с момента предыдущей загрузки (см. логику `last_update` и инкрементальные выборки).
    - Для каждого такого фильма берём **его новые значения** полей (`title`, `rental_duration`, `rental_rate` и т.д.) из `staging film`.
2. **Нахождение затронутых строк в `dim_inventory`**
    
    - С помощью join-а по `film_id`:
        - Выбираем те строки `dim_inventory`, где `film_id` совпадает с фильмом, который поменялся.
        - Проверяем **период действия**: `dim_inventory.date_from` и `date_to`.
        - Если дата изменения фильма «попадает» во временной интервал (строка была активной в этот момент), значит, **именно** эту строку нужно «разрезать» (закрыть старую, вставить новую).
    - Важное условие: иногда дата изменения может **совпадать** с `date_to` старой строки или `date_from` новой. Тогда нужно аккуратно обрабатывать, чтобы не создавать «нулевые» промежутки.
3. **Вставка новой записи**
    
    - INSERT в `dim_inventory`:
        - Копируем часть полей из старой строки (например, `inventory_id`, «старый» суррогатный ключ, если нужно привязать? Но обычно суррогатный ключ генерируем заново),
        - Поля, связанные с фильмом, берём **из новых данных** (полученных в `staging film`),
        - `date_from` ставим равным `last_update` фильма,
        - `date_to` = «далёкое будущее» (или NULL, если вы предпочитаете такой подход),
        - `is_active = true`.
4. **Обновление старой записи**
    
    - UPDATE той самой записи в `dim_inventory`, которая была «активной» до изменения:
        - `date_to` = дата/время изменения,
        - `is_active = false`.

---

### 7.3 Особые случаи и аккуратность дат

1. **Случай совпадения времён**
    
    - Если у фильма дата изменения ровно совпадает с `dim_inventory.date_from`, значит, старая версия практически не действовала или действовала до этой точки. Надо убедиться, что не создаются «двойные» записи на одно и то же время.
    - Если совпадает с `dim_inventory.date_to`, возможно, строка уже была закрыта, и не нужно ничего делать (фильм уже вышел из «активной» зоны).
2. **Несколько изменений подряд**
    
    - Если у фильма в течение одного дня произошли сразу 2–3 правки (например, сначала сменили `rental_rate`, затем спустя час — название), алгоритм может создавать **несколько** записей подряд в `dim_inventory`.
    - Нужно убедиться, что каждая новая версия «закрывает» предыдущую корректно, без наложения периодов.
3. **Условность времён**
    
    - Если точность до секунды или миллисекунды, можно более надёжно восстанавливать последовательность. Если же только «дата» без времени, придётся решать логически, что произошло раньше.

---

### 7.4 Ключевые моменты в SQL-коде

1. **Временные таблицы**
    
    - В демонстрации автор создает временную таблицу, куда складирует фильмы, изменённые с прошлого раза.
    - Затем создаёт ещё одну временную таблицу, где хранятся идентификаторы строк `dim_inventory`, которые нужно обновить (т.е. по которым «упала» дата изменения внутрь их периода действия).
2. **INSERT с использованием `JOIN`**
    
    - При вставке новых записей в `dim_inventory`:
        1. `JOIN` старую версию записи (из `dim_inventory`) и изменённый фильм (из временной таблицы),
        2. Выбираются нужные поля оттуда и оттуда,
        3. Проставляются новые значения по полям фильма, старые значения для `inventory_id`, `store_id` (если есть), и т.д.
3. **UPDATE уже существующих строк**
    
    - Обновляет `date_to` и `is_active` на `false`, чтобы закрыть период действия.
    - Критически важно, чтобы этот UPDATE затронул **только те** строки, что действительно попадают под изменение.
    - В коде автор показывает, как правильно делать `WHERE <primary_key> IN (SELECT ...)` или JOIN, чтобы не обновлять все строки массово.

---

### 7.5 Резюме по механике разделения строк

- **Главная цель**: обеспечить, что в `dim_inventory` каждая значимая смена полей фильма отражается новой строкой (SCD Type 2).
- **Технические шаги**: найти изменившиеся фильмы → определить записи, где эти фильмы были активны → «разрезать» интервал на два.
- **Важная деталь**: «предыдущий» отрезок заканчивается в момент изменения, новый отрезок начинается в ту же самую дату/время (или на какую-то долю секунды позже, если это возможно).
- В следующей части авторы продолжат тестировать этот алгоритм на конкретных примерах, проверяя, не возникают ли нежелательные «дырки» или двойные пересечения во временных интервалах.

> **Резюме Часть 7**:
> 
> 1. Показан сквозной пример SCD Type 2, **двойной**: для `inventory` (смена дисков) и для **полей фильма** (смена характеристик).
> 2. Каждый раз, когда у фильма меняется нужное поле, мы ищем все связанные «активные» строки `dim_inventory` и закрываем/открываем строки заново.
> 3. Код включает создание временных таблиц, инсерты и апдейты с фильтрами по датам, чтобы аккуратно «разбивать» период действия.