## Краткое перечисление типов SCD
- **SCD Type 0**: отсутствие отслеживания изменений — данные остаются такими, как были изначально, обновления игнорируются.
- **SCD Type 1**: перезапись значений — при изменении в источнике в DWH тоже «затирают» старую версию. История **не сохраняется**.
- **SCD Type 2**: добавление новой строки (история во времени) — когда атрибут изменяется, старая версия «закрывается», а новая добавляется с новым «периодом действия».
- **SCD Type 3**: хранение нескольких версий атрибута в одном измерении — обычно хранится текущее и одно-два «предыдущих» значений в отдельных полях.
- **SCD Type 4**: вынесение часто меняющихся групп атрибутов в отдельную «мини-измерение» (Mini-dimension) с собственным ключом и логикой.

> Основной упор в данном курсе делается на **SCD2**, так как это самый распространённый способ хранить полную историю изменений.

---

## Реализация SCD2 для `dim_inventory`

### Зачем именно SCD2?
- В пример с компакт-дисками (таблица `inventory`) важно знать, **какой фильм** и **в какие даты** был записан на диск.
- Отталкиваясь от дат, можно правильно связывать факты (прокаты, платежи) с нужной версией диск-фильм.

### Добавление полей `effective_date_from` и `effective_date_to`
1. **`effective_date_from`**  
   - Дата, с которой данная строка (версия записи) считается актуальной.  
   - Если это первый раз, когда запись появляется в DWH, можно по умолчанию ставить что-то вроде `1900-01-01` или реальную дату вставки.
2. **`effective_date_to`**  
   - Дата, по которую данная версия считается актуальной (не включая этот момент).  
   - Для «открытых» версий можно условно ставить `9999-12-31`, обозначая, что запись действует до «бесконечности» или до следующего изменения.
3. **`is_active`**  
   - Булево поле (true/false), чтобы быстро находить текущую актуальную версию без сложного сравнения дат.  
   - Если запись уже не актуальна, выставляем `false` и в `effective_date_to` прописываем дату изменения.

### Пример с двумя версиями для одного `inventory_id`
- **Прежде**: `inventory_id = 1` — фильм A.  
  - `effective_date_from = 1900-01-01`,  
  - `effective_date_to = 9999-12-31`,  
  - `is_active = true`.  
- **После изменения**: в источнике заменили фильм A на фильм B.  
  - Старая версия: `is_active = false`, `effective_date_to = дата изменения`.  
  - Новая строка: тот же `inventory_id`, но **новый** первичный ключ DWH (Surrogate Key) и:  
    - `effective_date_from = дата изменения`,  
    - `effective_date_to = 9999-12-31`,  
    - `is_active = true`.

### Алгоритм действий
1. **Определить новые записи** (которые впервые появились в источнике).  
   - В хранилище создаются новые строки с «открытыми» датами (`from` = условная «ранняя» дата, `to` = «поздняя»).
2. **Определить изменённые записи** (которые уже существуют, но атрибуты поменялись).  
   - «Закрыть» старую версию: проставить `is_active = false` и заполнить `effective_date_to` текущей датой изменения.  
   - «Открыть» новую версию: вставить новую строку, где `effective_date_from = дата изменения`, `effective_date_to = 9999-12-31`, `is_active = true`.
3. **Определить удалённые записи** (если такое требуется по бизнес-логике).  
   - Аналогично: «закрыть» существующую актуальную версию, выставить `is_active = false`, `effective_date_to = дата удаления`.

> Именно такая модель (**SCD2**) и будет реализована далее в коде, чтобы продемонстрировать механизм историзации на примере `dim_inventory`.
