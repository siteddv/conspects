## 4.1. Подготовка таблиц к учёту историчности (SCD2)

### 4.1.1. Изменения в схеме Staging
1. **Добавление поля `last_update`**  
   - В таблицу `staging.inventory` (которая получает данные из операционной БД) добавляется новое поле `last_update TIMESTAMP`.  
   - С помощью этого поля DWH будет знать **момент** изменения строки в источнике.  
   - При инкрементальной загрузке это упрощает определение «какие записи были обновлены с последнего раза».
2. **Поле `deleted` (флаг или дата удаления)**  
   - Уже использовалось как признак логического удаления: если запись удалена в источнике, в `deleted` хранится дата (или `NOT NULL`).  
   - Нужно помнить, что при реализации SCD2 удаление означает «закрыть версию» в измерении (вместо физического удаления строки).

### 4.1.2. Изменения в схеме Core (таблица `dim_inventory`)
1. **Новые колонки**:
   - `effective_date_from TIMESTAMP NOT NULL`  
   - `effective_date_to TIMESTAMP NOT NULL`  
   - `is_active BOOLEAN NOT NULL DEFAULT TRUE`  
2. **Уникальность по `inventory_id` убирается**  
   - Раньше мог стоять уникальный индекс/constraint, чтобы не было дубликатов по `inventory_id`.  
   - Теперь при SCD2 **разрешено** несколько строк для одного `inventory_id`, отличающихся периодами (`effective_date_from/to`) и `is_active`.

3. **Пересоздание или `ALTER TABLE`**  
   - Если схема уже была, можно внести изменения командой `ALTER TABLE`. В учебном примере зачастую полная пересоздача с помощью скрипта.  
   - Ставим значения по умолчанию (например, `effective_date_from = '1900-01-01'`, `effective_date_to = '9999-12-31'`) при вставке новых строк.

---

## 4.2. Переписывание процедур загрузки: общий подход

Преподаватель поясняет, что теперь логика загрузки должна обрабатывать:
1. **Удалённые записи**: закрыть их (если они были активны).  
2. **Новые записи**: добавить их с «открытой» версией (дата начала = условная «минимальная» или реальная дата, дата конца = «максимальная», `is_active = true`).  
3. **Изменённые записи**: закрыть старую версию, создать новую.  

### 4.2.1. Пример алгоритма 
**(в порядке, который удобен в большинстве реализаций):**
1. **Обработка удалённых**  
   - `UPDATE dim_inventory SET is_active = false, effective_date_to = deleted_date FROM staging.inventory` …  
   - Условие: где `is_active = true` и `staging.deleted IS NOT NULL`.  
   - Фактически «закрываем» старую версию.
2. **Определение «новых» строк**  
   - Создать временную таблицу (например, `new_inventory_id_list`), куда складывать `inventory_id` из `staging` которых **нет** в `dim_inventory`.  
   - Исключить те, у которых `deleted` уже проставлено (или, наоборот, если логика требует, можно сразу «закрыть» их).  
3. **Вставка «новых» строк**  
   - `INSERT INTO dim_inventory (…) SELECT … FROM staging.inventory WHERE inventory_id IN new_inventory_id_list`.  
   - Проставить `effective_date_from = '1900-01-01'` (или реальную дату появления), `effective_date_to = '9999-12-31'`, `is_active = true`.
4. **Обработка «изменённых»**  
   - Если запись **уже есть** в `dim_inventory` (не новая, не удалена), но какие-то атрибуты (например, film_id) **поменялись**:  
     - «Закрываем» предыдущую запись:  
       ```sql
       UPDATE dim_inventory
         SET is_active = false,
             effective_date_to = staging.last_update
         FROM staging.inventory
         WHERE dim_inventory.is_active = true
           AND dim_inventory.inventory_id = staging.inventory_id
           AND ... (условие что значения отличаются) ...
       ```
     - «Открываем» новую версию:  
       ```sql
       INSERT INTO dim_inventory(…)
       SELECT ..., staging.last_update AS effective_date_from,
              '9999-12-31' AS effective_date_to,
              true AS is_active
       FROM staging.inventory
       ```
   - Таким образом, для каждого изменения появляется **новая строка**.

---

## 4.3. Разбор кода пошагово

### 4.3.1. Проверка существующих процедур
- Ранее были написаны процедуры, в которых при конфликте делался `ON CONFLICT … DO UPDATE`.  
- **Теперь** это не подходит, потому что на один `inventory_id` может быть **несколько** строк (разные версии).  
- Поэтому в скриптах убираем логику «затирания» и заменяем на «добавление новой строки + закрытие старой».

### 4.3.2. Создание временной таблицы `new_inventory_id_list`
- Пример команды:
  ```sql
  CREATE TEMP TABLE new_inventory_id_list ON COMMIT DROP AS
  SELECT staging.inventory_id
  FROM staging.inventory
  LEFT JOIN dim_inventory ON ...
  WHERE dim_inventory.inventory_id IS NULL
    AND staging.deleted IS NULL;
