## Подготовка таблиц и полей для историчности

1. **Добавление дат последнего изменения и флага удаления в Staging**  
   - Поле `last_update` (`TIMESTAMP`) указывает, когда запись была обновлена в источнике.  
   - Поле `deleted` (может быть `TIMESTAMP` или булево, в примере — `TIMESTAMP`) указывает момент логического удаления в источнике.  
   - Они помогают определить, какие строки изменились, появились или удалились с момента предыдущей загрузки.

2. **Расширение схемы Core**  
   - В таблицу `dim_inventory` (уровень Core) добавляются новые поля:  
     - `effective_date_from`,  
     - `effective_date_to`,  
     - `is_active`.  
   - Логика:  
     - Если запись «открыта» (актуальна), `is_active = true`, `effective_date_to` = `9999-12-31`.  
     - Если запись более не актуальна, `is_active = false`, а в `effective_date_to` ставится дата изменения или удаления.

## Обновление процедур загрузки

1. **Отказ от прежней стратегии удаления/перезаписи**  
   - Раньше при изменениях или удалениях строк из Staging «старые» записи в `dim_inventory` могли просто «затираться».  
   - Теперь же «старые» версии **закрываются**: ставится `is_active = false` и заполняется `effective_date_to` датой соответствующего события.

2. **Создание временной таблицы для определения “новых” записей**  
   - Пример: `new_inventory_id_list`.  
   - В неё складываются те `inventory_id`, которых **ещё нет** в `dim_inventory`.  
   - Цель — отделить «новые» строки от «изменённых».

3. **Логика для новых записей**  
   - Инструкция `INSERT` в `dim_inventory`:  
     - Подставить `inventory_id` из Staging,  
     - `effective_date_from` = либо «исторически ранняя дата» (1900-01-01), либо реальная дата появления,  
     - `effective_date_to` = `9999-12-31`,  
     - `is_active = true`.  
   - При этом если в Staging запись сразу пришла с признаком `deleted`, то можно «закрыть» её датой удаления, но это редкий сценарий.

4. **Логика для изменённых записей**  
   - **Сначала** «закрываем» предыдущую версию:  
     - `UPDATE dim_inventory SET is_active = false, effective_date_to = last_update`  
     - Условие: взять только «актуальную» строку (где `is_active = true`) для данного `inventory_id`.  
   - **Затем** вставляем новую строку (новая версия):  
     - `INSERT` с `is_active = true`,  
     - `effective_date_from = last_update`,  
     - `effective_date_to = 9999-12-31`.

5. **Обработка удалённых записей**  
   - Аналогично изменению, но дата окончания ставится равной `deleted`.  
   - Если запись помечена как удалённая (не `NULL` в поле `deleted`), значит в `dim_inventory` «закрываем» ту версию, которая была актуальна.

## Важные детали реализации

- **Порядок операций**:  
  1. Обрабатываем удалённые, чтобы закрыть версии, которые больше не нужны.  
  2. Выделяем новые записи и вставляем их с «открытыми» датами.  
  3. Обрабатываем изменённые, закрывая старые версии и открывая новые.  

- **Использование “date_from/date_to” вместо “on conflict update”**:  
  - Ранее при инкрементальной загрузке применялась конструкция `ON CONFLICT (inventory_id) DO UPDATE`.  
  - Теперь на один `inventory_id` может быть несколько строк, следовательно, **ключ уникальности** по `inventory_id` убирается: каждое изменение создаёт новую запись.

- **Преимущества явной атрибуции “is_active”**:  
  - Упрощает фильтрацию текущих актуальных версий: `WHERE is_active = true`.  
  - Экономит время и не требует сложных оконных функций по диапазону дат.

---

