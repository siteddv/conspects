### **3.1. Определение задачи**

Теперь, когда структура хранилища полностью пересоздана и процедура `load_core_rental` успешно загружает данные, необходимо проверить, как система обрабатывает **новые поступающие данные**.

**Задачи:**

1. Добавить **новые строки в `staging.rental`** (имитация новых данных в источнике).
2. Проверить, **корректно ли загружаются новые данные** в `core.fact_rental`.
3. Убедиться, что **данные после обновления хранилища остаются консистентными**.

---

### **3.2. Генерация новых данных в `rental`**

Предполагается, что новые данные **поступают в `staging.rental` автоматически** (из внешних систем, например, OLTP-базы данных).

Но в тестовых условиях мы **создаем их вручную** с помощью процедуры `fill_rental`, которая:

- **Генерирует новые записи**.
- **Выбирает дату, следующую за последней в базе**.

Сначала смотрим **текущую максимальную дату** в `staging.rental`:

```sql
SELECT MAX(rental_date) FROM staging.rental;
```

Допустим, максимальная дата в таблице **9 июня 2022 года**.  
Теперь добавим **3 новые записи** за **10 июня 2022 года**.

**Вызываем процедуру генерации новых данных:**

```sql
CALL fill_rental(3);
```

- Если не передавать дату, процедура **автоматически** создаст записи за **следующий день**.
- В результате появятся **3 новые аренды**.

Проверяем, что данные добавились:

```sql
SELECT * FROM staging.rental ORDER BY rental_id DESC LIMIT 10;
```

- Должны появиться **новые строки** с датой **10 июня 2022 года**.
- `rental_id` должен увеличиться.

---

### **3.3. Проверка наполнения хранилища (`fact_rental`) перед загрузкой**

Перед тем как загружать данные, **проверяем, какие записи есть в `fact_rental`**.

Проверяем **максимальную дату** в `fact_rental`:

```sql
SELECT MAX(rental_date) FROM core.fact_rental;
```

- Должно быть **9 июня 2022 года** (до загрузки новых данных).

Проверяем **максимальный `rental_id`**:

```sql
SELECT MAX(rental_id) FROM core.fact_rental;
```

- Должно совпадать с последним `rental_id` до генерации новых данных.

---

### **3.4. Запуск загрузки новых данных**

Теперь вызываем процедуру `load_core_rental`, чтобы обновить `fact_rental`:

```sql
CALL load_core_rental();
```

- Процедура должна обработать **все новые записи**.
- Данные за **10 июня 2022 года** должны появиться в хранилище.

---

### **3.5. Проверка результатов загрузки**

#### **Проверяем, обновилась ли `fact_rental`**

```sql
SELECT MAX(rental_date) FROM core.fact_rental;
```

- Должно быть **10 июня 2022 года**.

Проверяем, **появились ли новые строки**:

```sql
SELECT * FROM core.fact_rental WHERE rental_date = '2022-06-10';
```

- Должны появиться **3 новые аренды**.

Проверяем, **соответствует ли количество записей в источнике и хранилище**:

```sql
SELECT COUNT(*) FROM staging.rental WHERE rental_date = '2022-06-10';
SELECT COUNT(*) FROM core.fact_rental WHERE rental_date = '2022-06-10';
```

- Число записей **должно совпадать**.

---

### **3.6. Анализ возможных проблем**

После загрузки заметили, что **некоторые значения `total_amount` равны `NULL`**.

**Причина:**  
Некоторые аренды **не имеют платежей** в `staging.payment`, а `SUM(amount)` возвращает `NULL`.

**Решение:**  
Обновляем процедуру, чтобы `NULL` заменялся на `0`:

```sql
COALESCE(SUM(p.amount), 0) AS total_amount
```

Пересоздаем процедуру и повторно загружаем данные:

```sql
DROP PROCEDURE IF EXISTS load_core_rental;
-- Затем создаем заново с исправлением NULL
CALL load_core_rental();
```

Проверяем снова `total_amount`, **должны быть только числа, без `NULL`**.

---

### **Вывод**

✅ **Добавлены новые строки в `staging.rental`**.  
✅ **Запущена загрузка данных в `fact_rental`**.  
✅ **Подтверждено соответствие данных между источником и хранилищем**.  
✅ **Исправлена проблема с `NULL` в `total_amount`**.