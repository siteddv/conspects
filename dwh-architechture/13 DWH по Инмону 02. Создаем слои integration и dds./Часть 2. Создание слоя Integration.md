### **1. Архитектура и структура слоя Integration** _(24:01 - 27:18)_

**Основные задачи слоя Integration:**

- Объединить данные из разных источников.
- Привести данные к **третьей нормальной форме (3NF)**.
- Присвоить суррогатные ключи (Surrogate Keys).
- Выполнить **очистку и первичные вычисления**.

**Пример структуры:**

- В ODS у нас есть таблица **Users** (данные пользователей), которая может содержать:
    - `user_id` – идентификатор пользователя из источника.
    - `name`, `email`, `phone` – данные о пользователе.
    - `city` – город пользователя в виде строки.
- В Integration данные должны быть **приведены к нормализованному виду**:
    - Вынесем `city` в отдельную таблицу `Cities` и присвоим ей `city_id`.
    - В основной таблице `Users` заменим `city` на `city_id`.
    - Аналогично сделаем с `phone`, если его формат разнится между источниками.

---

### **2. Наполнение данных в Integration слой** _(27:18 - 31:12)_

#### **2.1. Присвоение суррогатных ключей**

- **Что такое суррогатные ключи?**
    - Это **уникальные идентификаторы**, которые **не зависят от данных источника**.
    - Они используются для **унификации** данных из разных систем.
- **Пример:**
    - У нас есть пользователи из разных систем:
        - В системе A `user_id = 123`.
        - В системе B `user_id = 456`.
    - В Integration создается **единый суррогатный ключ (`sk_user_id`)**, который уникален внутри хранилища.

#### **2.2. Очистка и нормализация данных**

- Убираем **дубликаты**.
- Приводим данные к **единому формату** (например, телефонные номера – в один формат).
- Применяем **стандартизированные справочники** (например, города, страны).

#### **2.3. Инкрементальная загрузка данных**

- Полный пересчет данных **делать нельзя**, так как объем может быть слишком большим.
- Используем **инкрементальную загрузку**, загружая **только новые или измененные данные**.
- Способы отслеживания изменений:
    - **CDC (Change Data Capture)** – отслеживание изменений на уровне базы данных.
    - **Сравнение с предыдущей версией данных** в Integration.
    - Использование полей **`last_updated`** в источнике.

---

### **3. Создание структуры таблиц Integration** _(31:12 - 39:45)_

**Пример таблицы `Users` в ODS:**

|user_id|name|email|phone|city|
|---|---|---|---|---|
|123|Иван|[ivan@mail.com](mailto:ivan@mail.com)|+7 900 123|Москва|
|456|Анна|[anna@mail.com](mailto:anna@mail.com)|8 (800) 456|Санкт-Петербург|

После нормализации в Integration:

**Таблица `Users`**

|sk_user_id|user_id|name|email|phone_id|city_id|
|---|---|---|---|---|---|
|1|123|Иван|[ivan@mail.com](mailto:ivan@mail.com)|1|1|
|2|456|Анна|[anna@mail.com](mailto:anna@mail.com)|2|2|

**Таблица `Phones`**

|phone_id|phone|
|---|---|
|1|+7900123|
|2|+7800456|

**Таблица `Cities`**

|city_id|city|
|---|---|
|1|Москва|
|2|Санкт-Петербург|

---

### **4. Автоматизация процесса ETL (Extract, Transform, Load)** _(39:45 - 46:22)_

#### **4.1. Общий процесс ETL**

1. **Extract** – извлечение данных из ODS.
2. **Transform** – нормализация, очистка, присвоение ID.
3. **Load** – загрузка в Integration.

#### **4.2. Написание SQL-запросов для загрузки**

**Пример запроса для загрузки новых пользователей:**

```sql
INSERT INTO Integration.Users (sk_user_id, user_id, name, email, phone_id, city_id)
SELECT 
    nextval('seq_sk_user_id'),  -- Генерация суррогатного ключа
    o.user_id,
    o.name,
    o.email,
    p.phone_id,
    c.city_id
FROM ODS.Users o
LEFT JOIN Integration.Phones p ON o.phone = p.phone
LEFT JOIN Integration.Cities c ON o.city = c.city;
```

**Пример запроса для обновления данных:**

```sql
UPDATE Integration.Users u
SET 
    name = o.name,
    email = o.email,
    phone_id = p.phone_id,
    city_id = c.city_id
FROM ODS.Users o
LEFT JOIN Integration.Phones p ON o.phone = p.phone
LEFT JOIN Integration.Cities c ON o.city = c.city
WHERE u.user_id = o.user_id
AND (u.name <> o.name OR u.email <> o.email OR u.phone_id <> p.phone_id OR u.city_id <> c.city_id);
```

**Как отслеживать новые записи?**

- Используем **`NOT EXISTS`** для поиска новых записей:

```sql
SELECT * FROM ODS.Users o
WHERE NOT EXISTS (
    SELECT 1 FROM Integration.Users u WHERE u.user_id = o.user_id
);
```

---

### **5. Оптимизация и ошибки при загрузке данных** _(46:22 - 53:18)_

#### **5.1. Ошибки, которые могут возникнуть**

- Дубликаты данных.
- Несоответствие типов данных (например, строка вместо числа).
- Ошибки при **присвоении суррогатных ключей**.

#### **5.2. Способы оптимизации загрузки данных**

- **Индексы**: добавляем индексы на `user_id`, `phone_id`, `city_id`.
- **Партиционирование** таблиц, если данных слишком много.
- **Использование batch-загрузки**, а не построчной вставки.

#### **5.3. Проверка данных после загрузки**

- **Сравнение количества записей** в ODS и Integration.
- Проверка на **отсутствие дубликатов**.
- Контроль, что нет **"потерянных" данных** (все пользователи из ODS должны быть в Integration).

---

### **Выводы второй части**

✅ **Создана структура слоя Integration.**  
✅ **Разобрали процессы нормализации данных и присвоения суррогатных ключей.**  
✅ **Написаны SQL-запросы для ETL-процесса.**  
✅ **Разобрали ошибки и способы оптимизации загрузки данных.**