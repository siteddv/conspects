Ниже приводится развёрнутый конспект обсуждения, когда преподаватель переходит к **логике инкрементальной загрузки** и объясняет, как обрабатывать таблицу `payment` с учётом связи через `rental` и далее через `inventory`.

---

### 1. Суть задачи по инкрементальной загрузке

- **Основная цель**: загружать данные из таблицы `payment` не полностью (full load), а **инкрементально**, то есть только **изменившиеся** (insert/update) и **удалённые** (delete) записи.
- Уточняется, что:
    - Таблица `payment` напрямую **не содержит** поля `inventory_id`; для определения, по какому именно диску (или другому ресурсу) совершен платёж, требуется соединение с таблицей `rental`.
    - Таблица `rental`, в свою очередь, **ссылается** на `inventory`.
    - Возникает вопрос: **как** при инкрементальной загрузке платежей «дотягиваться» до нужных полей, если мы делаем не полный, а именно инкрементальный подход?

---

### 2. Возможные варианты решения

Преподаватель перечисляет несколько сценариев, как можно построить логику инкрементальной загрузки:

1. **Делать в `staging` полный набор данных по `rental`**
    
    - В этом случае таблица `staging_rental` всегда содержит все записи из источника (т.е. полная копия).
    - При загрузке инкрементов в `rental` в `staging` происходит только «сравнение», но результатом остаётся **полная таблица** (все строки).
    - Тогда при загрузке `payment` в `staging_payment` мы можем **всегда** делать `join` к этой «полной» `staging_rental`, легко получая `inventory_id`.
    - Недостаток подхода: усложняется **дальнейшая** инкрементальная выгрузка `rental` в слой Core, так как там нужно аккуратно вычислять, что **действительно** изменилось по сравнению с предыдущим состоянием.
2. **Использовать дополнительные слои – например, ODS (Operational Data Store)**
    
    - Идея в том, чтобы сделать специальный промежуточный слой (ODS), где **хранится полноценная копия** таблиц из источника, но уже с датами изменения/удаления.
    - Из ODS затем проще «подтягивать» все нужные поля и формировать **следующие** уровни хранилища (Core, DDS и т.п.).
    - Пока в видео это упоминается как перспективный вариант («Мы ещё не дошли до полноценного слоя ODS»), но **на данном этапе** преподаватель предлагает более простое и быстрое решение.
3. **Сделать `join` `payment` c `rental` прямо на стороне источника**
    
    - На момент **инкрементальной** загрузки в `staging_payment` брать нужные поля (`inventory_id`) через `JOIN` к `rental` **из исходной базы**.
    - Да, при этом дополнительная нагрузка придётся на базу-источник, потому что для каждой порции платежей надо «дотягивать» связанные поля. Но это позволяет обойтись без полного копирования `rental` в `staging` или создания слоя ODS.
    - Преподаватель поясняет, что в учебных примерах – это наиболее простой вариант.

**Итог**: выбрано решение – **в `staging_payment` при инкрементальной загрузке «приджойниться» к `rental`** в базе-источнике и сразу получить `inventory_id`. Это **минимально усложняет** архитектуру и реализуется в рамках одной SQL-процедуры.

---

### 3. Доработка структуры таблицы `payment` в источнике

Чтобы инкрементальная загрузка **работала**, необходимо знать, **какие** записи и **когда** изменились. Для этого:

- **Добавляются** два поля:
    - `last_update` (тип **timestamp**), куда автоматически проставляется время любого изменения записи.
    - `deleted` (тип **timestamp**), в которое записывается время фактического удаления (или `NULL`, если запись не удалена).
- Создаётся **триггер** (по аналогии с таблицей `rental`), который при любом `UPDATE` в `payment` выставляет актуальный `last_update = now()`.
- Преподаватель **показывает**, как написать `ALTER TABLE` для добавления колонок:
    - Сначала поле создают как `NULL`, заполняют `last_update` старыми датами, потом делают `NOT NULL`.
    - Поле `deleted` остаётся допускающим `NULL`.
- Затем **проверка** работы триггера:
    1. Обновляют одну строку (меняют сумму платежа).
    2. Смотрят, что в `last_update` записалась **текущая** дата/время.

В завершении этого блока педагог ещё раз подчёркивает важность подготовки данных **на стороне источника** (на реальном проекте потребовалось бы согласовывать это с владельцами OLTP-системы).

---

### 4. Переход к следующему этапу

- После того как в **исходной** таблице `payment` появились поля `last_update` и `deleted`, и триггер работает, преподаватель говорит, что теперь можно заняться **конфигурацией** слоя `staging_payment`.
- **Далее** (в **Части 3** видео) он начинает создавать таблицу `staging_payment` с учётом новых полей и описывает SQL-процедуры для загрузки.

---

**Итог**: во второй части (~0:08–0:16) преподаватель главным образом:

1. Формулирует **проблему** инкрементальной загрузки при наличии связи `payment -> rental -> inventory`.
2. Перечисляет **три основных метода** решения (полная таблица `rental` в `staging`, ввод слоя ODS, либо `join` в источнике).
3. Выбирает простой **путь** – при загрузке `payment` «приджойниться» к `rental»**.
4. Поясняет **необходимость** полей `last_update` и `deleted` в таблице `payment`, **показывает** их добавление, настройку триггера и проверку.