В этой части преподаватель **тестирует всю систему**, проверяя работу инкрементальной загрузки, историчности и корректности данных в `fact_payment`. Также он исправляет обнаруженные **ошибки**, объясняет нюансы с `rental_id` и `inventory_id` и отвечает на вопросы участников.

---

### **1. Проверка работы системы на реальных изменениях**

Преподаватель **последовательно изменяет данные** в источнике (`source_payment`) и проверяет, **как эти изменения отразятся** в хранилище.

#### **Тест 1: Изменение суммы платежа (`amount`)**

- Выбираем **случайный `payment_id`** и меняем его сумму.

```sql
UPDATE source_payment 
SET amount = 3.99 
WHERE payment_id = 320098;
```

- Запускаем загрузку:

```sql
CALL full_load();
```

- Проверяем `fact_payment`:

```sql
SELECT * FROM fact_payment WHERE payment_id = 320098;
```

- **Ожидаемый результат**:
    - В `fact_payment` появляется **новая строка** с `amount = 3.99`.
    - **Старая запись** остаётся, но `is_active = FALSE`, `effective_date_to` устанавливается в момент изменения.

✅ **Тест пройден** – новая строка корректно создаётся.

---

#### **Тест 2: Изменение даты платежа (`payment_date`)**

- Меняем **только дату** (не затрагивая время):

```sql
UPDATE source_payment 
SET payment_date = '2022-10-10' 
WHERE payment_id = 320098;
```

- Загружаем изменения:

```sql
CALL full_load();
```

- Проверяем:

```sql
SELECT * FROM fact_payment WHERE payment_id = 320098;
```

- **Ожидаемый результат**:
    - **Добавляется новая строка**, так как `payment_date` входит в **исторически значимые поля**.
    - **Старая строка** помечается `is_active = FALSE`.

✅ **Тест пройден** – историчность соблюдается.

---

#### **Тест 3: Изменение `rental_id`**

- Изменяем аренду:

```sql
UPDATE source_payment 
SET rental_id = 14245 
WHERE payment_id = 320098;
```

- Запускаем загрузку и проверяем `fact_payment`.

**Ожидаемый результат**:

- **Новая запись создаётся** с обновлённым `rental_id`.
- **Старая запись** становится неактивной.

✅ **Тест пройден**.

---

### **2. Ошибка с обновлением `inventory_id`**

После нескольких запусков преподаватель **обнаруживает проблему**:

- Когда **меняется `inventory_id` в `rental`**, это **не фиксируется** в `staging_payment`.
- Причина: `staging_payment` **не учитывает изменения в `rental`**, если `payment` не изменялся.

#### **Решение**

- Добавляем в `staging_payment_load` проверку `rental.last_update`:

```sql
WHERE p.last_update >= (SELECT last_load_time FROM meta_load_tracking WHERE table_name = 'staging_payment')
   OR r.last_update >= (SELECT last_load_time FROM meta_load_tracking WHERE table_name = 'staging_payment');
```

✅ **Теперь `rental_id` всегда обновляется** при изменениях.

---

### **3. Вопросы слушателей**

**Вопрос 1**: Почему `payment_date` – `integer`, а не `date`?

- Ответ:
    - Это **внешний ключ** на `dim_date` → `integer` даёт **оптимизацию запросов**.
    - Форматирование дат делается в `dim_date` → это удобнее для отчётов.
    - Такой подход исключает ошибки при группировке данных по неделям, месяцам и т.п.

**Вопрос 2**: Что делать, если изменился `rental_id`, но сам платёж нет?

- Ответ:
    - Историчность поддерживается **по `rental_id`**, поэтому **новая строка создаётся**.
    - Ошибка была в `staging_payment_load`, теперь исправлено (`rental.last_update` тоже проверяется).

---

### **4. Заключение и планы на следующее занятие**

- **Что сделано**:
    
    - Настроена **инкрементальная загрузка**.
    - Добавлена **историчность (SCD2)**.
    - Исправлены ошибки **обновления `rental_id` и `inventory_id`**.
    - Проведено **тестирование** – система работает корректно.
- **Следующее занятие**:
    
    - Добавление **ODS (Operational Data Store)**.
    - Оптимизация процесса загрузки.
    - Разбор сложных сценариев изменения данных.