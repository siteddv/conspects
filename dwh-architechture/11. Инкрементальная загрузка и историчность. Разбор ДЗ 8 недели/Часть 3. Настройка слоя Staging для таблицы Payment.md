В этой части преподаватель **создаёт и настраивает** `staging_payment` – промежуточный слой, куда будут загружаться инкременты из источника `payment`. Он детально показывает, **как именно** строится процесс загрузки, какие **ошибки** могут возникнуть и **как их исправить**.

---

### 1. Создание `staging_payment` с учётом новых полей

- Теперь, когда в **исходной** таблице `payment` появились `last_update` и `deleted`, их нужно **отразить** в слое `staging`.
- Создаётся **структура** таблицы `staging_payment`, которая теперь включает:
    - `payment_id` – идентификатор платежа (ключ).
    - `customer_id` – ID клиента.
    - `staff_id` – ID сотрудника, обработавшего платёж.
    - `rental_id` – ссылка на аренду (добавляется отдельно).
    - `amount` – сумма платежа.
    - `payment_date` – дата платежа.
    - `last_update` – когда запись последний раз изменялась.
    - `deleted` – когда запись была удалена (`NULL`, если не удалена).
- Таблица создаётся **с нуля**, если уже существует – **пересоздаётся**.

---

### 2. Реализация процедуры `staging_payment_load`

Преподаватель создаёт SQL-процедуру `staging_payment_load`, которая:

1. **Определяет последний момент загрузки**
    
    - Используется переменная, в которую записывается время последней успешной загрузки (из метаданных).
    - Это позволяет загружать **только изменённые и удалённые записи**.
2. **Удаляет старые записи в Staging**
    
    - В `staging_payment` **удаляются** строки, которые загружались **на предыдущем шаге**, чтобы заменить их **новыми инкрементами**.
3. **Загружает инкременты с `JOIN` на `rental`**
    
    - Выбираются только **записи, у которых `last_update` или `deleted` больше последней загрузки**.
    - Делаем `JOIN` на `rental`, чтобы сразу **вытащить `inventory_id`**.
    - В результате, в `staging_payment` сразу записывается информация **о платеже и связанном инвентаре**.

Пример запроса (упрощённый вариант, без доп. полей):

```sql
INSERT INTO staging_payment
(payment_id, customer_id, staff_id, rental_id, amount, payment_date, last_update, deleted)
SELECT 
    p.payment_id, 
    p.customer_id, 
    p.staff_id, 
    r.rental_id, 
    p.amount, 
    p.payment_date, 
    p.last_update, 
    p.deleted
FROM source_payment p
JOIN source_rental r ON p.rental_id = r.rental_id
WHERE p.last_update >= (SELECT last_load_time FROM meta_load_tracking WHERE table_name = 'staging_payment')
   OR p.deleted IS NOT NULL;
```

---

### 3. Проверка загрузки инкрементов

- Преподаватель **показывает тестовый запуск**:
    1. **Перед загрузкой**: `staging_payment` пуст.
    2. **После первой загрузки**: вставляются **все** данные (первичный `full load`).
    3. **После второй загрузки**: если изменений нет – таблица очищается (`0 записей`), так как инкременты отсутствуют.
    4. **Если в источнике меняем запись** (`amount`, `payment_date` или `rental_id`) – после загрузки появляется **обновлённая строка**.

---

### 4. Исправление ошибки при повторной загрузке

- После тестирования выявляется **ошибка**:
    - При втором запуске `staging_payment_load` данные не очищаются должным образом.
    - Причина: в процедуре не было **сохранения метки последней загрузки**.
- Исправление:
    - Добавляется **обновление метаданных** (`meta_load_tracking`), которое фиксирует **момент успешной загрузки**.

Пример кода исправления:

```sql
UPDATE meta_load_tracking 
SET last_load_time = now() 
WHERE table_name = 'staging_payment';
```

---

### Итог

В этой части преподаватель **настроил `staging_payment`**, обеспечив: ✔ **Перенос новых и изменённых данных из `payment`**.  
✔ **Достраивание недостающих полей (`rental_id`) через `JOIN`**.  
✔ **Очистку устаревших данных в `staging` перед каждой загрузкой**.  
✔ **Использование временных меток (`last_update`) для определения инкрементов**.  
✔ **Исправление бага с повторной загрузкой**.
