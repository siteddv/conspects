### **4.1. Переход от Staging Layer к Core Layer**

После успешного создания **Staging-слоя**, следующая цель — **перенос данных в основной слой хранилища (Core Layer)**.

#### **4.1.1. Разница между Staging и Core**

- **Staging Layer** → хранит **сырые данные** в том виде, как они пришли из источника.
- **Core Layer** → содержит **нормализованные данные**, подготовленные для аналитики.
- **Основная задача Core Layer** → привести данные к **оптимальному формату**.

#### **4.1.2. Почему нельзя строить отчёты напрямую на Staging?**

- В Staging **данные не обработаны** и могут содержать:
    - Дубликаты.
    - Неполные записи.
    - Неверные или устаревшие данные.
- Если строить отчёты на **сырых данных**, можно получить **некорректные результаты**.
- В **Core Layer** данные очищаются, нормализуются и приводятся к **единому формату**.

---

### **4.2. Создание Core Layer и его структуры**

#### **4.2.1. Создание схемы Core**

- В хранилище данных создаётся **отдельная схема** для Core Layer:
    
    ```sql
    CREATE SCHEMA core;
    ```
    
- Это позволяет **разделить Staging и Core**.

#### **4.2.2. Создание таблицы фильмов (`core.film`)**

- Таблица `staging.film` содержит **все данные из источника**, но в Core-слое их нужно **нормализовать**.
- В новой таблице **исправляются ошибки**, удаляются ненужные поля.

**Создание таблицы в Core Layer:**

```sql
CREATE TABLE core.film (
    film_id INT PRIMARY KEY,
    title VARCHAR(255),
    description TEXT,
    release_year INT,
    rating VARCHAR(10),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

- Добавляется **поле `created_at`** для хранения даты загрузки.

---

### **4.3. Очистка и нормализация данных**

#### **4.3.1. Удаление дубликатов**

- Иногда из источника могут приходить **повторяющиеся записи**.
- В Core-слое при загрузке **дубликаты удаляются**.

**Пример удаления дубликатов:**

```sql
DELETE FROM staging.film
WHERE film_id IN (
    SELECT film_id FROM core.film
);
```

- Это гарантирует, что в Core-слое **не будет повторяющихся записей**.

#### **4.3.2. Очистка от "грязных" данных**

- Например, **если поле `rating` содержит NULL**, его можно заменить значением по умолчанию.

```sql
UPDATE staging.film
SET rating = 'NR' -- Not Rated
WHERE rating IS NULL;
```

#### **4.3.3. Нормализация данных**

- В **Staging Layer** данные хранятся "как есть", но в Core-слое их можно **разделить на отдельные таблицы**.
- Например:
    - Вынести **категории фильмов** в отдельную таблицу `core.category`.
    - Разделить **информацию о фильмах** и **их наличии в магазине**.

---

### **4.4. Создание ETL-процедуры для переноса данных в Core**

#### **4.4.1. Создание процедуры `load_film_to_core`**

- После загрузки данных в Staging, их нужно **перенести в Core Layer**.

**SQL для процедуры загрузки данных в Core:**

```sql
CREATE OR REPLACE PROCEDURE core.load_film_to_core()
LANGUAGE plpgsql AS
$$
BEGIN
    -- Удаляем старые данные
    DELETE FROM core.film WHERE film_id IN (SELECT film_id FROM staging.film);

    -- Загружаем новые данные
    INSERT INTO core.film (film_id, title, description, release_year, rating, created_at)
    SELECT film_id, title, description, release_year, rating, CURRENT_TIMESTAMP
    FROM staging.film;
END;
$$;
```

- Эта процедура:
    1. **Удаляет старые записи**, если такие уже есть.
    2. **Загружает новые данные** из Staging.
    3. Добавляет **время загрузки** в `created_at`.

#### **4.4.2. Запуск процедуры**

- После выполнения Staging-процедур вызывается процедура `load_film_to_core`:

```sql
CALL core.load_film_to_core();
```

- Теперь данные находятся **в Core-слое и готовы для анализа**.

---

### **4.5. Оптимизация производительности Core Layer**

#### **4.5.1. Добавление индексов**

- Для ускорения запросов можно создать **индексы** на ключевых полях.

```sql
CREATE INDEX idx_film_title ON core.film (title);
```

- Это ускорит поиск фильмов по названию.

#### **4.5.2. Разделение таблицы на партиции**

- Если в таблице **миллионы записей**, можно **разделить её на части** (`partitioning`).

```sql
CREATE TABLE core.film_2023 PARTITION OF core.film
FOR VALUES FROM ('2023-01-01') TO ('2023-12-31');
```

- Это **уменьшит время выборки данных**.

---

### **4.6. Автоматизация ETL-процессов**

После создания Core-слоя можно **автоматизировать загрузку данных**.

#### **4.6.1. Создание общей процедуры `load_all_to_core`**

```sql
CREATE OR REPLACE PROCEDURE core.load_all_to_core()
LANGUAGE plpgsql AS
$$
BEGIN
    CALL core.load_film_to_core();
    -- В дальнейшем добавятся процедуры для inventory и rental
END;
$$;
```

#### **4.6.2. Запуск ETL-процесса**

```sql
CALL core.load_all_to_core();
```

- Эта процедура **запускает все загрузки сразу**.

#### **4.6.3. Настройка автоматического выполнения**

- Чтобы не запускать процесс вручную, можно **добавить его в `pg_cron`**.

```sql
SELECT cron.schedule('0 3 * * *', 'CALL core.load_all_to_core()');
```

- Теперь процесс загрузки данных **будет выполняться каждый день в 3:00 ночи**.

---

### **Выводы из четвёртой части**

- Создан **Core Layer** для хранения обработанных данных.
- Реализованы **процедуры для переноса данных из Staging в Core**.
- Введены **методы оптимизации** (индексы, партиции, очистка данных).
- Автоматизирована загрузка данных с помощью `pg_cron`.