### **5.1 Проблема зависимостей и внешних ключей**

- **Ошибка:**
    
    - При попытке **удалить данные из `dim_inventory` или `dim_staff`**, система выдает ошибку.
    - Причина: **Таблицы фактов (`fact_payment`, `fact_rental`) ссылаются на измерения**, и SQL-сервер **не позволяет удалять строки, на которые есть ссылки**.
- **Что делать?**
    
    - **Удалять данные из таблиц фактов перед загрузкой измерений**.
    - Это можно делать вручную, но лучше **автоматизировать процесс**.

---

### **5.2 Создание процедуры очистки фактов (`fact_delete`)**

- **Решение:**
    - Создаем процедуру **удаления данных из таблиц фактов перед их перезагрузкой**.
    - Теперь перед вставкой данных в измерения (`dim_inventory`, `dim_staff`) **процедура `fact_delete()` очищает таблицы `fact_payment` и `fact_rental`**.

```sql
CREATE OR REPLACE PROCEDURE core.fact_delete() 
LANGUAGE SQL 
AS $$
DELETE FROM core.fact_payment;
DELETE FROM core.fact_rental;
$$;
```

- **Добавляем вызов `fact_delete()` в процедуру полной загрузки (`full_load`)**.

---

### **5.3 Ошибка: Процедуры создаются в `public` вместо `core`**

- **Проблема:**
    
    - При создании **процедур загрузки (`load_inventory`, `load_staff`, `load_payment`)** они по умолчанию создаются **в схеме `public`**, а не `core`.
    - Это приводит к тому, что при вызове процедуры **PostgreSQL не находит ее в `core`**.
- **Решение:**
    
    - Явно указываем схему `core` при создании всех процедур.
    - **Пример исправления**:
        
        ```sql
        CREATE OR REPLACE PROCEDURE core.load_inventory()
        ```
        
    - Пересоздаем **все процедуры в `core`**, проверяем схему в `pgAdmin`.

---

### **5.4 Оптимизация загрузки данных**

- **Наблюдение:**
    
    - Полная загрузка данных выполняется **~9 секунд**.
    - При этом загрузка в `staging` занимает **0.3 секунды**, а загрузка в `core` – **8.7 секунд**.
    - Это говорит о **неэффективных SQL-запросах в `core`**, скорее всего **из-за сложных `JOIN` и отсутствия индексов**.
- **Будущая оптимизация:**
    
    - Рассмотрим **использование индексов для ускорения JOIN**.
    - Подумаем над **инкрементальной загрузкой**, чтобы не перезагружать все данные каждый раз.

---

### **5.5 Проверка корректности загрузки**

1. **Выполняем `full_load()`** – полный цикл загрузки.
2. **Проверяем количество строк в `fact_payment`** – **должно быть 14 596**.
3. **Проверяем `dim_inventory`** – **должно быть 4 584 строки**.
4. **Проверяем `dim_staff`** – **2 строки (2 сотрудника)**.
5. **Тестируем процедуру `fact_delete()` – после ее вызова в `fact_payment` и `fact_rental` не должно быть данных.**

✅ **После исправлений загрузка работает без ошибок**.

---

### **Выводы по этой части**

✅ **Добавлена процедура `fact_delete()` для очистки данных перед загрузкой**.  
✅ **Исправлены ошибки с схемами – теперь процедуры создаются в `core`**.  
✅ **Полный цикл загрузки `full_load()` выполняется успешно**.  
✅ **Выявлена необходимость оптимизации JOIN-запросов**.