# Глава 4. Кодирование и эволюция

Необходима совместимость: обратная (новый код читает старые данные) и прямая (старый код читает новые данные). Прямая совместимость сложнее, так как старый код должен игнорировать новые поля.

## [[4.1. Форматы кодирования данных]] [4.1. Форматы кодирования данных](../../../полный/Часть 1. Основы информационных систем/Глава 4. Кодирование и эволюция/подтемы/4.1. Форматы кодирования данных.md)

Кодирование (сериализация) — преобразование из памяти в байты, декодирование — обратно. **Языковые форматы** (Java Serializable, Python pickle) имеют недостатки: языковая привязка, проблемы безопасности, отсутствие контроля версий, неэффективность.

**JSON, XML, CSV:** популярны, но имеют проблемы с типами данных (числа, двоичные строки). JSON не поддерживает точность для больших чисел. Двоичные данные требуют Base64 (+33% объема).

**Thrift и Protocol Buffers:** двоичные форматы со схемами. Теги полей критичны для эволюции: можно менять названия, но не теги. Новые поля добавляются с новыми тегами (прямая совместимость), не могут быть обязательными (обратная совместимость). Изменение типов возможно с риском потери точности.

**Avro:** схема без тегов, компактное кодирование (32 байта). Данные — последовательность значений без идентификации полей. Схема для записи и схема для чтения могут различаться, если совместимы. Поля сопоставляются по именам. Поддержка динамически генерируемых схем, гибкость для статически и динамически типизированных языков.

**Достоинства схем:** компактность, актуальная документация, проверка совместимости, генерация кода.

## [[4.2. Режимы движения данных]] [4.2. Режимы движения данных](../../../полный/Часть 1. Основы информационных систем/Глава 4. Кодирование и эволюция/подтемы/4.2. Режимы движения данных.md)

**Поток данных через БД:** записывающий процесс кодирует, читающий декодирует. Обратная совместимость критична. Данные могут иметь разные временные метки, время жизни данных превышает время жизни кода. Эволюция схемы позволяет БД выглядеть единообразно.

**REST и RPC:** REST — архитектурный стиль на основе HTTP, простой. SOAP — протокол на XML, сложный. Проблемы RPC: непредсказуемость сетевых запросов, задержки, дублирование, проблемы совместимости типов. Современные фреймворки (Thrift, gRPC, Avro) поддерживают RPC с различными форматами. Для эволюции RPC важна обратная совместимость запросов и прямая — ответов.

**Асинхронная передача сообщений:** брокеры сообщений (RabbitMQ, Kafka) обеспечивают буферизацию, повторную отправку, скрытие деталей, мультидоставляемость. Распределенные акторные фреймворки (Akka, Orleans, Erlang OTP) используют асинхронные сообщения для масштабирования.

## [[4.3. Резюме]] [4.3. Резюме](../../../полный/Часть 1. Основы информационных систем/Глава 4. Кодирование и эволюция/подтемы/4.3. Резюме.md)

Форматы: языковые (несовместимы), текстовые (JSON/XML/CSV — популярны, но проблемы с типами), двоичные (Thrift/Protocol Buffers/Avro — эффективны, четкая семантика совместимости). Режимы передачи: БД, RPC, REST, асинхронные сообщения. Важна совместимость для плавающих обновлений и частых развертываний.

---

**Подробнее:** [[Глава 4. Кодирование и эволюция]] [Глава 4. Кодирование и эволюция](Глава 4. Кодирование и эволюция.md)

