# Глава 5. Репликация

Репликация — хранение копий данных на нескольких машинах для повышения доступности и производительности. Три алгоритма: с одним ведущим узлом, с несколькими ведущими узлами, без ведущего узла.

## [[5.1. Ведущие и ведомые узлы]] [5.1. Ведущие и ведомые узлы](../../../полный/Часть 2. Распределенные данные/Глава 5. Репликация/подтемы/5.1. Ведущие и ведомые узлы.md)

**Репликация с ведущим узлом:** одна реплика — ведущая (принимает записи), остальные — ведомые (получают журнал изменений). Чтение возможно с любых реплик, запись — только на ведущую.

**Синхронная и асинхронная репликация:** синхронная — ведущий ждет подтверждения (актуальность, но медленнее). Асинхронная — без ожидания (быстрее, но риск потери данных). Полусинхронная конфигурация: один ведомый синхронный, остальные асинхронные.

**Создание новых ведомых узлов:** снимок состояния → копирование → подключение к журналу репликации.

**Отказ ведомого узла:** восстановление через журнал изменений. **Отказ ведущего узла:** failover включает установление отказа, выбор нового ведущего, перенастройку клиентов. Проблемы: потеря данных при асинхронной репликации, разделение вычислительных мощностей.

**Методы репликации:** операторная (SQL-команды, проблемы с недетерминированными функциями), перенос WAL (низкоуровневый, проблемы совместимости версий), логическая построчная (отделение от структуры хранения, совместимость версий, CDC), триггерная (гибкость, но выше накладные расходы).

## [[5.2 Проблемы задержки репликации]] [5.2 Проблемы задержки репликации](../../../полный/Часть 2. Распределенные данные/Глава 5. Репликация/подтемы/5.2 Проблемы задержки репликации.md)

Асинхронная репликация приводит к конечной согласованности: данные на ведомых узлах могут быть устаревшими.

**Чтение после записи:** пользователь должен видеть свои изменения. Решения: чтение с ведущего для измененных данных, отслеживание времени обновления, метки времени, маршрутизация в один ЦОД.

**Монотонное чтение:** предотвращение "движения во времени назад". Решение: чтение с одной реплики для каждого пользователя.

**Согласованное префиксное чтение:** сохранение причинно-следственной связи. Решение: запись связанных операций в одну секцию, алгоритмы отслеживания зависимостей.

## [[5.3. Репликация с несколькими ведущими узлами]] [5.3. Репликация с несколькими ведущими узлами](../../../полный/Часть 2. Распределенные данные/Глава 5. Репликация/подтемы/5.3. Репликация с несколькими ведущими узлами.md)

Несколько узлов обрабатывают записи и обмениваются изменениями. **Сценарии:** несколько ЦОДов (независимость при сбоях, локальная обработка), офлайн-клиенты (каждое устройство — ведущий), совместное редактирование.

**Обработка конфликтов:** асинхронное обнаружение (конфликты обнаруживаются позже). Предотвращение: все изменения записи через один узел. Конвергентное разрешение: LWW (потеря данных), объединение значений, сохранение конфликтов для пользователя. Пользовательская логика: при записи или чтении. CRDT, операциональное преобразование.

**Топологии:** каждый с каждым (устойчивость), кольцо, звезда (проблемы с порядком сообщений).

## [[5.4. Репликация без ведущего узла]] [5.4. Репликация без ведущего узла](../../../полный/Часть 2. Распределенные данные/Глава 5. Репликация/подтемы/5.4. Репликация без ведущего узла.md)

Клиенты отправляют записи на несколько реплик. **Кворум:** w + r > n гарантирует пересечение множеств записи и чтения. Настройка w и r для баланса между производительностью и согласованностью.

**Нестрогий кворум:** операции на доступных узлах, направленная передача при восстановлении. Повышает доступность, но не гарантирует актуальность.

**Обнаружение конкурентных операций:** связь "происходит до" определяет конкурентность. Номера версий позволяют различать перезапись и конкурентные записи. **Векторы версий:** отслеживание версий каждой реплики для корректного слияния. Слияние конкурентных значений: CRDT, отметки об удалении (tombstones).

## [[5.5 Резюме]] [5.5 Резюме](../../../полный/Часть 2. Распределенные данные/Глава 5. Репликация/подтемы/5.5 Резюме.md)

Три метода репликации имеют разные компромиссы. Асинхронная репликация быстрее, но может привести к потере данных. Модели согласованности (чтение после записи, монотонное чтение, согласованное префиксное чтение) помогают справляться с задержками. Разрешение конфликтов критично для многоузловых систем.

---

**Подробнее:** [[Глава 5. Репликация]] [Глава 5. Репликация](Глава 5. Репликация.md)

