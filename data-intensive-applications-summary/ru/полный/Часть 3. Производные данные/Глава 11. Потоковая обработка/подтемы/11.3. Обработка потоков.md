До сих пор мы говорили в этой главе о том, откуда поступают потоки (события, сообщающие о действиях пользователей, показаниях датчиков, операциях записи в базу данных), и о том, как они переносятся (с помощью прямого обмена сообщениями, через брокеров сообщений, журналы событий).

## Три варианта обработки потоков

1. **Извлекать данные из событий и записывать их в БД, кэш, поисковый индекс** — это хороший способ синхронизировать базу с изменениями, происходящими в других частях системы
2. **Передавать события пользователям** — например, отправив оповещения по электронной почте, или выдавая предупреждения, или транслируя поток событий на панель мониторинга в реальном времени
3. **Обрабатывать один или несколько входных потоков и создавать один или несколько выходных** — потоки могут проходить через конвейер, состоящий из нескольких этапов обработки

## Применение обработки потоков

**Мониторинг:**
- Системы обнаружения мошенничества
- Торговые системы
- Системы производства
- Военные и разведывательные системы

**Обработка сложных событий (CEP):**
- Технология, разработанная в 1990-х годах для анализа потоков событий
- Позволяет создавать правила для поиска в потоке событий, соответствующих заданным шаблонам
- В системах CEP часто применяется декларативный язык запросов высокого уровня, такой как SQL
- Примеры: Esper, IBM InfoSphere Streams, Apama, TIBCO StreamBase, SQLstream

**Аналитика потоков:**
- Измерение частоты событий определенного типа
- Вычисление скользящего среднего значения за некоторый период времени
- Сравнение текущих статистических показателей с данными за предшествующие временные интервалы
- Временной интервал, в течение которого выполняется сбор данных, называется окном
- Примеры: Apache Storm, Spark Streaming, Flink, Concord, Samza, Kafka Streams

**Поддержка материализованных представлений:**
- Поток изменений в базе данных может использоваться для того, чтобы информация в производных информационных системах соответствовала тому, что хранится в исходной базе
- Для построения материализованного представления потенциально потребуются все события за произвольный период времени

**Поиск в потоках:**
- Системы CEP позволяют находить события, удовлетворяющие заданному шаблону
- Иногда требуется и поиск событий по сложным критериям, таким как полнотекстовые поисковые запросы
- Пример: фильтр в Elasticsearch

## Рассуждения о времени

**Время наступления и время обработки события:**
- В пакетном процессе задачи обработки быстро проходят по большому набору исторических событий
- Пакетный процесс ориентируется по временным меткам, встроенным в каждое событие
- Во многих потоковых системах обработки для определения временного окна используются локальные системные часы вычислительной машины (время обработки)
- Есть много причин, по которым обработка может задерживаться: очередь, сетевые сбои, низкая производительность, перезапуск потребителя потока, повторная обработка прошлых событий

**Как узнать о готовности:**
- Сложность с определением временных окон с точки зрения времени наступления события заключается в том, что вы никогда не можете быть уверены в получении всех событий для определенного временного окна
- Два варианта: игнорировать отставшие события или опубликовать поправку, обновленное значение для данного временного окна с учетом отставших событий

**Чьи часы вы используете:**
- Временная метка событий должна быть действительным временем, в которое произошло данное действие пользователя
- Применяется подход с регистрацией трех временных меток: время, когда произошло событие, по часам устройства; время, когда событие было отправлено на сервер, по часам устройства; время, когда событие было получено сервером, по часам сервера

**Типы временных окон:**
- **«Падающее» окно** — имеет постоянную длину, и каждое событие принадлежит только одному окну
- **«Прыгающее» окно** — имеет фиксированную длину, но окна могут перекрываться для обеспечения некоторого сглаживания
- **Скользящее окно** — содержит все события, происходящие с некоторыми интервалами между собой
- **Окно сессии** — определяется как множество всех событий для одного и того же пользователя, которые происходят близко друг к другу во времени

## Объединения потоков

**Объединение «поток — поток» (объединение окон):**
- Для реализации этого типа объединения поточный процессор должен поддерживать состояния, например все события, произошедшие за последний час и индексированные по ID сессии
- Пример: расчет процента переходов по ссылкам для каждого URL в результатах поиска

**Объединения «поток — таблица» (обогащение потока):**
- На входе поток событий активности, содержащих ID пользователя, а на выходе — поток событий активности, в которых идентификатор дополнен информацией о его профиле
- Локальная копия БД потокового процессора должна обновиться при изменении содержимого базы
- Потоковый процессор может подписаться на журнал изменений пользовательских профилей в базе данных

**Объединения «таблица — таблица» (материализованная поддержка представлений):**
- Пример: лента сообщений Twitter
- Для реализации такого обслуживания кэша в потоковом процессоре нужны потоки событий для твитов (отправка и удаление) и отношения подписки (отслеживание и устранение)
- Процесс потока должен поддерживать базу данных, содержащую набор подписчиков для каждого пользователя

**Зависимость объединений от времени:**
- Важна последовательность событий, поддерживающих состояние
- Если порядок событий в потоке не определен, то объединение становится недетерминированным
- В складах данных эта проблема известна как медленно меняющееся измерение (SCD)

## Отказоустойчивость

**Микропакеты и контрольные точки:**
- Разбить поток на небольшие блоки и рассматривать каждый из них как миниатюрный пакетный процесс
- Такой подход называется микропакетами и используется в Spark Streaming
- Вариант этой технологии, реализованный в Apache Flink, периодически генерирует контрольные точки состояния и записывает их в долговременное хранилище

**Подтверждение малых изменений:**
- Чтобы в случае сбоя повторно обрабатывать данные только один раз, необходимо гарантировать следующее: все выходные данные и побочные эффекты обработки события вступают в силу тогда и только тогда, когда обработка прошла успешно
- Все указанные действия либо должны входить в состав атомарной операции, либо ни одно из них не должно произойти
- Такой подход реализован в Google Cloud Dataflow и VoltDB

**Идемпотентность:**
- Идемпотентная операция — это такая операция, которую можно выполнять несколько раз, и результат будет таким же, как если бы ее выполнили только один раз
- Даже если операция по своей природе не является идемпотентной, ее часто можно сделать таковой, задействовав небольшое количество дополнительных метаданных
- Пример: в Kafka каждое сообщение имеет постоянное монотонно увеличивающееся смещение

**Восстановление состояния после сбоя:**
- Любой потоковый процесс, требующий состояния, должен гарантировать, что это состояние может быть восстановлено после сбоя
- Можно сохранять состояние локально в потоковом процессоре и периодически реплицировать его
- Примеры: Flink периодически делает снимки состояния оператора и записывает их в надежное хранилище; Samza и Kafka Streams реплицируют изменения состояния, отправляя их в специальную тему Kafka с уплотнением журнала

