В этой книге многократно повторялась идея о том, что у любой проблемы есть несколько решений, у каждого из которых — свои достоинства, недостатки и компромиссы. В случае проблемы — например, «я хочу сохранить некие данные и позже снова их просмотреть» — нет ни одного правильного решения, но зато есть много разных подходов, более или менее приемлемых, в зависимости от ситуации.

## Объединение специализированных инструментов путем сбора информации

В сложных приложениях данные часто задействуются несколькими способами. Вряд ли найдется один программный продукт, который подойдет для всех вариантов использования данных, поэтому вам, чтобы обеспечить функционирование приложения, неизбежно приходится объединять несколько таких продуктов.

**Примеры интеграции:**
- Интеграция в базу данных OLTP полнотекстового поискового индекса
- Хранение копий в аналитических системах (складах данных и системах пакетной и потоковой обработки)
- Поддержка кэшей или денормализованных версий объектов
- Пропуск информации через системы машинного обучения, классификации, ранжирование или выдачу рекомендаций
- Отправка уведомлений, основанных на изменении данных

## Рассуждения об информационных потоках

Если копии одних и тех же данных должны обслуживаться несколькими системами хранения информации, в соответствии с разными шаблонами доступа, то необходимо четко разделить входные и выходные данные: куда они записываются вначале, какие представления и из каких источников формируются?

**Принцип единой системы записи:**
- Можно вначале построить систему записей в базу данных и прежде всего заносить информацию туда, фиксируя внесенные изменения, а затем применяя их к поисковому индексу в том же порядке
- Если единственным способом обновления индекса является сбор данных об изменениях (CDC), то вы можете быть уверены, что индекс полностью получен из системы записи и, следовательно, будет с ней совместим
- Запись в базу является единственным способом ввести данные в эту систему

**Проблема двойной записи:**
- Позволяя приложению напрямую записывать данные в поисковый индекс и базу, мы рискуем получить проблему, где два клиента конкурентно отправляют конфликтующие записи, а две системы хранения обрабатывают их в другом порядке
- Если есть возможность пропустить пользовательские входные данные через единую систему, которая принимает решение о последовательности всех операций записи, то будет намного проще получить другие представления данных

## Производные данные и распределенные транзакции

**Различия между производными системами и распределенными транзакциями:**
- При использовании распределенных транзакций последовательность записей определяется благодаря блокировкам взаимного исключения, в то время как с помощью CDC и источников событий последовательность событий выстраивается по журналу
- В распределенных транзакциях для гарантии того, что изменения вступают в силу ровно один раз, применяется технология атомарных фиксаций; системы на основе журнала, напротив, часто опираются на детерминированные повторы и идемпотентность
- Транзакционные системы обычно обеспечивают линеаризуемость; производные информационные системы часто обновляются асинхронно, поэтому по умолчанию не обеспечивают такие же гарантии хронометража

**Ограничения распределенных транзакций:**
- У XA низкие показатели отказоустойчивости и производительности, что серьезно ограничивает ее применимость
- В отсутствие хорошего протокола распределенных транзакций, пользующегося широкой поддержкой, наиболее перспективной технологией интеграции различных систем я считаю производные данные на основе журналирования

## Ограничения тотального журналирования

По мере развития системы становятся все крупнее, потоки данных в них усложняются, и возникают следующие ограничения:

**Проблемы масштабирования:**
- В большинстве случаев для построения полностью упорядоченного журнала требуется, чтобы все события проходили через единый ведущий узел
- Если плотность событий больше, чем может обрабатывать один компьютер, то необходимо разделить нагрузку на несколько машин, и тогда порядок событий в разных секциях будет неоднозначен

**Географическое распределение:**
- Если серверы находятся в разных, географически разделенных ЦОДах, то обычно в каждом ЦОДе есть по одному ведущему узлу
- Это приводит к неопределенной последовательности событий, происходящих в разных центрах

**Микросервисы:**
- При развертывании приложений в виде микросервисов построение общей архитектуры заключается в том, чтобы развернуть каждый сервис и его долговременное хранилище как отдельный модуль
- Когда два события поступают из разных сервисов, у этих событий нет определенной последовательности

**Офлайн-клиенты:**
- Отдельные приложения поддерживают хранение состояния на стороне клиента, которое обновляется сразу после ввода пользователем данных
- В таких приложениях клиенты и серверы, скорее всего, будут видеть события в разной последовательности

## Упорядочение событий для сохранения причинно-следственных связей

Когда между событиями нет причинно-следственной связи, отсутствие общей последовательности не является большой проблемой, поскольку конкурентные события могут быть упорядочены произвольно.

**Проблема причинно-следственных связей:**
- Некоторые случаи легко разрешимы: например, несколько обновлений одного и того же объекта можно полностью упорядочить, направляя все обновления для объекта с определенным ID в один раздел журнала
- Однако бывают и более тонкие причинно-следственные связи

**Решения:**
- Логические метки времени обеспечивают полное упорядочение без согласования, так что могут помочь в тех случаях, когда рассылка общей последовательности невозможна
- Если можно внести в журнал событие с записью состояния системы, которое пользователь видел перед принятием решения, и присвоить этому событию уникальный идентификатор, то для сохранения причинно-следственной связи все последующие события могут ссылаться на этот ID
- Алгоритмы разрешения конфликтов помогают обрабатывать события, которые были доставлены с нарушением последовательности

## Пакетная и потоковая обработка

Цель интеграции данных — гарантировать, что данные попадают во все нужные места, будучи представленными в нужной форме. Инструментами для достижения цели являются пакетные и потоковые процессоры.

**Результаты пакетных и потоковых процессов:**
- Поисковые индексы
- Материализованные представления
- Рекомендации для пользователей
- Совокупные показатели

**Различия между пакетной и потоковой обработкой:**
- Потоковые процессоры работают с неограниченными наборами данных, тогда как входные данные пакетного процесса имеют известный конечный размер
- В Spark потоковая обработка выполняется на базе процессора пакетной обработки с разбиением потока на микропакеты, в Apache Flink же пакетная обработка выполняется на базе системы потоковой обработки

## Сопровождение производного состояния

**Принципы:**
- У пакетной обработки довольно сильный функциональный привкус: он поощряет детерминированные, чистые функции, у которых выходные данные зависят только от входных
- Входные данные обрабатываются как неизменяемые, а выходные — в режиме дописывания
- Обработка потоков аналогична, но расширяет возможности операторов, чтобы обеспечить управляемое отказоустойчивое состояние

**Асинхронность:**
- В принципе, производные информационные системы могут поддерживаться синхронно, подобно тому, как реляционная база данных синхронно обновляет вторичные индексы
- Однако асинхронность является тем, что делает системы, основанные на журналах событий, надежными: благодаря ей локальные ошибки не выходят за пределы своей части системы

## Повторная обработка данных при развитии приложения

**Преимущества повторной обработки:**
- Потоковая обеспечивает низкую задержку при отражении входных данных в производных представлениях
- Пакетная позволяет обрабатывать большие объемы накопленной исторической информации и получать новые представления на основе существующего набора данных
- Обработка существующей информации — хороший механизм для обслуживания схемы и ее развития

**Миграции схемы:**
- Без повторной обработки эволюция схемы ограничивается простыми изменениями наподобие добавления к записи необязательного поля
- При повторной обработке можно преобразовать набор данных в совершенно другую модель, которая лучше соответствует новым требованиям
- Производные представления позволяют развивать систему постепенно

## Лямбда-архитектура

**Основная идея:**
- Записывать входные данные путем добавления неизменяемых событий к постоянно растущему набору данных
- Запустить две разные системы параллельно: систему пакетной обработки и отдельную систему потоковой обработки
- Потоковый процессор потребляет события и быстро создает приблизительное обновление представления; пакетный процессор позже потребляет тот же набор событий и выстраивает уточненную версию производного представления

**Практические проблемы:**
- Необходимость поддерживать одну и ту же логику как для пакетной, так и для потоковой системы обработки — это значительные дополнительные усилия
- Поскольку потоковый и пакетный конвейеры производят разные выходные данные, для ответа на запросы пользователей эти данные необходимо объединить
- Иметь возможность повторной обработки всего исторического набора данных — это прекрасно, однако большие наборы данных нередко требуют значительных вычислительных затрат

