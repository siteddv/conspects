В базе данных с конечной согласованностью при направлении одинакового запроса одновременно в две разные реплики можно получить два разных ответа. Это сбивает с толку. Разве не было бы намного проще, если бы база могла создать у пользователя иллюзию, что существует только одна реплика (то есть только одна копия данных)? Тогда у каждого клиента было бы одинаковое представление о данных, и не пришлось бы беспокоиться о задержке репликации.

## Основная идея линеаризуемости

**Линеаризуемость** (также известная как атомарная согласованность, сильная согласованность, непосредственная согласованность и внешняя согласованность) — это гарантия, что система внешне выглядела так, как если бы в ней была только одна копия данных и все операции с ними были атомарными. С такой гарантией, даже при наличии на самом деле множества реплик, приложению не приходится о них беспокоиться.

В линеаризуемой системе сразу же после удачного завершения клиентом записи все клиенты, читающие БД, должны иметь возможность видеть только что написанное значение. Поддержание иллюзии единственной копии данных означает гарантию того, что прочитанное значение является самым последним обновленным значением и не связано с устаревшим кэшем или репликой. Другими словами, **линеаризуемость есть гарантия актуальности**.

## Что делает систему линеаризуемой

В основе линеаризуемости лежит простая идея: снаружи система должна вести себя так, как если бы в ней существовала только одна копия данных. Для понимания того, что именно это означает, нужно рассмотреть несколько примеров.

**Основные правила линеаризуемости:**
- Если запрос чтения осуществляется конкурентно запросу на запись, то он может вернуть либо старое, либо новое значение
- После того как операция чтения вернет новое значение, все последующие операции чтения (для этого и других клиентов) также должны возвращать новое значение
- Операции должны быть упорядочены в единую последовательность, которая согласуется с реальным порядком их выполнения

## Линеаризуемость и последовательность

Линеаризуемость часто путают с сериализуемостью, поскольку кажется, что оба слова означают нечто вроде «можно упорядочить в виде последовательности». Однако они представляют собой две совершенно разные гарантии:

- **Сериализуемость** — гарантия изоляции транзакций (избежание условий гонки из-за конкурентного выполнения транзакций). Это свойство транзакций, а не отдельных операций чтения/записи.
- **Линеаризуемость** — гарантия возврата при чтении и записи реестра (отдельного объекта). Она не объединяет операции в транзакции, поэтому не предотвращает таких проблем, как асимметрия записи, если не предпринять дополнительные меры.

База данных может обеспечивать как сериализуемость, так и линеаризуемость. Это сочетание известно как **строгая сериализуемость** или **сильная сериализуемость с одной копией** (1SR-сильная).

## Опора на линеаризуемость

В каких случаях полезна линеаризуемость?

### Блокировка и выбор ведущего узла

Система, использующая репликацию с одним ведущим узлом, должна гарантировать, что только один узел считает себя ведущим. Выбор ведущего узла — это консенсусная проблема, которая требует линеаризуемого хранилища. Аналогично, распределенные блокировки должны быть линеаризуемыми.

### Ограничения и гарантии уникальности

Когда требуется обеспечить ограничения уникальности (например, уникальность имени пользователя или файла), нужна линеаризуемость. Например, когда два человека пытаются конкурентно создать пользователя или файл с одинаковыми именами, одна из этих операций должна завершиться с ошибкой.

### Межканальные синхронизационные зависимости

Когда в системе есть несколько каналов связи (например, хранилище файлов и очередь сообщений), линеаризуемость гарантирует автоматическое сохранение причинности между этими каналами, предотвращая условия гонки.

## Реализация линеаризуемых систем

Поскольку линеаризуемость означает «вести себя так, как будто существует только одна копия данных и все операции над ней являются атомарными», самым простым ответом было бы действительно использовать только одну такую копию. Однако этот вариант не позволяет справляться с отказами.

Наиболее распространенным методом обеспечения отказоустойчивости является использование репликации. Различные методы репликации обеспечивают линеаризуемость по-разному:

- **Репликация с одним ведущим узлом** (потенциально линеаризуемая): если операции чтения обслуживаются ведущим узлом или синхронно обновляемыми ведомыми, то они могут быть линеаризуемыми. Однако на практике не каждая база данных с одним ведущим узлом является линеаризуемой.
- **Консенсусные алгоритмы** (линеаризуемые): консенсусные протоколы содержат меры, позволяющие предотвратить разделение интеллекта и использование устаревших реплик. Так работают ZooKeeper и etcd.
- **Репликация с несколькими ведущими узлами** (нелинеаризуемая): обычно не является линеаризуемой, поскольку конкурентно обрабатывает записи на нескольких узлах.
- **Репликация без ведущего узла** (не всегда линеаризуемая): даже при строгих кворумах возможно нелинеаризуемое поведение из-за условий гонки.

## Цена линеаризуемости

Поскольку одни методы репликации обеспечивают линеаризуемость, а другие — нет, важно исследовать преимущества и недостатки линеаризуемости.

### Теорема CAP

При нарушении связи по сети между двумя ЦОДами возникает компромисс:
- Если приложение требует линеаризуемости, а некоторые реплики не имеют доступа к другим репликам из-за проблем в сети, то эти реплики не могут обрабатывать запросы, пока они отключены: они должны либо ждать, пока связь будет восстановлена, либо возвращать ошибку (в любом случае они становятся недоступными).
- Если приложение не требует линеаризуемости, то оно может быть записано таким образом, чтобы каждая реплика могла обрабатывать запросы независимо, даже будучи отключенной от других реплик. Тогда приложение может оставаться доступным даже в случае проблем с сетью, но его поведение нелинеаризуемо.

Это представление широко известно как **теорема CAP** (Consistency, Availability, Partition tolerance). Однако в действительности все не так просто: нарушение связности сети является своего рода ошибкой, у нас нет выбора — нарушение связности будет, нравится это или нет. В тех случаях, когда сеть работает правильно, система может обеспечивать и согласованность (линеаризуемость), и доступность из любой точки. При возникновении сбоя в сети приходится выбирать либо линеаризуемость, либо доступность.

**Критика теоремы CAP:**
- В обсуждениях, касающихся CAP, есть несколько противоречивых определений термина «доступность»
- Теорема CAP имеет очень узкую область применения: она рассматривает только одну модель согласованности (линеаризуемость) и один вид сбоя (нарушение связности сети)
- В ней ничего не говорится о задержках в сети, мертвых узлах и других компромиссах
- Хотя теорема CAP имеет историческое значение, она малоприменима на практике при проектировании систем

### Линеаризуемость и сетевые задержки

Хотя линеаризуемость и является полезной гарантией, на практике удивительно мало систем являются линеаризуемыми. Причиной снижения линеаризуемости во многих случаях является не отказоустойчивость, а **производительность**.

**Доказательство о производительности:**
Х. Аттия и Дж. Уэлч доказали, что если нужно реализовать линеаризуемость, то время отклика запросов на чтение и запись будет по крайней мере пропорционально времени неопределенных сетевых задержек. В сети с очень разновременными задержками время отклика для линеаризуемых операций чтения и записи неизбежно будет высоким. Более быстрый алгоритм для линеаризуемости не существует, но более слабые модели согласованности могут оказаться гораздо быстрее.

Этот компромисс важен для систем, чувствительных к задержкам. В главе 12 мы обсудим некоторые методы, позволяющие избежать линеаризуемости, не жертвуя корректностью.

