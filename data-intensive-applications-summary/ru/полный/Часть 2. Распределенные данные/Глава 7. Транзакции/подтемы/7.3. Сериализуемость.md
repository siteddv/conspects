Глава обсуждает проблемы гонок состояний в транзакциях, включая асимметрию записи и фантомы. Уровни изоляции данных реализуются по-разному в разных БД, что делает их использование сложным. Отсутствие инструментов для выявления состояний гонки усложняет тестирование. Решением является использование сериализуемости, которая гарантирует правильность выполнения транзакций как при последовательном, так и при конкурентном их выполнении. Рассматриваются три метода реализации сериализуемости: последовательное выполнение, двухфазная блокировка и оптимистическое управление конкурентным доступом.

### Последовательное выполнение

Простейший способ избежать проблем с конкурентным доступом — выполнять транзакции последовательно, в одном потоке. Этот подход стал популярным в 2007 году, когда дешевые RAM и осознание, что OLTP-транзакции обычно короткие, позволили эффективно работать с данными в памяти. Системы, использующие однопоточное выполнение, такие как VoltDB, Redis и Datomic, часто показывают лучшую производительность, чем многопоточные, так как не тратят ресурсы на блокировки. Однако их пропускная способность ограничена одним ядром CPU, что требует особой организации транзакций.

### Инкапсуляция транзакций в хранимых процедурах

В начале эры баз данных транзакции предполагалось делать атомарными для целых процессов, например, бронирования авиабилетов. Однако, когда транзакция включает ожидание ввода данных пользователем, это требует поддержания множества конкурентных транзакций, что не всегда эффективно. В результате, большинство OLTP-приложений сокращают продолжительность транзакций, исключая ожидания в интерактивном режиме. В веб-технологиях это означает, что каждая новая HTTP-запрос инициирует отдельную транзакцию.

В интерактивном режиме транзакции выполняются пошагово, что увеличивает время на обмен сетевыми сообщениями между приложением и базой данных. Для повышения производительности требуется обработка нескольких транзакций одновременно. Поэтому в системах с однопоточным выполнением транзакций интерактивные многооператорные транзакции исключены. Вместо них транзакции выполняются через хранимые процедуры, что значительно ускоряет процесс, так как данные уже находятся в оперативной памяти и не требуется ожидание ввода/вывода.

![[44. Stored procedure vs interactive transaction.png]] [44. Stored procedure vs interactive transaction.png](44. Stored procedure vs interactive transaction.png.md)

### Достоинства и недостатки хранимых процедур

Хранимые процедуры, являющиеся частью стандарта SQL с 1999 года, долго имели плохую репутацию из-за различных языков реализации (PL/SQL, T-SQL, PL/pgSQL) и ограниченной поддержки новшеств. Эти языки отставали от современных языков программирования и не имели широких библиотек. Также выполнение кода в базе данных сложнее структурировать и отлаживать, а ошибки в хранимых процедурах могут серьезно повлиять на производительность БД. Современные СУБД, такие как VoltDB, Datomic и Redis, используют универсальные языки (Java, Lua), что улучшает гибкость. Хранимые процедуры в таких системах позволяют выполнять транзакции в одном потоке, обеспечивая высокую производительность без ожидания ввода/вывода и блокировок. В VoltDB хранимые процедуры также используются для репликации данных, требуя детерминированных результатов.

### Секционирование

Последовательное выполнение транзакций упрощает контроль версий, но ограничивает пропускную способность базы данных, так как зависит от скорости одного ядра процессора. Для масштабирования можно секционировать данные, как это делает VoltDB, чтобы каждая транзакция работала с отдельной секцией данных, позволяя использовать несколько ядер CPU. Однако для транзакций, затрагивающих несколько секций, необходимо синхронизировать выполнение по всем секциям, что снижает производительность. Транзакции с несколькими секциями работают гораздо медленнее, и добавление новых машин не повышает их пропускную способность. Возможность сделать транзакцию односекционной зависит от структуры данных, при этом простые данные легко секционировать, а данные с вторичными индексами требуют сложного согласования.

### Краткое резюме последовательного выполнения

Последовательное выполнение транзакций, применяемое для изоляции снимков состояния, имеет несколько ограничений. Все транзакции должны быть быстрыми, иначе медленная транзакция может замедлить работу всей системы. Набор данных должен помещаться в память, иначе система замедлится при доступе к данным на диске. Пропускная способность по записи должна быть низкой для обработки на одном ядре CPU. Многосекционные транзакции возможны, но их использование ограничено. Для работы с данными вне памяти используется подход антикэширования, при котором данные загружаются асинхронно.

### Двухфазная блокировка (2PL)

Двухфазная блокировка (2PL) — алгоритм для обеспечения сериализуемости транзакций в базах данных. В отличие от обычных блокировок, 2PL требует, чтобы транзакция сначала блокировала все необходимые ресурсы, а затем выполняла операции, после чего блокировки освобождаются. Это исключает конкуренцию за ресурсы, предотвращая «грязные» операции записи. В 2PL запрещается чтение объекта, пока другая транзакция его записывает, и наоборот. В отличие от изоляции снимков состояния, 2PL блокирует как чтение, так и запись. 2PL защищает от потери обновлений и асимметрии записи.

### Реализация двухфазной блокировки

Двухфазная блокировка (2PL) используется в СУБД MySQL (InnoDB), SQL Server и DB2 для обеспечения сериализуемости и воспроизводимого чтения. Каждый объект в базе данных может быть заблокирован в двух режимах: разделяемом (для чтения) и монопольном (для записи). Транзакция, читающая объект, получает блокировку в разделяемом режиме, а записывающая — в монопольном. Для записи объект должен быть заблокирован эксклюзивно, и другие транзакции не могут удерживать блокировку. Если транзакция сначала читает, а затем записывает объект, она может повысить блокировку с разделяемой до монопольной. Блокировки удерживаются до завершения транзакции. В случае взаимных блокировок (deadlock), когда транзакции ждут друг друга, база данных автоматически прерывает одну из них для продолжения работы остальных. Приложение должно повторно выполнить прерванную транзакцию.

### Производительность двухфазной блокировки

Основной недостаток двухфазной блокировки (2PL) — низкая производительность. Это связано с затратами на установку и освобождение блокировок, а также с снижением конкурентности транзакций. Транзакции, которые могут вызвать состояние гонки, вынуждены ждать завершения других, что замедляет систему. В реляционных БД, где транзакции могут длиться неопределенно долго, образуются очереди, замедляя работу. Взаимные блокировки при 2PL могут привести к дополнительным затратам, так как при повторном выполнении транзакции она должна пройти все действия заново, что ухудшает производительность.

### Предикатные блокировки

Для предотвращения фантомов, где одна транзакция изменяет результаты запроса, выполненного другой транзакцией, необходимы предикатные блокировки. Они аналогичны обычным блокировкам, но не ограничиваются конкретным объектом, а распространяются на все объекты, соответствующие определенному условию запроса. Например, при бронировании конференц-зала транзакция A, выполняющая запрос на поиск, должна установить предикатную разделяемую блокировку, чтобы другие транзакции не могли вставить или обновить записи, которые удовлетворяют этому условию, до завершения A. При обновлении данных транзакция A должна проверить, не попадает ли она под условия предикатной блокировки, установленной другой транзакцией, и дождаться ее завершения. Это предотвращает фантомы и обеспечивает полную сериализуемость, устраняя асимметрию записи и другие состояния гонки.

### Блокировки по диапазону значений индекса

Производительность предикатных блокировок часто неудовлетворительная, особенно при большом количестве блокировок, так как проверка соответствия может занимать много времени. Поэтому многие базы данных с 2PL используют блокировку по диапазону значений индекса (или блокировку следующего ключа). Это упрощенный аналог предикатной блокировки. Например, для бронирования конференц-зала можно расширить блокировку, охватывая более широкий диапазон времени или залы. Если база использует индекс по времени, она связывает блокировку с диапазоном значений этого индекса. Этот подход эффективно предотвращает фантомы и асимметрию записи с меньшими затратами, чем предикатные блокировки, обеспечивая при этом безопасность.

### Сериализуемая изоляция снимков состояния (SSI)

Двухфазная блокировка (2PL) — пессимистический метод управления конкурентным доступом, где транзакции ожидают нормализации ситуации перед выполнением действий. Этот подход аналогичен монопольной блокировке на всю базу данных. Напротив, сериализуемая изоляция снимков состояния (SSI) — оптимистический метод, где транзакции выполняются в надежде на отсутствие конфликтов, а при их обнаружении транзакции прерываются и повторяются. SSI эффективна при низкой конкуренции, но может снижать производительность при высокой. SSI использует согласованный снимок состояния базы для чтений и добавляет алгоритм для обнаружения конфликтов при записи.

### Решения, основанные на устаревших исходных условиях

При изоляции снимков состояния транзакция может выполнить действия на основе устаревших данных, если они изменились между чтением и фиксацией. Например, если транзакция основывает свои решения на данных о числе врачей, а эти данные изменились после чтения, это может привести к ошибке. Чтобы обеспечить сериализуемость, база данных должна выявлять такие ситуации и прерывать транзакции. Для этого она отслеживает два случая: когда чтение выполняется на устаревшей версии объекта (незафиксированная запись) и когда запись влияет на ранее прочитанные данные.

### Выявление операций чтения устаревших версий MVCC объектов

Изоляция снимков состояния (MVCC) позволяет транзакции читать согласованный снимок базы, игнорируя незавершенные операции других транзакций. Однако, если данные изменяются между чтением и фиксацией, это может привести к аномалии, когда транзакция использует устаревшие данные. Для предотвращения этой ошибки база отслеживает игнорируемые операции и прерывает транзакцию при фиксации, если эти операции были завершены. Однако, если транзакция только читала данные, прерывать её сразу не нужно, так как возможно, что изменения не повлияют на её результаты.

![[45. Old MVCC versions.png]] [45. Old MVCC versions.png](45. Old MVCC versions.png.md)

### Выявление операций записи, влияющих на предшествующие операции чтения

![[46. Depend on future transactions.png]] [46. Depend on future transactions.png](46. Depend on future transactions.png.md)

В случае, когда другая транзакция модифицирует данные после их чтения, база данных может отслеживать такие изменения с помощью индексов. При чтении данных транзакция отмечает, какие записи были прочитаны. Если другая транзакция пытается модифицировать эти данные, она должна проверить, были ли они прочитаны другими транзакциями. Этот процесс напоминает блокировку диапазона значений, но без реальной блокировки. Если данные были изменены после их чтения, транзакцию, использующую устаревшие данные, нужно прервать.

### Производительность сериализуемой изоляции снимков состояния

Производительность алгоритма сериализуемой изоляции снимков состояния (SSI) зависит от множества факторов, включая уровень детализации отслеживания операций транзакций. Чем более детализировано отслеживание, тем выше точность принятия решений о прерывании транзакций, но это увеличивает издержки. Менее детализированное отслеживание ускоряет процесс, но может привести к ненужным прерываниям. SSI позволяет транзакциям работать независимо, не блокируя друг друга, что улучшает производительность, особенно при высокой нагрузке на чтение. В отличие от двухфазной блокировки, SSI не зависит от одного процессора и масштабируется на несколько машин. Прерывания транзакций в SSI влияют на производительность, но она более устойчива к медленным транзакциям, чем двухфазная блокировка.