В реплицированных базах данных при просмотре двух узлов в один и тот же момент времени, скорее всего, можно увидеть различные данные, потому что запросы на запись поступают на разные узлы в разное время. Эти несоответствия возникают независимо от используемого метода репликации (с одним ведущим узлом, с несколькими ведущими узлами или без ведущего).

## Конечная согласованность

Большинство реплицированных БД обеспечивают по меньшей мере **конечную согласованность** (eventual consistency). Это означает, что если прекратить записывать данные в базу и подождать некоторое неопределенное время, то в конце концов все запросы на чтение вернут одно и то же значение. Другими словами, несогласованность является временной и в конечном итоге устраняется сама собой (при условии устранения всех неисправностей в сети).

Лучшим названием для конечной согласованности могла бы быть **конвергенция**, поскольку мы ожидаем, что все реплики со временем сойдутся к одному и тому же значению.

## Ограничения конечной согласованности

Это очень слабая гарантия. Она ничего не говорит о том, когда именно реплики сойдутся. До момента конвергенции операции чтения могут возвращать что угодно или вообще ничего. Например:

- Если вы запишете значение и сразу же прочтете его снова, то нет никакой гарантии, что увидите то же значение, которое написали
- Чтение может быть перенаправлено на другую реплику, которая еще не получила обновление
- Операция чтения может вообще не удаться

## Проблемы для разработчиков

Конечная согласованность неудобна для разработчиков приложений: она слишком сильно отличается от поведения переменных в обычной однопоточной программе. Если вы присвоите значение переменной и сразу ее прочитаете, то вряд ли будете ожидать, что прочитаете старое значение или что операция чтения вообще не удастся.

Внешне база данных выглядит как переменная, которую можно читать и записывать, но на самом деле ее семантика гораздо сложнее.

## Работа со слабыми гарантиями

При работе с базой данных, обеспечивающей только слабые гарантии, приходится постоянно помнить о ее ограничениях и не рассчитывать на слишком многое. Ошибки в этой области часто трудно найти путем тестирования, потому что большую часть времени приложение может работать хорошо. Пограничные случаи конечной согласованности становятся очевидными только при:

- Сбоях в системе (например, при прерывании соединения с сетью)
- Большом количестве конкурентных процессов

## Более сильные модели согласованности

В этой главе рассматриваются более сильные модели согласованности, пригодные для реализации в информационных системах. У каждой из них есть своя цена:

- Системы с более надежными гарантиями могут иметь худшую производительность
- Могут быть менее отказоустойчивыми, чем системы с более слабыми гарантиями
- Тем не менее системы с более сильными гарантиями могут быть привлекательными, поскольку их легче правильно использовать

Рассмотрев несколько моделей согласованности, можно принимать обоснованные решения о том, какое из них лучше всего соответствует потребностям.

## Связь с изоляцией транзакций

Существует некоторое сходство между распределенными моделями согласованности и иерархией уровней изоляции в транзакциях. Однако, несмотря на ряд совпадений, в основном это независимые задачи:

- **Изоляция транзакций** заключается главным образом в том, чтобы избежать условий гонки из-за конкурентного выполнения транзакций
- **Распределенная согласованность** — координировать состояние реплик в условиях задержек и сбоев

## Структура главы

Эта глава охватывает широкий круг тем, которые на практике глубоко связаны:

1. **Линеаризуемость** — одна из самых сильных моделей согласованности общего назначения, ее достоинства и недостатки
2. **Упорядочение событий** — проблема упорядочения событий в распределенной системе, причинно-следственные связи и единая последовательность
3. **Распределенные транзакции и консенсус** — как обеспечить атомарную фиксацию распределенных транзакций, что в итоге приводит к решениям проблемы консенсуса

