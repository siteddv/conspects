В нашей книге постоянно обсуждается сохранение последовательности; таким образом подразумевается, что это важная фундаментальная идея. Существуют глубокие взаимосвязи между упорядочением, линеаризуемостью и консенсусом.

## Порядок и причинность

Есть несколько причин, почему значение сохранения правильной последовательности продолжает расти, и одна из них такова: это помогает сохранить причинность. В книге нам уже встретилось несколько примеров, где важна причинность:

- **Согласованное префиксное чтение**: участник чата сначала увидел ответ на вопрос, а затем сам вопрос — это нарушает причинно-следственную связь
- **Репликация с несколькими ведущими узлами**: некоторые операции записи могут «обгонять» другие из-за сетевых задержек, что нарушает причинность
- **Обнаружение конкурентных операций записи**: для двух операций A и B существует три возможности: либо A произошла раньше, чем B, либо B произошла раньше, чем A, либо A и B являются конкурентными
- **Изоляция снимков состояний**: транзакция считывается из согласованного снимка состояния, что означает «согласованный с причинностью»

Причинность требует расположения событий в определенном порядке: причина должна идти раньше результата; сообщение отправляется до того, как было получено; вопрос приходит перед ответом. Эти цепочки причинно-зависимых операций определяют причинно-следственный порядок в системе.

В случае подчинения системы последовательности, соответствующей причинно-следственным связям, говорят, что она **причинно-согласованна**.

## Причинно-следственное упорядочение — это не полное упорядочение

**Полное упорядочение** позволяет сравнить два произвольных элемента и в любой момент сказать, какой из них больше, а какой — меньше. **Частичное упорядочение** означает, что в некоторых случаях элементы несравнимы.

Разница между полным и частичным упорядочением отражается в разных моделях согласованности баз данных:

- **Линеаризуемость**: имеет место полное упорядочение операций — для любых двух операций всегда можно сказать, какая из них произошла первой
- **Причинность**: две операции являются конкурентными, если ни одна из них не произошла раньше другой. Это значит, что причинность определяет частичную, а не полную упорядоченность: одни операции упорядочены одна относительно другой, а другие — несравнимы

## Линеаризуемость — более сильная зависимость, чем причинная согласованность

Линеаризуемость подразумевает причинность: любая линеаризуемая система сохранит причинно-следственные зависимости. Однако сделать систему линеаризуемой обычно означает снизить ее производительность и доступность, особенно если ей свойственны значительные сетевые задержки.

**Хорошая новость:** линеаризуемость не единственный способ сохранения причинности, есть и другие. Система может быть причинно-последовательной без падения производительности, возможном при линеаризации. В сущности, **причинно-следственная согласованность — это наиболее сильная модель согласованности, которая не замедляет работу системы из-за сетевых задержек и остается доступной при сбоях сети**.

Во многих случаях системы, на первый взгляд требующие линеаризуемости, в действительности требуют только причинно-следственную согласованность, которая может быть реализована более эффективно.

## Выявление причинно-следственных связей

Для сохранения причинности нужно знать, какая операция произошла раньше, а какая — позже. Когда реплика обрабатывает операцию, она должна гарантировать, что все причинно-предшествующие ей операции уже обработаны; если какая-либо из предыдущих операций отсутствует, то более поздняя операция должна дождаться обработки этой предыдущей операции.

Методы определения того, какая операция произошла раньше, аналогичны тем, что были рассмотрены в подразделе «Обнаружение конкурентных операций записи» раздела 5.4. Для отслеживания причинных зависимостей используют обобщенные векторы версий.

## Упорядоченность по порядковым номерам

Хотя причинность является важной теоретической концепцией, в реальности отслеживание всех причинно-следственных зависимостей может оказаться непрактичным. Для упорядочения событий можно использовать порядковые номера или временные метки. Такая метка не должна ставиться по часам времени суток (физическим часам), а должна опираться на **логические часы** — алгоритм генерации последовательности чисел для идентификации операций.

Порядковые номера обеспечивают полную упорядоченность: каждая операция имеет уникальный порядковый номер; всегда можно сравнить два таких номера, чтобы определить, какой из них больше. Благодаря этому можно строить полную упорядоченность по порядковым номерам, согласующуюся с причинностью: таким образом гарантируется, что если операция A была причиной операции B, то в общей последовательности A идет перед B.

### Генераторы неполных порядковых номеров

Если единого ведущего узла нет, менее понятно, как генерировать порядковые номера для операций. На практике используются следующие методы:

- Каждый узел может генерировать собственный независимый набор порядковых номеров (например, один узел — только нечетные числа, другой — только четные)
- Можно прикреплять к каждой операции временную метку от часов времени суток (физических часов)
- Можно предварительно распределить между узлами диапазоны порядковых номеров

Однако все эти методы имеют проблему: создаваемые ими порядковые номера не согласуются с причинностью.

### Временные метки Лампорта

**Временные метки Лампорта** — простой метод генерации порядковых номеров, который согласуется с причинностью. Каждый узел имеет уникальный идентификатор и хранит счетчик количества обработанных им операций. Временная метка Лампорта — это просто пара типа «счетчик, ID узла».

**Основная идея:** каждый узел и каждый клиент отслеживают максимальное значение счетчика, встречавшееся им до сих пор, и включают данное значение в каждый запрос. Когда узел получает запрос или ответ со значением счетчика, большим, чем его собственное, он немедленно увеличивает свой счетчик до этого максимума.

Эта схема гарантирует, что упорядочение с временными метками Лампорта будет причинно-согласованным: каждая причинная зависимость приводит к увеличению временной метки.

**Отличие от векторов версий:** временные метки Лампорта всегда обеспечивают полное упорядочение, тогда как векторы версий позволяют определить, являются ли две операции конкурентными, или же одна из них — следствие другой.

## Временных меток недостаточно

Несмотря на то что временные метки Лампорта определяют полную последовательность операций, которая согласуется с причинностью, их недостаточно для решения многих распространенных проблем, возникающих в распределенных информационных системах.

**Проблема:** полное упорядочение операций возникает только после того, как были собраны все операции. Если другой узел сгенерировал некоторые операции, но вы еще не знаете, что они собой представляют, то не можете построить полную последовательность операций.

Для реализации чего-то вроде ограничения по уникальности для имен пользователей недостаточно полного упорядочения операций — также необходимо знать, когда будет построена окончательная последовательность.

## Рассылка общей последовательности

**Рассылка общей последовательности** (также известная как атомарная рассылка или многоадресная рассылка полной последовательности) — это протокол обмена сообщениями между узлами, который требует, чтобы всегда выполнялись два следующих требования безопасности:

- **Надежная доставка**: ни одно сообщение не должно быть потеряно. Если сообщение доставляется одному узлу, то оно доставляется всем узлам.
- **Полностью упорядоченная доставка**: сообщения доставляются во все узлы в одном и том же порядке.

Корректный алгоритм рассылки общей последовательности должен гарантировать, что функции надежности и упорядоченности выполняются всегда, даже если узел или сеть неисправны.

### Использование рассылки общей последовательности

- **Репликация базы данных**: если каждое сообщение представляет собой запись в базу и каждая реплика обрабатывает одни и те же записи в той же последовательности, то реплики будут оставаться согласованными между собой. Этот принцип известен как **репликация конечных автоматов**.
- **Сериализуемые транзакции**: если каждое сообщение представляет собой детерминированную транзакцию, которая должна выполняться как хранимая процедура, и если каждый узел обрабатывает эти сообщения в одном и том же порядке, то разделы и реплики базы данных будут согласованы между собой.
- **Сервис блокировки**: каждый запрос на получение блокировки заносится в журнал как сообщение. Все сообщения последовательно нумеруются в порядке их появления в журнале. Затем эти порядковые номера могут служить ограждающими маркерами.

### Реализация линеаризуемого хранилища с помощью рассылки общей последовательности

Рассылка общей последовательности асинхронна: она гарантирует надежную доставку сообщений в фиксированном порядке, но не гарантирует время доставки сообщений. Напротив, линеаризуемость гарантирует своевременность: операция чтения заведомо выдаст последнее записанное значение.

Однако при наличии рассылки общей последовательности можно создать на ее основе линеаризуемое хранилище. Например, для обеспечения уникальности имени пользователя можно использовать линеаризуемый реестр с атомарной операцией сравнения с присвоением, реализованный через рассылку общей последовательности как журнал с разрешением только на дополнение.

### Реализация рассылки общей последовательности с помощью линеаризуемого хранилища

Можно посмотреть на этот метод с другой стороны: предположить, что у нас имеется линеаризуемое хранилище, и показать, как построить на его основе рассылку общей последовательности.

Самый простой способ — предположить, что у нас есть линеаризуемый реестр, который хранит целое число и позволяет выполнять атомарную операцию приращения с чтением. Для каждого сообщения, которое мы хотим отправить через рассылку общей последовательности, выполняем операцию приращения с чтением и получаем линеаризуемое целое число, а затем прикрепляем полученное значение реестра к сообщению в виде порядкового номера.

**Важное отличие от временных меток Лампорта:** числа, которые мы получаем в результате приращения линеаризуемого реестра, образуют последовательность без пропусков. Таким образом, если узел доставил сообщение 4 и получает входящее сообщение с порядковым номером 6, то знает, что сначала должен дождаться сообщения 5.

**Связь с консенсусом:** можно доказать, что линеаризуемый реестр сравнения с присвоением (или приращения с чтением) и рассылка общей последовательности эквивалентны консенсусу. Другими словами, если одна из указанных проблем решена, то она превращается в решение для других.

