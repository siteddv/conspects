Глава о репликации данных рассматривает её важность и цели, такие как **высокая доступность**, **работа в офлайн-режиме**, **снижение задержки** и **масштабирование**. Репликация позволяет системе продолжать работу в случае отказов узлов или сетевых проблем, повышать производительность за счёт распределения запросов на реплики, а также обеспечивать низкую задержку за счёт географически близких копий данных.

Хотя задача репликации кажется простой (копирование данных на несколько машин), на практике она сложна и требует учета конкурентного доступа, сбоев и их последствий. Проблемы включают недоступные узлы, разрывы сети и даже порчу данных из-за программных ошибок.

Рассмотрены три основных метода репликации:

1. **Репликация с одним ведущим узлом**: Все операции записи отправляются на ведущий узел, который распространяет изменения на ведомые узлы. Операции чтения могут происходить с любых реплик, но данные с ведомых узлов могут быть устаревшими.

2. **Репликация с несколькими ведущими узлами**: Записи отправляются на один из нескольких ведущих узлов, которые синхронизируют данные друг с другом и с ведомыми репликами. Это повышает отказоустойчивость и уменьшает риски потери данных.

3. **Репликация без ведущего узла**: Клиенты могут отправлять записи на несколько узлов, а чтение происходит с разных реплик для поиска актуальных данных. Это устраняет зависимость от одного узла, но требует корректировки данных при обнаружении устаревших значений.

Каждый метод имеет свои достоинства и недостатки. Репликация с одним ведущим узлом проще в реализации, но уязвима к сбоям. Репликация с несколькими ведущими узлами и без ведущего узла более устойчива, но сложнее в реализации и требует более слабых гарантий согласованности.

Репликация может быть **синхронной** или **асинхронной**. Асинхронная репликация быстрее, но может привести к потере данных при сбоях, если данные не успели быть реплицированы до отказа ведущего узла.

Кроме того, обсуждены проблемы, связанные с задержкой репликации, и несколько моделей согласованности, которые помогают системе правильно реагировать на такие задержки:
- **Согласованность типа «чтение после записи»**: Пользователь всегда видит данные, которые он сам только что записал.
- **Монотонное чтение**: После того как пользователь увидел данные на определённый момент времени, он не должен увидеть более старую версию.
- **Согласованное префиксное чтение**: Данные отображаются в порядке их зависимостей, например, вопрос и ответ должны быть видны в правильном порядке.

В заключение, рассматриваются вопросы **конкурентного доступа** и разрешения конфликтов при репликации. В случае нескольких конкурентных операций записи возможны конфликты, которые решаются через алгоритмы слияния конкурентных обновлений, что позволяет поддерживать согласованность данных в системе.