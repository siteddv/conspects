Часы и точное измерение времени критичны для приложений, таких как определение истечения времени ожидания, расчет времени отклика, запросов в секунду или времени, проведенного на сайте. В распределенных системах проблемы возникают из-за различных часов на машинах, которые могут быть неточными. Для синхронизации используется NTP, который позволяет компьютерам подстраивать свои часы с учетом времени, передаваемого серверами, получающими информацию от точных источников, например, GPS.

### Монотонные часы и часы истинного времени

В современных компьютерах существует как минимум две разновидности часов:
часы истинного времени (time-of-day clock) и монотонные часы (monotonic clock).
Хотя и те и другие измеряют время, необходимо их различать, поскольку они слу-
жат разным целям.

### Часы истинного времени

Часы истинного времени возвращают дату и время согласно календарю (например, с начала эры UNIX). Функции, как clock_gettime(CLOCK_REALTIME) в Linux или System.currentTimeMillis() в Java, предоставляют количество секунд с полуночи 1 января 1970 года по UTC. Эти часы синхронизируются через NTP, но могут быть сброшены, если локальное время сильно отличается от серверного. Из-за игнорирования секунд координации и прыжков времени они не подходят для измерения прошедшего времени. Ранее разрешение часов было грубым, но современные системы решают эту проблему.

### Монотонные часы

Монотонные часы, такие как clock_gettime(CLOCK_MONOTONIC) в Linux и System.nanoTime() в Java, подходят для измерения продолжительности времени, например, времени отклика. Они всегда движутся вперед, в отличие от часов истинного времени, которые могут прыгать назад. Монотонные часы измеряют только прошедшее время, но их абсолютные значения не имеют смысла, и их нельзя сравнивать между разными компьютерами. NTP подстраивает частоту монотонных часов, но не изменяет их значения вперед или назад. Разрешение таких часов обычно достаточно высокое, до микросекунд.

### Синхронизация часов и их точность

Для обеспечения точности времени, необходимо синхронизировать часы с внешними источниками, такими как NTP-серверы, поскольку аппаратные часы и NTP имеют свои ограничения. Например, кварцевые часы компьютера могут отклоняться от точного времени из-за температуры (расхождение до 6-17 миллисекунд). NTP-серверы могут отказать в синхронизации при большом расхождении или проблемах с конфигурацией, а также могут быть ограничены сетевой задержкой (ошибка до 1 секунды). Виртуальные машины добавляют дополнительные проблемы, поскольку их аппаратные часы также виртуализируются. Секунды координации (59-61 секунда) могут нарушать точность, что вызывает сбои в системах. Для достижения высокой точности (например, в высокочастотной торговле), требуется использование GPS или Precision Time Protocol (PTP), однако это требует тщательной настройки и мониторинга, и может быть подвержено проблемам при неправильной конфигурации NTP.

### Ненадежность синхронизированных часов

Проблема с часами заключается в их неточности, которая может оставаться незамеченной. Хотя системы обычно работают хорошо, ошибки в настройке NTP или кварцевых часов могут привести к скрытым сбоям, например, потерям данных, без явных признаков неисправности. Для ПО, требующего синхронизации времени, важно мониторить расхождения между часами на разных узлах. Узлы с сильно отличающимися часами следует исключать из кластера, чтобы предотвратить ущерб.

### Метки даты/времени и упорядочение событий

Использование часов истинного времени для упорядочивания событий в распределенных системах может быть рискованным. Например, при записи данных клиентами в разные узлы базы данных, метки времени могут не отразить правильный порядок событий. Стратегия «выигрывает последний» (LWW), широко используемая в базах данных с репликацией, может ошибочно отклонить более свежую запись, если метки времени, несмотря на правильную синхронизацию, не соответствуют реальному порядку операций.

![[49. Time bottleneck.png]]

Проблемы возникают, когда узлы с не синхронизированными часами не могут корректно перезаписать данные, что может привести к потере данных без уведомления. Также LWW не различает последовательные операции и конкурентные записи, что нарушает причинно-следственную связь. В случае одинаковых меток времени на разных узлах требуется дополнительное значение для разрешения конфликтов, но это может нарушить порядок событий.

Логические часы, которые отслеживают только относительный порядок событий, являются более надежной альтернативой. Они не зависят от физического времени и позволяют избежать проблем с синхронизацией времени, обеспечивая корректное упорядочение событий в распределенных системах.

### Доверительный интервал показаний часов

Часы истинного времени, даже с разрешением в микросекунды или наносекунды, могут быть неточными из-за расхождений кварцевых часов и ограничений синхронизации, особенно при использовании NTP-серверов в Интернете, где погрешность может достигать 100 миллисекунд. Время следует рассматривать как интервал с доверительной погрешностью, а не как точный момент. Некоторые системы, например, API TrueTime в Google Spanner, учитывают погрешность и предоставляют интервал (earliest, latest), показывая возможные границы времени с учетом синхронизации и ошибок.

### Синхронизация часов для глобальных снимков состояния

Для создания глобального снимка состояния распределенной системы (например, для резервного копирования или аудита) требуется определить момент времени, который будет использоваться для всех узлов. Однако из-за неточности часов истинного времени невозможно гарантировать, что все узлы видят одинаковое состояние в один и тот же момент.

Проблема возникает, когда разные узлы имеют расхождение в часах: снимок состояния, сделанный на узле A в момент времени T, может не соответствовать снимку на узле B в тот же момент T из-за расхождения часов. Это может привести к несогласованности данных в снимке.

Решения включают использование логических часов или векторов версий для отслеживания причинно-следственных связей вместо физического времени, что позволяет создавать согласованные снимки состояния независимо от синхронизации часов.

### Паузы при выполнении процессов

В распределенных системах процессы могут приостанавливаться на неопределенное время из-за различных причин: сборка мусора (GC), виртуализация, планировщик операционной системы, переключение контекста и т.д. Эти паузы создают серьезные проблемы для систем, полагающихся на время ожидания (timeouts) и договоры аренды (leases).

**Проблемы с паузами:**
- Процесс может приостановиться на несколько секунд или даже минут, что нарушает предположения о времени выполнения операций
- Во время паузы процесс не может отвечать на запросы, что может привести к тому, что другие узлы сочтут его неработающим
- Договоры аренды могут истечь во время паузы, но процесс об этом не узнает до возобновления работы

**Пример проблемы:**
Если процесс получил договор аренды на 30 секунд, но затем приостановился на 35 секунд из-за сборки мусора, то к моменту возобновления работы договор уже истек. Однако процесс может не знать об этом и продолжать выполнять операции, которые он считает разрешенными, что может привести к конфликтам и порче данных.

**Решения:**
- Использование ограждающих маркеров (fencing tokens) для защиты ресурсов от устаревших запросов
- Мониторинг и ограничение длительности пауз (например, настройка GC для минимизации пауз)
- Использование выделенных процессов для критических операций, которые не могут быть приостановлены
- Реализация механизмов обнаружения и обработки устаревших операций на стороне сервера

Эти проблемы подчеркивают важность проектирования распределенных систем с учетом неопределенности времени и возможности пауз процессов, а не полагаться на точные временные гарантии.
