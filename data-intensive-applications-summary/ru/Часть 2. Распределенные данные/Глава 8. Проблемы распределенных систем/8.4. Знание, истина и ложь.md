В распределенных системах возникает фундаментальная проблема: узел не может быть полностью уверен в состоянии других узлов или в том, что он сам является "избранным" (например, ведущим узлом или владельцем блокировки). Это связано с ненадежностью сетей, часов и возможностью пауз процессов.

### Истина определяется большинством

В распределенной системе нет глобального источника истины. Вместо этого истина определяется большинством узлов через механизмы кворума. Если большинство узлов считает, что что-то произошло, то это считается истиной, даже если отдельные узлы имеют другую информацию.

**Проблема "избранного" узла:**
- Узел может считать себя ведущим узлом секции базы данных, владельцем блокировки или обработчиком запроса
- Однако другие узлы могут не согласиться с этим, особенно если произошел разрыв сети или пауза процесса
- Узел, который был "избранным", может быть "понижен в должности" другими узлами, которые объявили его неработающим

**Пример проблемы с блокировкой:**
При неправильной реализации распределенной блокировки может возникнуть ситуация, когда клиент 1 получил договор аренды (lease) на файл, но затем приостановился на длительное время. Срок договора истек, и клиент 2 получил новый договор аренды на тот же файл. Когда клиент 1 возобновляет работу, он ошибочно считает, что у него все еще есть действующий договор, и начинает запись в файл, что приводит к порче данных из-за конфликта с операциями клиента 2.

### Ограждающие маркеры

Для защиты от устаревших операций используется механизм ограждающих маркеров (fencing tokens). При каждом предоставлении блокировки или договора аренды сервер блокировок возвращает монотонно возрастающий номер — ограждающий маркер. Клиент должен включать этот маркер в каждый запрос на запись к защищенному ресурсу.

**Как это работает:**
1. Клиент 1 получает договор аренды с маркером 33, затем приостанавливается
2. Срок договора истекает, клиент 2 получает договор с маркером 34
3. Клиент 2 отправляет запрос на запись с маркером 34 — сервис хранения принимает его
4. Клиент 1 возобновляет работу и отправляет запрос с маркером 33
5. Сервис хранения видит, что уже обработал запрос с большим маркером (34), и отклоняет запрос клиента 1

**Важные требования:**
- Проверка маркеров должна выполняться на стороне сервера (ресурса), а не только на клиенте
- Ресурс должен отслеживать максимальный обработанный маркер и отклонять все запросы с меньшими маркерами
- В качестве маркеров можно использовать идентификаторы транзакций (например, zxid в ZooKeeper) или версии узлов

Этот механизм защищает систему от непреднамеренных ошибок, но не защищает от злонамеренных действий узлов.

### Византийские сбои

В большинстве систем предполагается, что узлы "добропорядочны": они могут работать медленно, не отвечать или иметь устаревшее состояние, но если узел отвечает, то он "говорит правду" и соблюдает протокол.

**Византийский сбой** — это ситуация, когда узел может "лгать": отправлять произвольные сбойные или поврежденные ответы, заявлять о получении сообщений, которых не было, и т.д. Задача достижения консенсуса в такой среде называется **задачей византийских генералов**.

**Когда важна защита от византийских сбоев:**
- В авиакосмической отрасли, где радиация может портить данные в памяти, что приводит к непредсказуемым ответам
- В системах с множеством не доверяющих друг другу участников (например, блокчейн-системы типа Bitcoin)
- В критически важных системах, где отказ может привести к катастрофическим последствиям

**Почему обычно не используется:**
- В большинстве серверных систем узлы контролируются одной организацией и являются доверенными
- Протоколы защиты от византийских сбоев очень сложны и дороги в реализации
- Требуют квалифицированного большинства из более чем двух третей нормально работающих узлов
- Для защиты от ошибок ПО потребовалось бы несколько независимых реализаций одного и того же программного обеспечения

**Слабые формы защиты:**
Хотя полная защита от византийских сбоев обычно не требуется, полезно защищаться от слабых форм "лжи":
- Проверка контрольных сумм для обнаружения порчи сетевых пакетов
- Валидация вводимых данных для предотвращения некорректных сообщений
- Использование нескольких NTP-серверов для повышения надежности синхронизации времени

### Модели системы на практике

Для формализации типов вероятных сбоев используются модели системы — абстракции, описывающие допущения алгоритма.

**Модели по хронометражу:**
- **Синхронная модель**: предполагает ограниченность сетевых задержек, пауз процессов и расхождения часов фиксированной верхней границей. Нереалистична для большинства практических систем.
- **Частично синхронная модель**: система большую часть времени ведет себя как синхронная, но иногда выходит за рамки заданных ограничений. Реалистична для большинства систем.
- **Асинхронная модель**: алгоритм не может строить временные допущения, даже часы отсутствуют. Очень ограничивает разработчика.

**Модели по отказам узлов:**
- **Модель "отказ — остановка"**: узел может только полностью прекратить работу и больше не возобновить ее.
- **Модель "отказ — восстановление"**: узел может прекратить работу, но затем восстановиться. Предполагается наличие надежного хранилища.
- **Византийские (произвольные) сбои**: узлы могут делать все что угодно, включая попытки обмана.

Для большинства реальных систем лучше всего подходит **частично синхронная модель типа "сбой — восстановление"**.

### Корректность алгоритмов

Корректность распределенного алгоритма определяется через его свойства, которые делятся на два типа:

**Функциональная безопасность (safety):**
- Неформально: "ничего плохого не произошло"
- Если свойство нарушается, существует конкретный момент времени нарушения
- Ущерб уже нанесен, ничего нельзя исправить
- Примеры: уникальность ограждающих маркеров, монотонное возрастание значений

**Живучесть (liveness):**
- Неформально: "со временем случится что-то хорошее"
- Содержит фразу "в конце концов"
- Может не быть привязано к конкретному моменту времени
- Примеры: доступность, конечная согласованность

**Требования к свойствам:**
- Свойства функциональной безопасности должны соблюдаться всегда, даже при фатальных сбоях
- Свойства живучести могут иметь уточнения (например, только при отсутствии сбоя большинства узлов)

### Привязка моделей к реальному миру

Модели системы — это упрощенные абстракции реальности. При реализации алгоритма на практике возникают ситуации, которые модель не учитывает:

- Повреждение данных на диске или стирание данных из-за аппаратных ошибок
- Ошибки в прошивке сервера
- "Амнезия" узла — забывание ранее сохраненных данных
- Другие непредвиденные сбои

**Подход к обработке:**
В реализации иногда требуется включить код для обработки случаев, которые модель предполагает невозможными. Это может быть простая обработка с логированием и остановкой системы для ручного вмешательства оператора.

**Ценность моделей:**
Несмотря на упрощения, модели систем исключительно полезны:
- Позволяют извлечь из сложности реальной системы приемлемое множество сбоев для рассмотрения
- Дают возможность систематически понять задачу и решить ее
- Позволяют доказать корректность алгоритма математически

Доказательство корректности алгоритма не гарантирует, что его реализация всегда будет вести себя корректно, но это очень хороший первый шаг к созданию надежной системы.

