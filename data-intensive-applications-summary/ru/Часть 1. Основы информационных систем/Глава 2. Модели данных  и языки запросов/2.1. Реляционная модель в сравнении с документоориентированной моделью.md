Наиболее известной моделью данных является реляционная модель, предложенная Эдгаром Коддом в 1970 году. Данные организованы в таблицы, состоящие из кортежей (строк). С начала 1980-х годов реляционные системы управления базами данных (RDBMS) и язык SQL стали оптимальными инструментами для хранения и обработки структурированных данных. Хотя в 1970-х и 1980-х годах существовали альтернативные модели (сетевая и иерархическая), реляционная модель доминировала. Со временем применение реляционных БД расширилось на многие сценарии, включая онлайн-публикации, социальные сети и интернет-магазины.

### Рождение NoSQL

В 2010-х годах NoSQL стала последней попыткой заменить реляционные базы данных. Название NoSQL возникло в 2009 году как хештег для семинара по распределенным нереляционным БД, но быстро стало популярным. NoSQL охватывает различные системы, которые изначально интерпретировались как "Не Только SQL". Основные  причины внедрения NoSQL включают потребность в большем масштабировании, предпочтение свободного ПО, специализированные запросные операции и разочарование ограниченностью реляционных схем. С учетом разнообразия требований приложений, вероятно, реляционные и нереляционные базы данных будут использоваться вместе в будущем, что известно как полиглотное хранение данных.

### Объектно-реляционное несоответствие

Современная разработка приложений преимущественно ведется на объектно-ориентированных языках, что вызвало критику модели данных SQL из-за "рассогласования" (impedance mismatch) между объектами кода и реляционными таблицами. Объектно-реляционные отображения (ORM), такие как ActiveRecord и Hibernate, помогают сократить шаблонный код, но не устраняют различия между моделями.

Например, в реляционной схеме профиль пользователя может быть представлен через уникальный идентификатор user_id, а поля, такие как first_name и last_name, могут стать столбцами таблицы users. Однако, для хранения информации о рабочих местах, образовании и контактных данных, которые могут иметь связь "один-ко-многим", существуют разные подходы:

1. В традиционном нормализованном представлении используются отдельные таблицы с внешними ключами для связи с таблицей users.
2. Более поздние версии SQL поддерживают структурированные типы данных и XML, что позволяет хранить многоэлементные данные в одной строке с возможностью индексации.
3. Третий вариант — хранение данных в формате JSON или XML в текстовом столбце, что усложняет выполнение запросов к содержимому.

![[8. CV relational.png]]

Для резюме удобно использовать JSON, так как он проще XML. Это поддерживают документоориентированные БД, например, MongoDB и CouchDB.

```json
{
   "user_id":251,
   "first_name":"Bill",
   "last_name":"Gates",
   "summary":"Co-chair of the Bill & Melinda Gates... Active blogger.",
   "region_id":"us:91",
   "industry_id":131,
   "photo_url":"/p/7/000/253/05b/308dd6e.jpg",
   "positions":[
      {
         "job_title":"Co-chair",
         "organization":"Bill & Melinda Gates Foundation"
      },
      {
         "job_title":"Co-founder, Chairman",
         "organization":"Microsoft"
      }
   ],
   "education":[
      {
         "school_name":"Harvard University",
         "start":1973,
         "end":1975
      },
      {
         "school_name":"Lakeside School, Seattle",
         "start":null,
         "end":null
      }
   ],
   "contact_info":{
      "blog":"http://thegatesnotes.com",
      "twitter":"http://twitter.com/BillGates"
   }
}
```

Модель JSON помогает уменьшить рассогласование между кодом приложения и слоем хранения данных. Однако у этого формата есть свои проблемы, особенно из-за отсутствия схемы. JSON обеспечивает лучшую локальность данных: для извлечения профиля достаточно одного запроса, в отличие от реляционных схем, где требуется несколько запросов или сложные соединения. Структура «один-ко-многим» между пользователем и его должностями, образованием и контактами становится явной в JSON, что упрощает работу с данными.

![[9. CV relational structure.png]]

Использование идентификаторов вместо текстовых строк, таких как "Greater Seattle Area" и "Philanthropy", предствленных в json, имеет несколько преимуществ:

1. **Единообразие**: Идентификаторы обеспечивают единый стиль написания и предотвращают неоднозначности, особенно в случае с городами с одинаковыми названиями.
2. **Удобство модификации**: Информация хранится в одном месте, что позволяет легко изменять её при необходимости.
3. **Поддержка локализации**: Списки можно локализовать для различных языков, что улучшает взаимодействие с пользователями.
4. **Улучшенные возможности поиска**: Идентификаторы позволяют эффективнее выполнять поиск, например, профили могут быть найдены по географическим регионам или сферам деятельности.

Использование идентификаторов минимизирует дублирование данных, снижает риск несоответствий и упрощает нормализацию. Однако нормализация требует связей «многие-к-одному», которые сложно реализовать в документных моделях. Если СУБД не поддерживает соединения, то их приходится эмулировать в коде приложения.

С увеличением функциональности приложения внутренние связи данных могут усложняться, что требует переработки структуры данных. Например, компании и школы могут стать сущностями с дополнительной информацией, а рекомендации могут ссылаться на профили авторов.

### Повторяется ли история в случае документоориентированных баз данных

Связи «многие-ко-многим» и соединения, активно используемые в реляционных БД, вновь становятся предметом обсуждения в контексте документоориентированных баз данных и NoSQL. Эта дискуссия уходит корнями в 1970-е, когда доминировала Система управления информацией (IMS) от IBM, изначально разработанная для космической программы «Аполлон». IMS использовала иерархическую модель данных, схожую с JSON, представляя данные в виде деревьев записей.

Хотя IMS хорошо справляется со связями «один-ко-многим», она сталкивается с трудностями в обработке «многие-ко-многим», требуя дублирования данных или ручного управления ссылками. Эти проблемы напоминают те, с которыми сегодня сталкиваются разработчики документоориентированных баз данных. Для решения ограничений иерархической модели были предложены реляционная и сетевая модели, каждая из которых имела свои сторонники и противников.

### Сетевая модель

Сетевая модель данных, стандартизированная комитетом CODASYL, является обобщением иерархической модели, позволяя каждой записи иметь несколько родительских записей. Это упрощает моделирование связей «многие-ко-многим», например, одна запись может представлять область "Greater Seattle Area" с ссылками на всех пользователей, живущих там.

Ссылки в сетевой модели напоминают указатели в языках программирования и обеспечивают доступ к записям через цепочки ссылок, называемые путями доступа. Это требует от программистов отслеживания различных путей, что усложняет код. Выполнение запросов подразумевает итерацию по спискам записей и следование по указанным путям.

Хотя в 1970-х ручной выбор путей доступа оптимизировал использование ограниченных аппаратных ресурсов, это создаёт сложный и негибкий код для обновления базы данных. Неизвестные пути доступа могут вызвать трудности, требуя переписывания кода запросов. Эти проблемы по сути аналогичны тем, с которыми сталкивались разработчики ранее в иерархических системах.

### Реляционная модель

Реляционная модель данных предлагает простой и открытый подход к управлению данными. Она представляет данные в виде таблиц (отношений), состоящих из наборов кортежей (строк), без запутанных вложенных структур. Пользователи могут легко читать, вставлять и выбирать строки, используя ключи и условия, не заботясь о внешних связях.

Оптимизатор запросов в реляционной базе данных автоматически определяет порядок выполнения запросов и использование индексов, что значительно упрощает процесс работы с данными. Если требуется изменить способ выполнения запросов, достаточно объявить новый индекс, не меняя сам запрос.

Создание универсального оптимизатора запросов требует значительных усилий, но в долгосрочной перспективе приносит преимущества, позволяя всем приложениям эффективно использовать возможности базы данных. Таким образом, реляционная модель значительно упрощает добавление новых функциональностей.

### Сравнение с документоориентированными базами данных

Документоориентированные базы данных сохраняют вложенные записи, что позволяет эффективно представлять связи «один-ко-многим», как, например, в случаях с positions, education и contact_info. Однако для связей «многие-к-одному» и «многие-ко-многим» реляционные и документоориентированные базы данных функционируют схожим образом. В обеих моделях обращение к элементам осуществляется через уникальный идентификатор: внешний ключ в реляционной модели и ссылку на документ в документной. Эти идентификаторы разрешаются во время чтения через соединения или дополнительные запросы. Таким образом, документоориентированные БД не следуют примеру CODASYL.

### Реляционные и документоориентированные базы данных сегодня

Реляционные и документоориентированные базы данных отличаются по множеству параметров, включая отказоустойчивость и конкурентный доступ. Документоориентированные модели предлагают гибкость схемы и локальную производительность, в то время как реляционные обеспечивают лучшую поддержку соединений и сложных связей.

### Какая из моделей приводит к более простому коду приложения

Документная модель данных подходит для приложений с деревообразной структурой, где все данные загружаются сразу. В отличие от реляционной модели, которая требует расщепления данных на таблицы, что может усложнять код, документная модель более интуитивна для таких структур. Однако она имеет ограничения: сложно обращаться к вложенным элементам, а плохая поддержка соединений может быть проблемой в приложениях с отношениями «многие-ко-многим». Денормализация может снизить количество соединений, но усложняет код и требует дополнительной логики для поддержания согласованности данных. Выбор модели зависит от типов связей между данными: при тесных связях реляционная модель будет проще, а графовая — наиболее естественна.

### Гибкость схемы в документной модели

Большинство документоориентированных баз данных и реляционных БД с поддержкой JSON не требуют жесткой схемы для данных, что позволяет добавлять произвольные ключи и значения. Этот подход часто называют бессхемным (schemaless), однако точнее использовать термин schema-on-read, где структура данных интерпретируется при чтении, в отличие от schema-on-write, где она фиксируется при записи.

```js 
if (user && user.name && !user.first_name) {
// В записанных до 8 декабря 2013 года документах нет поля first_name
user.first_name = user.name.split(" ")[0];
}
```

Схема при чтении аналогична динамической проверке типов в языках программирования, а схема при записи — статической. Споры о необходимости жесткой схемы остаются актуальными. Изменение формата данных в документоориентированных БД проще: можно добавлять новые поля без миграции старых данных. В реляционных БД изменение схемы требует выполнения операций ALTER TABLE и UPDATE, что может быть медленным и требовать простоя системы, особенно в MySQL. 

```sql
ALTER TABLE users ADD COLUMN first_name text;
UPDATE users SET first_name = split_part(name, ' ', 1);
 -- PostgreSQL
UPDATE users SET first_name = substring_index(name, ' ', 1);
 -- MySQL
```

Оператор UPDATE на большой таблице будет выполняться медленно в любой базе данных, поскольку приходится перезаписывать все строки. Если это неприемлемо, то приложение может оставить значение поля first_name равным NULL (по умолчанию) и заполнить его во время чтения, как в случае с документо­ориентированной БД.

Подход schema-on-read предпочтителен в случаях разнородных данных или внешних систем. В ситуациях с однородной структурой схемы помогают документировать и обеспечивать соответствие.

### Локальность данных и запросы

Документы в документоориентированных базах данных хранятся в виде непрерывных строк в форматах JSON, XML или BSON. Локальность хранилища важна для приложений, требующих доступа ко всему документу, так как это сокращает количество операций дискового поиска. Однако локальность имеет смысл только при извлечении больших частей документа, так как в противном случае загружается весь документ, что может быть неэкономно. При обновлении документа обычно нужно переписывать его целиком, что также снижает производительность. Рекомендуется минимизировать размер документов и избегать операций, увеличивающих их размер.

Идея группировки родственных данных для повышения локальности встречается и в реляционных БД, например, в Google Spanner и Oracle с многотабличными кластеризованными индекс-таблицами. Эти аспекты локальности будут обсуждены в главе 3.

### Постепенное сближение документоориентированных и реляционных баз данных

Большинство реляционных СУБД (кроме MySQL) с середины 2000-х годов поддерживают XML, включая функции для локальных изменений и индексации, что позволяет использовать модели данных, аналогичные документоориентированным БД. С начала 2010-х годов реляционные базы, такие как PostgreSQL (с версии 9.3), MySQL (с версии 5.7) и IBM DB2 (с версии 10.5), также начали поддерживать JSON-документы, что связано с его популярностью в веб-API.

Документоориентированные базы, такие как RethinkDB и MongoDB, предлагают возможности, напоминающие реляционные соединения. Это говорит о том, что реляционные и документоориентированные БД становятся все более схожими, что хорошо, так как их модели дополняют друг друга. Вероятно, будущее будет за гибридами реляционной и документной моделей. Кодд изначально предполагал возможность использования сложных типов данных, схожих с JSON, в реляционных схемах, что делает текущие изменения логичными.

