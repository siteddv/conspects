Одним из ключевых новшеств реляционной модели является использование SQL — декларативного языка запросов, в отличие от императивных языков, таких как IMS и CODASYL. В императивных языках программисту нужно указывать, как именно выполнить операции. Например, для получения акул из списка животных необходимо написать цикл, проверяющий каждое животное.

```js
function getSharks() {
	var sharks = [];
	for (var i = 0; i < animals.length; i++) {
		if (animals[i].family === "Sharks") {
			sharks.push(animals[i]);
		}
	}
	return sharks;
}
```

В SQL можно выразить эту задачу более лаконично: используя оператор запрос SELECT.

```sql
SELECT * FROM animals WHERE family = 'Sharks';
```
Декларативные языки позволяют описывать только шаблон необходимых данных и условия, которым они должны соответствовать, оставляя детали выполнения запросов (например, выбор индексов и методов соединения) оптимизатору СУБД. Это делает декларативные языки более сжатыми и удобными для работы, скрывая детали реализации базы данных и позволяя ей повышать производительность без изменения запросов.

Императивный код требует строгого порядка выполнения операций, что может затруднить автоматизацию оптимизации. В случае изменения порядка данных, как в случае "перетасовки" записей, это может нарушить работу существующих запросов. SQL не гарантирует конкретного порядка, что дает базе данных больше свободы для оптимизации.

Кроме того, декларативные языки хорошо подходят для параллельного выполнения, поскольку они описывают лишь шаблон результатов, а не алгоритм получения. Это облегчает распределение задач между ядрами процессоров и позволяет более эффективно использовать ресурсы современных многопроцессорных систем.

### Декларативные запросы в Интернете

Декларативные языки запросов, такие как SQL, имеют преимущества не только в базах данных, но и в других областях, например, в веб-разработке. Рассмотрим это на примере браузера. Если у нас есть сайт о морских животных, и пользователь просматривает страницу об акулах, мы можем пометить пункт меню "Sharks" как выбранный, используя HTML-код с классом CSS "selected". Чтобы задать синий фон для заголовка, мы можем использовать простой CSS:

```css
li.selected > p {
  background-color: blue;
}
```

Этот селектор автоматически применяет стиль к элементу `<p>Sharks</p>`, когда его родитель имеет класс "selected". Если же использовать XSL, то можно написать аналогичный код с помощью XPath:

```xml
<xsl:template match="li[@class='selected']/p">
  <fo:block background-color="blue">
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>
```

Если бы мы применяли императивный подход с JavaScript, код выглядел бы значительно сложнее:

```javascript
var liElements = document.getElementsByTagName("li");
for (var i = 0; i < liElements.length; i++) {
  if (liElements[i].className === "selected") {
    var children = liElements[i].childNodes;
    for (var j = 0; j < children.length; j++) {
      var child = children[j];
      if (child.nodeType === Node.ELEMENT_NODE && child.tagName === "P") {
        child.setAttribute("style", "background-color: blue");
      }
    }
  }
}
```

Этот код более громоздкий и сложный для понимания. Кроме того, он имеет недостатки: если класс "selected" будет удален, синий фон останется, в то время как в CSS браузер автоматически уберет его при удалении класса. Также, если мы захотим использовать новый API, нам придется переписывать код.

Таким образом, декларативные языки, такие как CSS и SQL, обеспечивают более удобный и эффективный способ работы с данными и стилями по сравнению с императивными подходами.

### Выполнение запросов с помощью MapReduce

### MapReduce в MongoDB

MapReduce — это модель программирования для обработки больших объемов данных на множестве машин, популяризированная Google. В некоторых NoSQL-хранилищах, таких как MongoDB и CouchDB, MapReduce используется для выполнения запросов на чтение.

MapReduce не является полностью декларативным языком или императивным API. Он сочетает элементы обоих подходов, позволяя писать фрагменты кода для обработки данных. Основные функции — `map` и `reduce`, которые известны во многих функциональных языках.

#### Пример использования MapReduce в MongoDB

Предположим, вы хотите подсчитать количество акул, наблюдавшихся за месяц. В PostgreSQL запрос выглядел бы так:

```sql
SELECT date_trunc('month', observation_timestamp) AS observation_month,
       sum(num_animals) AS total_animals
FROM observations
WHERE family = 'Sharks'
GROUP BY observation_month;
```

А в MongoDB с использованием MapReduce:

```javascript
db.observations.mapReduce(
  function map() {
    var year = this.observationTimestamp.getFullYear();
    var month = this.observationTimestamp.getMonth() + 1;
    emit(year + "-" + month, this.numAnimals);
  },
  function reduce(key, values) {
    return Array.sum(values);
  },
  {
    query: { family: "Sharks" },
    out: "monthlySharkReport"
  }
);
```

Функция `map` обрабатывает каждый документ и создает пары "ключ-значение". Функция `reduce` суммирует количества наблюдавшихся животных за месяц. Результаты сохраняются в коллекции `monthlySharkReport`.

Однако функции `map` и `reduce` должны быть чистыми, что ограничивает их возможности. MapReduce — низкоуровневая модель, но более высокоуровневые языки, такие как SQL, могут быть реализованы как конвейеры операций MapReduce.

С введением в MongoDB конвейера агрегирования (aggregation pipeline) в версии 2.2, аналогичный запрос стал более декларативным:

```javascript
db.observations.aggregate([
  { $match: { family: "Sharks" } },
  { $group: {
      _id: {
        year: { $year: "$observationTimestamp" },
        month: { $month: "$observationTimestamp" }
      },
      totalAnimals: { $sum: "$numAnimals" }
    }
  }
]);
```

Конвейер агрегирования напоминает SQL, но использует JSON-синтаксис. Это показывает, что NoSQL-системы могут повторно изобретать SQL в новой форме.
