Хранение и выполнение запросов в складах данных с триллионами строк и петабайтами данных представляет собой сложную задачу. Таблицы фактов, которые могут содержать более 100 столбцов, часто запрашиваются по нескольким из них (обычно 4-5). Например, запрос может обращаться к столбцам, содержащим дату, товар и количество, игнорируя остальные.

В традиционных OLTP системах данные хранятся построчно, что затрудняет выборку необходимых столбцов, поскольку необходимо загружать и обрабатывать все строки, даже если требуется лишь часть атрибутов. Чтобы оптимизировать запросы, используются индексы, однако это все равно может быть медленным процессом.

Столбцовые хранилища предлагают решение: данные хранятся по столбцам, что позволяет читать только необходимые столбцы. Это значительно ускоряет выполнение запросов. Например, в столбцовом формате Parquet данные организованы так, что каждый столбец хранится отдельно, позволяя эффективно собирать строки из соответствующих значений.

### Сжатие столбцов

Для повышения эффективности работы с данными в складах данных применяются методы сжатия, что особенно важно при использовании столбцовых хранилищ. Столбцы часто содержат много повторяющихся значений, что делает их хорошими кандидатами для сжатия. Одним из эффективных методов сжатия является кодирование с помощью битовой карты, где для каждого уникального значения создается битовая карта, показывающая наличие этого значения в каждой строке. Такой подход особенно полезен при выполнении запросов, основанных на нескольких значениях.

Например, запросы, использующие конструкцию WHERE product_sk IN (...), могут эффективно обрабатывать битовые карты, используя поразрядное ИЛИ. Аналогично, запросы с условием AND могут использовать поразрядное И для фильтрации данных.

Также важным аспектом является пропускная способность, поскольку выполнение запросов может ограничиваться скоростью передачи данных с диска в память. Для решения этой проблемы векторизованная обработка позволяет более эффективно использовать циклы CPU, обрабатывая данные в непрерывных циклах без вызовов функций. Это особенно эффективно в комбинации с сжатыми столбцовыми данными, что позволяет разместить больше строк в кэше и ускорить обработку.

### Порядок сортировки в столбцовом хранилище

В столбцовом хранилище порядок хранения строк может быть гибким. Обычно строки добавляются в порядке их вставки, что упрощает процесс, однако можно установить определённый порядок сортировки для оптимизации запросов. Это позволяет администраторам БД выбирать столбцы, по которым будет производиться сортировка, основываясь на частоте запросов. Например, если часто используются диапазоны дат, столбец `date_key` может быть первым ключом сортировки, а вторым — `product_sk`, чтобы сгруппировать продажи товаров по дням.

Сортировка не только ускоряет выполнение запросов, но и улучшает сжатие данных. При сортировке первого ключа повторяющиеся значения создают длинные последовательности, что делает кодирование более эффективным. Предложение о хранении данных с несколькими порядками сортировки, как в C-Store и Vertica, позволяет оптимизировать доступ для различных запросов, что напоминает вторичные индексы в построчных хранилищах, но с тем отличием, что в столбцовом хранилище нет указателей, только сами значения столбцов.

### Запись в столбцовое хранилище

Оптимизации, такие как столбцовое хранение, сжатие и сортировка, улучшают выполнение аналитических запросов в складах данных, предназначенных для чтения. Однако эти методы усложняют операции записи. При использовании сжатых столбцов обновление данных на месте невозможно, поскольку вставка строк в отсортированной таблице требует переписывания всех файлов столбцов.

LSM-деревья предлагают решение этой проблемы: данные сначала записываются в оперативной памяти в отсортированной структуре. При накоплении достаточно данных они объединяются и записываются на диск в новые файлы. В результате запросы могут одновременно обращаться как к данным на диске, так и к свежим данным в памяти, а оптимизатор запросов скрывает сложность этого процесса от пользователей, предоставляя актуальные данные без задержек.

### Агрегирование: кубы данных и материализованные представления

Столбцовые хранилища данных набирают популярность благодаря своей высокой производительности при аналитических запросах. Важно отметить, что использование материализованных представлений может существенно ускорить выполнение запросов, особенно когда они включают агрегирующие функции, такие как COUNT, SUM и AVG. В отличие от виртуальных представлений, материализованные представления сохраняют результаты запросов на диске, что позволяет избежать повторных вычислений.

Однако при изменении исходных данных материализованные представления требуют обновления, что увеличивает затраты на операции записи. Поэтому их применение чаще встречается в хранилищах данных (OLAP), где основная нагрузка — это операции чтения.

Одним из распространенных видов материализованных представлений является OLAP-куб, который организует сводные показатели по различным измерениям (например, по дате и товару). Каждый элемент куба содержит агрегированные данные, что позволяет быстро получать сводные итоги без необходимости обрабатывать все исходные данные.

Тем не менее, кубы данных имеют свои ограничения: они менее гибкие, чем запросы к исходным данным, что может затруднить анализ данных по неучтённым измерениям. Поэтому большинство хранилищ стремятся сохранять как можно больше исходных данных, используя кубы только для ускорения определённых запросов.

![[18. OLAP cubes.png]]

Представьте, что у каждого факта имеются внешние ключи только к двум таблицам
измерений — на рис. 3.12 это дата и товар. Можно нарисовать двумерную таблицу:
с товарами по одной оси координат и датами — по другой. Каждая ячейка содержит
сводный показатель (например, SUM) атрибута (например, net_price) всех фактов
с таким сочетанием даты и товара. Затем можно применить ту же агрегирующую
функцию вдоль каждой строки или столбца и получить итоги, сокращенные на одно
измерение (продажи по товарам независимо от даты или продажи по датам неза-
висимо от товара).