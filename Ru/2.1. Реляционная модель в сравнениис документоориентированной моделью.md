Наиболее известной моделью данных является реляционная модель, предложенная Эдгаром Коддом в 1970 году. Данные организованы в таблицы, состоящие из кортежей (строк). С начала 1980-х годов реляционные системы управления базами данных (RDBMS) и язык SQL стали оптимальными инструментами для хранения и обработки структурированных данных. Хотя в 1970-х и 1980-х годах существовали альтернативные модели (сетевая и иерархическая), реляционная модель доминировала. Со временем применение реляционных БД расширилось на многие сценарии, включая онлайн-публикации, социальные сети и интернет-магазины.

### Рождение NoSQL

В 2010-х годах NoSQL стала последней попыткой заменить реляционные базы данных. Название NoSQL возникло в 2009 году как хештег для семинара по распределенным нереляционным БД, но быстро стало популярным. NoSQL охватывает различные системы, которые изначально интерпретировались как "Не Только SQL". Основные причины внедрения NoSQL включают потребность в большем масштабировании, предпочтение свободного ПО, специализированные запросные операции и разочарование ограниченностью реляционных схем. С учетом разнообразия требований приложений, вероятно, реляционные и нереляционные базы данных будут использоваться вместе в будущем, что известно как полиглотное хранение данных.

### Объектно-реляционное несоответствие

Современная разработка приложений преимущественно ведется на объектно-ориентированных языках, что вызвало критику модели данных SQL из-за "рассогласования" (impedance mismatch) между объектами кода и реляционными таблицами. Объектно-реляционные отображения (ORM), такие как ActiveRecord и Hibernate, помогают сократить шаблонный код, но не устраняют различия между моделями.

Например, в реляционной схеме профиль пользователя может быть представлен через уникальный идентификатор user_id, а поля, такие как first_name и last_name, могут стать столбцами таблицы users. Однако, для хранения информации о рабочих местах, образовании и контактных данных, которые могут иметь связь "один-ко-многим", существуют разные подходы:

1. В традиционном нормализованном представлении используются отдельные таблицы с внешними ключами для связи с таблицей users.
2. Более поздние версии SQL поддерживают структурированные типы данных и XML, что позволяет хранить многоэлементные данные в одной строке с возможностью индексации.
3. Третий вариант — хранение данных в формате JSON или XML в текстовом столбце, что усложняет выполнение запросов к содержимому.

![[8. CV relational.png]]

Для резюме удобно использовать JSON, так как он проще XML. Это поддерживают документоориентированные БД, например, MongoDB и CouchDB.

```json
{
   "user_id":251,
   "first_name":"Bill",
   "last_name":"Gates",
   "summary":"Co-chair of the Bill & Melinda Gates... Active blogger.",
   "region_id":"us:91",
   "industry_id":131,
   "photo_url":"/p/7/000/253/05b/308dd6e.jpg",
   "positions":[
      {
         "job_title":"Co-chair",
         "organization":"Bill & Melinda Gates Foundation"
      },
      {
         "job_title":"Co-founder, Chairman",
         "organization":"Microsoft"
      }
   ],
   "education":[
      {
         "school_name":"Harvard University",
         "start":1973,
         "end":1975
      },
      {
         "school_name":"Lakeside School, Seattle",
         "start":null,
         "end":null
      }
   ],
   "contact_info":{
      "blog":"http://thegatesnotes.com",
      "twitter":"http://twitter.com/BillGates"
   }
}
```

Модель JSON помогает уменьшить рассогласование между кодом приложения и слоем хранения данных. Однако у этого формата есть свои проблемы, особенно из-за отсутствия схемы. JSON обеспечивает лучшую локальность данных: для извлечения профиля достаточно одного запроса, в отличие от реляционных схем, где требуется несколько запросов или сложные соединения. Структура «один-ко-многим» между пользователем и его должностями, образованием и контактами становится явной в JSON, что упрощает работу с данными.

![[9. CV relational structure.png]]

Использование идентификаторов вместо текстовых строк, таких как "Greater Seattle Area" и "Philanthropy", предствленных в json, имеет несколько преимуществ:

1. **Единообразие**: Идентификаторы обеспечивают единый стиль написания и предотвращают неоднозначности, особенно в случае с городами с одинаковыми названиями.
2. **Удобство модификации**: Информация хранится в одном месте, что позволяет легко изменять её при необходимости.
3. **Поддержка локализации**: Списки можно локализовать для различных языков, что улучшает взаимодействие с пользователями.
4. **Улучшенные возможности поиска**: Идентификаторы позволяют эффективнее выполнять поиск, например, профили могут быть найдены по географическим регионам или сферам деятельности.

Использование идентификаторов минимизирует дублирование данных, снижает риск несоответствий и упрощает нормализацию. Однако нормализация требует связей «многие-к-одному», которые сложно реализовать в документных моделях. Если СУБД не поддерживает соединения, то их приходится эмулировать в коде приложения.

С увеличением функциональности приложения внутренние связи данных могут усложняться, что требует переработки структуры данных. Например, компании и школы могут стать сущностями с дополнительной информацией, а рекомендации могут ссылаться на профили авторов.