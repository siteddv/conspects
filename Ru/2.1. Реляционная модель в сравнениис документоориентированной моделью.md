Наиболее известной моделью данных является реляционная модель, предложенная Эдгаром Коддом в 1970 году. Данные организованы в таблицы, состоящие из кортежей (строк). С начала 1980-х годов реляционные системы управления базами данных (RDBMS) и язык SQL стали оптимальными инструментами для хранения и обработки структурированных данных. Хотя в 1970-х и 1980-х годах существовали альтернативные модели (сетевая и иерархическая), реляционная модель доминировала. Со временем применение реляционных БД расширилось на многие сценарии, включая онлайн-публикации, социальные сети и интернет-магазины.

### Рождение NoSQL

В 2010-х годах NoSQL стала последней попыткой заменить реляционные базы данных. Название NoSQL возникло в 2009 году как хештег для семинара по распределенным нереляционным БД, но быстро стало популярным. NoSQL охватывает различные системы, которые изначально интерпретировались как "Не Только SQL". Основные причины внедрения NoSQL включают потребность в большем масштабировании, предпочтение свободного ПО, специализированные запросные операции и разочарование ограниченностью реляционных схем. С учетом разнообразия требований приложений, вероятно, реляционные и нереляционные базы данных будут использоваться вместе в будущем, что известно как полиглотное хранение данных.

### Объектно-реляционное несоответствие

Современная разработка приложений преимущественно ведется на объектно-ориентированных языках, что вызвало критику модели данных SQL из-за "рассогласования" (impedance mismatch) между объектами кода и реляционными таблицами. Объектно-реляционные отображения (ORM), такие как ActiveRecord и Hibernate, помогают сократить шаблонный код, но не устраняют различия между моделями.

Например, в реляционной схеме профиль пользователя может быть представлен через уникальный идентификатор user_id, а поля, такие как first_name и last_name, могут стать столбцами таблицы users. Однако, для хранения информации о рабочих местах, образовании и контактных данных, которые могут иметь связь "один-ко-многим", существуют разные подходы:

1. В традиционном нормализованном представлении используются отдельные таблицы с внешними ключами для связи с таблицей users.
2. Более поздние версии SQL поддерживают структурированные типы данных и XML, что позволяет хранить многоэлементные данные в одной строке с возможностью индексации.
3. Третий вариант — хранение данных в формате JSON или XML в текстовом столбце, что усложняет выполнение запросов к содержимому.

![[8. CV relational.png]]

Для резюме удобно использовать JSON, так как он проще XML. Это поддерживают документоориентированные БД, например, MongoDB и CouchDB.

```json
{
   "user_id":251,
   "first_name":"Bill",
   "last_name":"Gates",
   "summary":"Co-chair of the Bill & Melinda Gates... Active blogger.",
   "region_id":"us:91",
   "industry_id":131,
   "photo_url":"/p/7/000/253/05b/308dd6e.jpg",
   "positions":[
      {
         "job_title":"Co-chair",
         "organization":"Bill & Melinda Gates Foundation"
      },
      {
         "job_title":"Co-founder, Chairman",
         "organization":"Microsoft"
      }
   ],
   "education":[
      {
         "school_name":"Harvard University",
         "start":1973,
         "end":1975
      },
      {
         "school_name":"Lakeside School, Seattle",
         "start":null,
         "end":null
      }
   ],
   "contact_info":{
      "blog":"http://thegatesnotes.com",
      "twitter":"http://twitter.com/BillGates"
   }
}
```

Модель JSON помогает уменьшить рассогласование между кодом приложения и слоем хранения данных. Однако у этого формата есть свои проблемы, особенно из-за отсутствия схемы. JSON обеспечивает лучшую локальность данных: для извлечения профиля достаточно одного запроса, в отличие от реляционных схем, где требуется несколько запросов или сложные соединения. Структура «один-ко-многим» между пользователем и его должностями, образованием и контактами становится явной в JSON, что упрощает работу с данными.

![[9. CV relational structure.png]]

Использование идентификаторов вместо текстовых строк, таких как "Greater Seattle Area" и "Philanthropy", предствленных в json, имеет несколько преимуществ:

1. **Единообразие**: Идентификаторы обеспечивают единый стиль написания и предотвращают неоднозначности, особенно в случае с городами с одинаковыми названиями.
2. **Удобство модификации**: Информация хранится в одном месте, что позволяет легко изменять её при необходимости.
3. **Поддержка локализации**: Списки можно локализовать для различных языков, что улучшает взаимодействие с пользователями.
4. **Улучшенные возможности поиска**: Идентификаторы позволяют эффективнее выполнять поиск, например, профили могут быть найдены по географическим регионам или сферам деятельности.

Использование идентификаторов минимизирует дублирование данных, снижает риск несоответствий и упрощает нормализацию. Однако нормализация требует связей «многие-к-одному», которые сложно реализовать в документных моделях. Если СУБД не поддерживает соединения, то их приходится эмулировать в коде приложения.

С увеличением функциональности приложения внутренние связи данных могут усложняться, что требует переработки структуры данных. Например, компании и школы могут стать сущностями с дополнительной информацией, а рекомендации могут ссылаться на профили авторов.

### Повторяется ли история в случае документоориентированных баз данных

Связи «многие-ко-многим» и соединения, активно используемые в реляционных БД, вновь становятся предметом обсуждения в контексте документоориентированных баз данных и NoSQL. Эта дискуссия уходит корнями в 1970-е, когда доминировала Система управления информацией (IMS) от IBM, изначально разработанная для космической программы «Аполлон». IMS использовала иерархическую модель данных, схожую с JSON, представляя данные в виде деревьев записей.

Хотя IMS хорошо справляется со связями «один-ко-многим», она сталкивается с трудностями в обработке «многие-ко-многим», требуя дублирования данных или ручного управления ссылками. Эти проблемы напоминают те, с которыми сегодня сталкиваются разработчики документоориентированных баз данных. Для решения ограничений иерархической модели были предложены реляционная и сетевая модели, каждая из которых имела свои сторонники и противников.

### Сетевая модель

Сетевая модель данных, стандартизированная комитетом CODASYL, является обобщением иерархической модели, позволяя каждой записи иметь несколько родительских записей. Это упрощает моделирование связей «многие-ко-многим», например, одна запись может представлять область "Greater Seattle Area" с ссылками на всех пользователей, живущих там.

Ссылки в сетевой модели напоминают указатели в языках программирования и обеспечивают доступ к записям через цепочки ссылок, называемые путями доступа. Это требует от программистов отслеживания различных путей, что усложняет код. Выполнение запросов подразумевает итерацию по спискам записей и следование по указанным путям.

Хотя в 1970-х ручной выбор путей доступа оптимизировал использование ограниченных аппаратных ресурсов, это создаёт сложный и негибкий код для обновления базы данных. Неизвестные пути доступа могут вызвать трудности, требуя переписывания кода запросов. Эти проблемы по сути аналогичны тем, с которыми сталкивались разработчики ранее в иерархических системах.

### Реляционная модель

Реляционная модель данных предлагает простой и открытый подход к управлению данными. Она представляет данные в виде таблиц (отношений), состоящих из наборов кортежей (строк), без запутанных вложенных структур. Пользователи могут легко читать, вставлять и выбирать строки, используя ключи и условия, не заботясь о внешних связях.

Оптимизатор запросов в реляционной базе данных автоматически определяет порядок выполнения запросов и использование индексов, что значительно упрощает процесс работы с данными. Если требуется изменить способ выполнения запросов, достаточно объявить новый индекс, не меняя сам запрос.

Создание универсального оптимизатора запросов требует значительных усилий, но в долгосрочной перспективе приносит преимущества, позволяя всем приложениям эффективно использовать возможности базы данных. Таким образом, реляционная модель значительно упрощает добавление новых функциональностей.

### Сравнение с документоориентированными базами данных

Документоориентированные базы данных сохраняют вложенные записи, что позволяет эффективно представлять связи «один-ко-многим», как, например, в случаях с positions, education и contact_info. Однако для связей «многие-к-одному» и «многие-ко-многим» реляционные и документоориентированные базы данных функционируют схожим образом. В обеих моделях обращение к элементам осуществляется через уникальный идентификатор: внешний ключ в реляционной модели и ссылку на документ в документной. Эти идентификаторы разрешаются во время чтения через соединения или дополнительные запросы. Таким образом, документоориентированные БД не следуют примеру CODASYL.

