Одним из ключевых новшеств реляционной модели является использование SQL — декларативного языка запросов, в отличие от императивных языков, таких как IMS и CODASYL. В императивных языках программисту нужно указывать, как именно выполнить операции. Например, для получения акул из списка животных необходимо написать цикл, проверяющий каждое животное.

```js
function getSharks() {
	var sharks = [];
	for (var i = 0; i < animals.length; i++) {
		if (animals[i].family === "Sharks") {
			sharks.push(animals[i]);
		}
	}
	return sharks;
}
```

В SQL можно выразить эту задачу более лаконично: используя оператор запрос SELECT.

```sql
SELECT * FROM animals WHERE family = 'Sharks';
```
Декларативные языки позволяют описывать только шаблон необходимых данных и условия, которым они должны соответствовать, оставляя детали выполнения запросов (например, выбор индексов и методов соединения) оптимизатору СУБД. Это делает декларативные языки более сжатыми и удобными для работы, скрывая детали реализации базы данных и позволяя ей повышать производительность без изменения запросов.

Императивный код требует строгого порядка выполнения операций, что может затруднить автоматизацию оптимизации. В случае изменения порядка данных, как в случае "перетасовки" записей, это может нарушить работу существующих запросов. SQL не гарантирует конкретного порядка, что дает базе данных больше свободы для оптимизации.

Кроме того, декларативные языки хорошо подходят для параллельного выполнения, поскольку они описывают лишь шаблон результатов, а не алгоритм получения. Это облегчает распределение задач между ядрами процессоров и позволяет более эффективно использовать ресурсы современных многопроцессорных систем.

### Декларативные запросы в Интернете

Декларативные языки запросов, такие как SQL, имеют преимущества не только в базах данных, но и в других областях, например, в веб-разработке. Рассмотрим это на примере браузера. Если у нас есть сайт о морских животных, и пользователь просматривает страницу об акулах, мы можем пометить пункт меню "Sharks" как выбранный, используя HTML-код с классом CSS "selected". Чтобы задать синий фон для заголовка, мы можем использовать простой CSS:

```css
li.selected > p {
  background-color: blue;
}
```

Этот селектор автоматически применяет стиль к элементу `<p>Sharks</p>`, когда его родитель имеет класс "selected". Если же использовать XSL, то можно написать аналогичный код с помощью XPath:

```xml
<xsl:template match="li[@class='selected']/p">
  <fo:block background-color="blue">
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>
```

Если бы мы применяли императивный подход с JavaScript, код выглядел бы значительно сложнее:

```javascript
var liElements = document.getElementsByTagName("li");
for (var i = 0; i < liElements.length; i++) {
  if (liElements[i].className === "selected") {
    var children = liElements[i].childNodes;
    for (var j = 0; j < children.length; j++) {
      var child = children[j];
      if (child.nodeType === Node.ELEMENT_NODE && child.tagName === "P") {
        child.setAttribute("style", "background-color: blue");
      }
    }
  }
}
```

Этот код более громоздкий и сложный для понимания. Кроме того, он имеет недостатки: если класс "selected" будет удален, синий фон останется, в то время как в CSS браузер автоматически уберет его при удалении класса. Также, если мы захотим использовать новый API, нам придется переписывать код.

Таким образом, декларативные языки, такие как CSS и SQL, обеспечивают более удобный и эффективный способ работы с данными и стилями по сравнению с императивными подходами.

### Выполнение запросов с помощью MapReduce

