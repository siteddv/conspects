### Подробный конспект по функциям и процедурам в PostgreSQL

#### Введение в тему
В PostgreSQL существуют две основные категории подпрограмм: функции и процедуры. Эти два типа имеют свои особенности, которые определяют их использование в различных сценариях работы с базами данных. Основное различие заключается в способе вызова и возможностях управления транзакциями.

Функции в PostgreSQL всегда возвращают значение и работают в рамках текущей транзакции. Они могут быть вызваны как часть SQL-выражения, например, в операторах SELECT. Процедуры, напротив, не обязаны возвращать значения и вызываются через отдельный оператор CALL. Одним из ключевых преимуществ процедур является возможность управлять транзакциями внутри их тела, что особенно важно для выполнения сложных операций изменения состояния базы данных.

Процедуры появились в PostgreSQL только в версии 11, и их внедрение было обусловлено необходимостью более гибкого управления транзакциями. До этого момента разработчики были ограничены в возможностях выполнения комплексных операций, требующих контроля над транзакционными границами.

#### Основные отличия процедур от функций
Сравнительный анализ функций и процедур показывает несколько важных аспектов:

1. **Способ вызова**
   - Функции интегрируются непосредственно в SQL-выражения (например, SELECT my_function())
   - Процедуры вызываются автономно через оператор CALL (CALL my_procedure())

2. **Возвращаемое значение**
   - Функции обязаны возвращать результат, даже если это специальный тип void
   - Процедуры могут не возвращать значений напрямую, хотя могут передавать данные через параметры

3. **Управление транзакциями**
   - Функции выполняются строго в контексте текущей транзакции без возможности самостоятельного управления COMMIT/ROLLBACK
   - Процедуры предоставляют возможность управления транзакционными границами внутри своего тела

4. **Предназначение использования**
   - Функции ориентированы на вычислительные задачи и получение результатов
   - Процедуры предназначены для выполнения операций изменения состояния базы данных

5. **Поддержка языков программирования**
   - Оба типа поддерживают различные языки (PL/pgSQL, SQL, C), но возможности управления транзакциями зависят от выбранного языка реализации

#### Зачем появились процедуры в PostgreSQL?
Появление процедур в PostgreSQL 11 стало ответом на ряд технических вызовов, с которыми сталкивались разработчики при работе с функциями. Главной проблемой было отсутствие возможности управления транзакциями внутри функций. Это создавало серьезные ограничения при реализации сложных бизнес-логик, требующих точного контроля над транзакционными границами.

Процедуры решили эту проблему несколькими способами:
- Возможность открывать и закрывать транзакции внутри процедуры
- Использование операторов COMMIT и ROLLBACK
- Контроль выполнения операций на уровне базы данных

Однако важно отметить, что управление транзакциями доступно не во всех случаях. Например, при использовании процедур на языке PL/pgSQL существуют определенные ограничения.

#### Базовый синтаксис создания процедур
Создание процедуры начинается с ключевого слова CREATE PROCEDURE, за которым следует имя процедуры и список параметров (если они есть). После указания языка реализации (LANGUAGE) следует тело процедуры, заключенное в блок $$ ... $$.

Пример простой процедуры:
```sql
CREATE PROCEDURE example_proc()
LANGUAGE SQL
AS $$
    TRUNCATE TABLE my_table;
    INSERT INTO my_table VALUES (generate_series(1,3));
$$;
```

Эта процедура выполняет следующие действия:
- Очищает таблицу my_table
- Вставляет три записи с последовательными значениями
- Вызывается через оператор CALL: `CALL example_proc();`

#### Сравнение с аналогичной логикой через функцию
Попытка реализовать аналогичную логику через функцию сталкивается с рядом ограничений:
```sql
CREATE FUNCTION example_func() RETURNS void
LANGUAGE SQL
AS $$
    TRUNCATE TABLE my_table;
    INSERT INTO my_table VALUES (generate_series(1,3));
$$;
```

Основные проблемы:
- Функция не может выполнять операции, изменяющие структуру базы данных (например, TRUNCATE)
- Должна обязательно возвращать значение (даже void)
- Вызывается как часть выражения SELECT, что может привести к ошибкам при выполнении модифицирующих операций

#### Создание процедур
При создании процедур необходимо учитывать несколько важных моментов:
6. Использование правильного синтаксиса CREATE PROCEDURE
7. Корректный выбор языка реализации
8. Понимание ограничений при работе с транзакциями
9. Особенности вызова через оператор CALL

Пример создания процедуры:
```sql
CREATE PROCEDURE my_proc()
LANGUAGE SQL
AS $$
    TRUNCATE TABLE my_table;
    INSERT INTO my_table VALUES (generate_series(1,3));
$$;
```

Вызов процедуры осуществляется следующим образом:
```sql
CALL my_proc();
```

#### Особенности процедур
Процедуры обладают рядом характерных особенностей:
- Могут выполнять сложные операции изменения данных (INSERT, UPDATE, DELETE)
- Способны вызывать другие процедуры
- Поддерживают использование циклов и условий (в PL/pgSQL)
- Не могут возвращать результат напрямую через RETURN
- Невозможно использовать в SELECT-запросах

Пример сложной процедуры:
```sql
CREATE PROCEDURE fill_table(n INT)
LANGUAGE SQL
AS $$
    TRUNCATE TABLE my_table;
    INSERT INTO my_table (value) 
    SELECT generate_series(1, n);
$$;
```

Вызов:
```sql
CALL fill_table(5);
```

#### Работа с параметрами
Процедуры поддерживают различные типы параметров:
10. **IN (входные параметры)**
   - Передаются в процедуру на вход
   - Используются по умолчанию
   ```sql
   CREATE PROCEDURE add_number(n INT)
   LANGUAGE SQL
   AS $$
       INSERT INTO numbers(value) VALUES (n);
   $$;
   ```

11. **OUT (выходные параметры)**
   - Позволяют возвращать данные из процедуры
   - Передают результат через CALL
   ```sql
   CREATE PROCEDURE get_max_value(OUT max_val INT)
   LANGUAGE SQL
   AS $$
       SELECT MAX(value) INTO max_val FROM numbers;
   $$;
   ```

12. **INOUT (комбинированные параметры)**
   - Принимают входное значение и изменяют его
   ```sql
   CREATE PROCEDURE double_number(INOUT num INT)
   LANGUAGE SQL
   AS $$
       SELECT num * 2 INTO num;
   $$;
   ```

#### Перегрузка процедур и функций
PostgreSQL поддерживает механизм перегрузки (overloading) для функций и процедур. Это позволяет создавать несколько подпрограмм с одинаковым именем, но разными параметрами.

Правила перегрузки:
- Подпрограммы должны различаться количеством или типом входных параметров
- Перегрузка невозможна только по типу возвращаемого значения
- Различие только в OUT параметрах недостаточно

Пример перегрузки функций:
```sql
CREATE FUNCTION multiply(x INT, y INT) RETURNS INT
LANGUAGE SQL
AS $$
    SELECT x * y;
$$;

CREATE FUNCTION multiply(x REAL, y REAL) RETURNS REAL
LANGUAGE SQL
AS $$
    SELECT x * y;
$$;
```

Пример перегрузки процедур:
```sql
CREATE PROCEDURE log_message(msg TEXT)
LANGUAGE SQL
AS $$
    INSERT INTO logs (message) VALUES (msg);
$$;

CREATE PROCEDURE log_message(msg TEXT, level INT)
LANGUAGE SQL
AS $$
    INSERT INTO logs (message, log_level) VALUES (msg, level);
$$;
```

#### Полиморфизм в PostgreSQL
Полиморфизм позволяет создавать универсальные функции и процедуры, работающие с различными типами данных. Для этого используются специальные полиморфные типы:
- ANYELEMENT - любой скалярный тип
- ANYARRAY - массив любого типа
- ANYRANGE - диапазон любого типа

Пример использования ANYELEMENT:
```sql
CREATE FUNCTION max_value(a ANYELEMENT, b ANYELEMENT) RETURNS ANYELEMENT
LANGUAGE SQL
AS $$
    SELECT CASE WHEN a > b THEN a ELSE b END;
$$;
```

Пример использования ANYARRAY:
```sql
CREATE FUNCTION first_element(arr ANYARRAY) RETURNS ANYELEMENT
LANGUAGE SQL
AS $$
    SELECT arr[1];
$$;
```

Пример использования ANYRANGE:
```sql
CREATE FUNCTION range_start(r ANYRANGE) RETURNS ANYELEMENT
LANGUAGE SQL
AS $$
    SELECT lower(r);
$$;
```

Ограничения полиморфных функций:
- Все аргументы и возвращаемое значение должны быть одного типа
- Нельзя смешивать разные типы данных в одном вызове
- Не все операции применимы ко всем типам данных

#### Практическое применение: Удаление дубликатов
Рассмотрим практический пример использования процедур для удаления дубликатов из таблицы авторов и предотвращения их повторного появления.

13. **Создание таблицы authors**
```sql
CREATE TABLE authors (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL
);
```

14. **Создание процедуры для удаления дубликатов**
```sql
CREATE PROCEDURE remove_duplicates()
LANGUAGE SQL
AS $$
    DELETE FROM authors
    WHERE id NOT IN (
        SELECT MIN(id) FROM authors GROUP BY name
    );
$$;
```

15. **Вызов процедуры**
```sql
CALL remove_duplicates();
```

16. **Предотвращение появления дубликатов**
```sql
ALTER TABLE authors ADD CONSTRAINT unique_author_name UNIQUE (name);
```

Альтернативные методы:
- Использование EXCLUDE
```sql
ALTER TABLE authors ADD CONSTRAINT no_duplicate_authors
EXCLUDE USING BTREE (name WITH =);
```

- Использование BEFORE INSERT TRIGGER
```sql
CREATE OR REPLACE FUNCTION prevent_duplicates()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM authors WHERE name = NEW.name) THEN
        RETURN NULL;  -- Отменить вставку
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_duplicate_insert
BEFORE INSERT ON authors
FOR EACH ROW EXECUTE FUNCTION prevent_duplicates();
```

#### Заключение
Изучение функций и процедур в PostgreSQL показывает, что эти инструменты предоставляют мощные возможности для организации бизнес-логики базы данных. Ключевые выводы:

17. Функции подходят для вычислительных задач и получения результатов, тогда как процедуры лучше использовать для операций изменения состояния базы данных.
18. Управление транзакциями внутри процедур предоставляет дополнительную гибкость при реализации сложных операций.
19. Механизмы перегрузки и полиморфизма позволяют создавать универсальные подпрограммы, работающие с различными типами данных.
20. Комбинация процедур и ограничений целостности обеспечивает эффективное решение практических задач, таких как удаление дубликатов и предотвращение их повторного появления.

Понимание этих концепций и их правильное применение позволяет разработчикам создавать более эффективные и надежные базы данных в PostgreSQL.