### **Часть 5: Практическое применение триггеров**

#### **1. Проверка применимости операций**

Триггеры можно использовать для **проверки применимости операции** перед её выполнением. Это особенно полезно, если нужно убедиться, что операция соответствует бизнес-правилам или ограничениям, прежде чем она будет выполнена. Например, можно предотвратить обновление или удаление строк, если они не соответствуют определенным условиям.

**Пример:**

```sql
CREATE FUNCTION check_valid_balance() RETURNS TRIGGER AS $$
BEGIN
  IF NEW.balance < 0 THEN
    RAISE EXCEPTION 'Баланс не может быть отрицательным';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_negative_balance
BEFORE UPDATE ON accounts
FOR EACH ROW
EXECUTE FUNCTION check_valid_balance();
```

Этот триггер **проверяет, что баланс не становится отрицательным** при обновлении, и выбрасывает исключение, если условие нарушается.

---

#### **2. Логирование и аудит изменений**

Триггеры часто используются для **логирования операций**. Например, если нужно отслеживать все изменения в таблице (вставки, обновления, удаления), можно создать триггер, который будет записывать такие изменения в отдельную журналирующую таблицу.

**Пример логирования изменений:**

```sql
CREATE FUNCTION log_changes() RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO change_log (operation, table_name, old_value, new_value, change_time)
  VALUES (TG_OP, TG_TABLE_NAME, OLD.value, NEW.value, NOW());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_changes
AFTER INSERT OR UPDATE OR DELETE ON products
FOR EACH ROW
EXECUTE FUNCTION log_changes();
```

Этот триггер записывает все изменения в таблице `products` в таблицу `change_log`, указывая тип операции, старые и новые значения и время изменения.

---

#### **3. Каскадные обновления и синхронизация данных**

Иногда необходимо **синхронизировать данные** между несколькими таблицами. Например, при изменении записей в одной таблице нужно обновить значения в других таблицах. Это можно сделать с помощью триггеров.

**Пример каскадного обновления:**

```sql
CREATE FUNCTION update_related_table() RETURNS TRIGGER AS $$
BEGIN
  UPDATE related_table
  SET related_column = NEW.value
  WHERE related_column = OLD.value;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_related_data
AFTER UPDATE ON main_table
FOR EACH ROW
EXECUTE FUNCTION update_related_table();
```

Этот триггер **синхронизирует данные** в таблице `related_table` с изменениями в таблице `main_table`, обновляя столбец `related_column`, если значение `value` было изменено в основной таблице.

---

#### **4. Проверка целостности данных**

Триггеры можно использовать для обеспечения **целостности данных** в базе данных. Например, если необходимо убедиться, что данные всегда соответствуют определённым правилам (например, уникальности, диапазону значений и т. д.), можно создать триггер, который проверяет эти условия перед выполнением операции.

**Пример проверки уникальности:**

```sql
CREATE FUNCTION check_unique_username() RETURNS TRIGGER AS $$
BEGIN
  IF EXISTS (SELECT 1 FROM users WHERE username = NEW.username) THEN
    RAISE EXCEPTION 'Имя пользователя уже существует';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_duplicate_username
BEFORE INSERT OR UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION check_unique_username();
```

Этот триггер проверяет, что при добавлении или обновлении записи в таблице `users` не будет вставлено дублирующееся имя пользователя.

---

#### **5. Асинхронная обработка и отложенные операции**

Триггеры также могут быть использованы для **отложенной обработки событий**. Например, можно отложить выполнение какой-то операции или передать её в очередь на обработку в фоновом режиме.

**Пример асинхронной обработки:**

```sql
CREATE FUNCTION enqueue_async_task() RETURNS TRIGGER AS $$
BEGIN
  -- Добавление записи в очередь для фоново обработки
  INSERT INTO task_queue (task_name, task_data)
  VALUES ('Process Data', NEW.data);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER queue_task
AFTER INSERT ON data_table
FOR EACH ROW
EXECUTE FUNCTION enqueue_async_task();
```

Этот триггер записывает задачи в очередь `task_queue` после вставки новых данных в таблицу `data_table`. Задачи могут быть обработаны в фоновом режиме позже.

---

#### **6. Ограничение отрицательных значений и проверка остатков**

Одним из самых распространённых случаев использования триггеров является **проверка остатков**. Например, если вы не хотите позволить пользователю совершить покупку, если товар не доступен в нужном количестве на складе, триггер может обеспечить такую проверку.

**Пример ограничения отрицательных остатков:**

```sql
CREATE FUNCTION check_stock() RETURNS TRIGGER AS $$
BEGIN
  IF NEW.quantity < 0 THEN
    RAISE EXCEPTION 'Недостаточно товара на складе';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_negative_stock
BEFORE UPDATE ON stock
FOR EACH ROW
EXECUTE FUNCTION check_stock();
```

Этот триггер **не позволяет установить отрицательное количество товара** на складе, проверяя значение перед его обновлением.

---

### **Выводы по части 5**

- Триггеры могут использоваться для **проверки применимости операций**, таких как предотвращение обновлений или удалений, если они нарушают бизнес-правила.
- Они часто применяются для **логирования и аудита**, что позволяет отслеживать все изменения в базе данных.
- Триггеры могут **синхронизировать данные** между таблицами или выполнять **каскадные обновления**.
- Они обеспечивают **целостность данных** с помощью проверок уникальности, диапазонов и других ограничений.
- Триггеры могут быть использованы для **асинхронной обработки** и отложенных операций, повышая гибкость системы.
- Примеры ограничений, таких как **проверка остатков**, показывают, как триггеры могут использоваться для бизнес-логики и обеспечения консистентности данных.

---

Переходим к **Части 6: Проблемы и нюансы работы с триггерами**?