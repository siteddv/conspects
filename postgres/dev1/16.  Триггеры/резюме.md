### Конспект по триггерам в базах данных

#### Введение в триггеры
Триггеры — это механизмы автоматического выполнения операций в базе данных при изменении данных. Они играют важную роль в поддержании целостности данных, автоматизации задач и выполнения бизнес-логики без необходимости изменения клиентского кода. Триггер состоит из двух частей: самого триггера, который определяет событие, при котором он должен срабатывать, и триггерной функции, которая выполняется при срабатывании триггера.

Триггеры могут отслеживать изменения в таблицах или представлениях и реагировать на такие события, как `INSERT`, `UPDATE` и `DELETE`. Когда в базе данных выполняется одна из этих операций, система проверяет наличие соответствующего триггера. Если триггер найден, он выполняет триггерную функцию, которая может либо отменить операцию, выбросив исключение, либо изменить данные перед записью в таблицу, либо запустить дополнительные действия, такие как запись изменений в журнал или обновление связанных таблиц.

Триггеры работают внутри транзакций, что означает, что если триггер выбрасывает исключение, вся транзакция откатывается. Это позволяет гарантировать согласованность данных. Например, `AFTER`-триггеры могут использоваться для логирования или других побочных эффектов без изменения данных.

Триггерная функция — это специальная функция, вызываемая при срабатывании триггера. Она не принимает параметры (они определяются контекстом триггера) и возвращает специальный тип `TRIGGER`. Функция может использовать переменные `OLD` и `NEW`, содержащие данные до и после изменения, а также доступ к контекстным переменным, таким как `TG_OP`, `TG_TABLE_NAME` и `TG_WHEN`.

Пример объявления триггерной функции в PostgreSQL:
```sql
CREATE FUNCTION my_trigger_function() RETURNS TRIGGER AS $$
BEGIN
  -- Пример проверки данных перед вставкой
  IF NEW.amount < 0 THEN
    RAISE EXCEPTION 'Negative amount is not allowed';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```
Эта функция проверяет, что значение `amount` неотрицательное. Если условие нарушено, операция прерывается (`RAISE EXCEPTION`). Если всё нормально, возвращается `NEW`, и запись выполняется.

Триггер, использующий эту функцию:
```sql
CREATE TRIGGER check_amount
BEFORE INSERT OR UPDATE ON transactions
FOR EACH ROW EXECUTE FUNCTION my_trigger_function();
```
Этот триггер работает до вставки или обновления и применяется к каждой строке, вызывая `my_trigger_function()`, которая проверяет корректность данных.

#### Механика работы триггеров
Триггеры могут реагировать на следующие команды изменения данных (DML-операции):
- `INSERT` – вставка новых записей.
- `UPDATE` – обновление существующих записей.
- `DELETE` – удаление записей.
- `TRUNCATE` – очистка таблицы (удаляет все строки без возможности восстановления).

Каждый триггер должен быть привязан к одному или нескольким этим событиям. Например:
```sql
CREATE TRIGGER my_trigger
BEFORE INSERT OR UPDATE ON my_table
FOR EACH ROW
EXECUTE FUNCTION my_trigger_function();
```

Триггеры могут выполняться в разные моменты:
1. **BEFORE (До операции)** – срабатывает перед тем, как выполняется `INSERT`, `UPDATE` или `DELETE`. Используется для проверки данных перед их изменением, изменения данных до их вставки/обновления или отмены операции, выбросив ошибку (`RAISE EXCEPTION`).
2. **AFTER (После операции)** – срабатывает после завершения изменения данных. Используется для аудита изменений, логирования, каскадных операций. Не может отменить операцию, так как данные уже изменены.
3. **INSTEAD OF (Вместо операции)** – применяется только к `VIEW` (представлениям). Позволяет определить свою логику обновления представлений.

Триггеры на уровне оператора (`FOR EACH STATEMENT`) выполняются один раз для всей команды и не видят отдельные строки, изменяемые в запросе. Полезны для аудита, логирования, агрегатных проверок. Например:
```sql
CREATE TRIGGER log_update
AFTER UPDATE ON my_table
FOR EACH STATEMENT
EXECUTE FUNCTION log_changes();
```
Этот триггер срабатывает один раз, даже если `UPDATE` изменяет 1000 строк.

Триггеры на уровне строк (`FOR EACH ROW`) выполняются для каждой строки, участвующей в операции, позволяют модифицировать данные `NEW` перед записью (`BEFORE`) и анализировать изменения `OLD` и `NEW` (`AFTER`). Например:
```sql
CREATE TRIGGER check_negative
BEFORE INSERT OR UPDATE ON transactions
FOR EACH ROW
WHEN (NEW.amount < 0)
EXECUTE FUNCTION raise_exception();
```
Этот триггер срабатывает для каждой измененной строки.

Для таблиц можно использовать `BEFORE`, `AFTER` и `INSTEAD OF` триггеры. Для представлений (`VIEW`) доступны только `INSTEAD OF` триггеры, так как сами `VIEW` не хранят данные. Для `TRUNCATE` триггеры работают только на уровне оператора (`FOR EACH STATEMENT`), так как `TRUNCATE` удаляет все строки сразу.

Можно ограничить срабатывание триггера, добавив условие `WHEN`. Это повышает производительность, так как триггерная функция не вызывается, если условие не выполняется. Например:
```sql
CREATE TRIGGER check_negative_amount
BEFORE INSERT OR UPDATE ON transactions
FOR EACH ROW
WHEN (NEW.amount < 0)
EXECUTE FUNCTION raise_exception();
```

#### Контекст выполнения триггеров
При срабатывании триггера в его функции доступен специальный контекст выполнения, содержащий информацию об операции, которая вызвала триггер. В PostgreSQL этот контекст представлен предопределенными переменными:

| Переменная | Описание |
|------------|----------|
| `TG_NAME` | Имя триггера |
| `TG_TABLE_NAME` | Имя таблицы, для которой сработал триггер |
| `TG_WHEN` | Когда сработал триггер: `BEFORE`, `AFTER`, `INSTEAD OF` |
| `TG_LEVEL` | Уровень триггера: `ROW` (на уровне строки) или `STATEMENT` (на уровне оператора) |
| `TG_OP` | Тип операции: `INSERT`, `UPDATE`, `DELETE`, `TRUNCATE` |
| `TG_RELID` | OID (уникальный идентификатор) таблицы, для которой сработал триггер |
| `TG_TABLE_SCHEMA` | Имя схемы таблицы |
| `TG_ARGV[n]` | Дополнительные аргументы триггера, если они были переданы |

Пример использования:
```sql
RAISE NOTICE 'Триггер % сработал на таблице % при выполнении %', TG_NAME, TG_TABLE_NAME, TG_OP;
```

В триггерах на уровне строк (`FOR EACH ROW`) доступны две особые переменные:
- **`OLD`** – содержит значение строки до изменения (доступна в `UPDATE`, `DELETE`).
- **`NEW`** – содержит значение строки после изменения (доступна в `INSERT`, `UPDATE`).

Пример использования:
```sql
RAISE NOTICE 'Старое значение: %, новое значение: %', OLD.amount, NEW.amount;
```

Разница между `BEFORE`, `AFTER`, `INSTEAD OF` триггерами:

| Тип триггера | Когда срабатывает | Доступ к `OLD`/`NEW` | Можно изменить `NEW` | Может отменить операцию |
|--------------|-------------------|----------------------|----------------------|-------------------------|
| `BEFORE` | Перед операцией | Да | Да | Да |
| `AFTER` | После операции | Да | Нет | Нет |
| `INSTEAD OF` | Вместо операции (только для `VIEW`) | Да | Да | Да |

Пример `BEFORE` триггера (изменение данных перед записью):
```sql
CREATE FUNCTION normalize_price() RETURNS TRIGGER AS $$
BEGIN
  NEW.price = ROUND(NEW.price, 2); -- Округляем цену до двух знаков
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER round_price_trigger
BEFORE INSERT OR UPDATE ON products
FOR EACH ROW
EXECUTE FUNCTION normalize_price();
```

Пример `AFTER` триггера (логирование изменений):
```sql
CREATE FUNCTION log_price_change() RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO price_log(product_id, old_price, new_price, change_date)
  VALUES (OLD.id, OLD.price, NEW.price, NOW());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER price_change_trigger
AFTER UPDATE ON products
FOR EACH ROW
WHEN (OLD.price <> NEW.price)
EXECUTE FUNCTION log_price_change();
```

Пример `INSTEAD OF` триггера (обновление представления):
```sql
CREATE FUNCTION update_view() RETURNS TRIGGER AS $$
BEGIN
  UPDATE real_table SET name = NEW.name WHERE id = OLD.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER update_view_trigger
INSTEAD OF UPDATE ON my_view
FOR EACH ROW
EXECUTE FUNCTION update_view();
```

#### Триггеры с переходными таблицами
Переходные таблицы – это специальные временные таблицы, которые содержат все измененные строки в рамках `AFTER STATEMENT` триггера.
- **`OLD TABLE`** – хранит удаленные (`DELETE`) или измененные (`UPDATE`) строки до изменения.
- **`NEW TABLE`** – хранит новые (`INSERT`) или обновленные (`UPDATE`) строки после изменения.

Переходные таблицы полезны, когда нужно проанализировать все строки сразу, выполнить агрегатные проверки перед фиксацией данных или логировать все изменения одним запросом вместо вызова триггера на каждую строку.

Пример использования:
```sql
CREATE TRIGGER log_changes_trigger
AFTER UPDATE ON products
REFERENCING OLD TABLE AS old_products NEW TABLE AS new_products
FOR EACH STATEMENT
EXECUTE FUNCTION log_changes();
```

Пример функции, которая анализирует изменения в `AFTER STATEMENT` триггере:
```sql
CREATE FUNCTION log_bulk_changes() RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO product_log(product_id, old_price, new_price, change_time)
  SELECT o.id, o.price, n.price, NOW()
  FROM old_products o
  JOIN new_products n ON o.id = n.id
  WHERE o.price <> n.price;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

Различия между `FOR EACH ROW` и `FOR EACH STATEMENT` с переходными таблицами:

| Характеристика | `FOR EACH ROW` | `FOR EACH STATEMENT` с переходными таблицами |
|----------------|----------------|---------------------------------------------|
| Количество вызовов | Для каждой строки | Один раз на всю команду |
| Доступ к `OLD` и `NEW` | По одной строке | Все строки сразу |
| Оптимально для | Логики на уровне строк | Агрегатного анализа |
| Производительность | Медленнее при массовых изменениях | Быстрее при массовых изменениях |

#### Практическое применение триггеров
Триггеры могут использоваться для различных целей, таких как проверка применимости операций, логирование и аудит изменений, каскадные обновления и синхронизация данных, проверка целостности данных, асинхронная обработка и отложенные операции, ограничение отрицательных значений и проверка остатков.

Пример проверки применимости операций:
```sql
CREATE FUNCTION check_valid_balance() RETURNS TRIGGER AS $$
BEGIN
  IF NEW.balance < 0 THEN
    RAISE EXCEPTION 'Баланс не может быть отрицательным';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER prevent_negative_balance
BEFORE UPDATE ON accounts
FOR EACH ROW
EXECUTE FUNCTION check_valid_balance();
```

Пример логирования изменений:
```sql
CREATE FUNCTION log_changes() RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO change_log (operation, table_name, old_value, new_value, change_time)
  VALUES (TG_OP, TG_TABLE_NAME, OLD.value, NEW.value, NOW());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER audit_changes
AFTER INSERT OR UPDATE OR DELETE ON products
FOR EACH ROW
EXECUTE FUNCTION log_changes();
```

Пример каскадного обновления:
```sql
CREATE FUNCTION update_related_table() RETURNS TRIGGER AS $$
BEGIN
  UPDATE related_table
  SET related_column = NEW.value
  WHERE related_column = OLD.value;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER update_related_data
AFTER UPDATE ON main_table
FOR EACH ROW
EXECUTE FUNCTION update_related_table();
```

Пример проверки уникальности:
```sql
CREATE FUNCTION check_unique_username() RETURNS TRIGGER AS $$
BEGIN
  IF EXISTS (SELECT 1 FROM users WHERE username = NEW.username) THEN
    RAISE EXCEPTION 'Имя пользователя уже существует';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER prevent_duplicate_username
BEFORE INSERT OR UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION check_unique_username();
```

Пример асинхронной обработки:
```sql
CREATE FUNCTION enqueue_async_task() RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO task_queue (task_name, task_data)
  VALUES ('Process Data', NEW.data);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER queue_task
AFTER INSERT ON data_table
FOR EACH ROW
EXECUTE FUNCTION enqueue_async_task();
```

Пример ограничения отрицательных остатков:
```sql
CREATE FUNCTION check_stock() RETURNS TRIGGER AS $$
BEGIN
  IF NEW.quantity < 0 THEN
    RAISE EXCEPTION 'Недостаточно товара на складе';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER prevent_negative_stock
BEFORE UPDATE ON stock
FOR EACH ROW
EXECUTE FUNCTION check_stock();
```

#### Проблемы и нюансы работы с триггерами
Сложность отладки триггеров является одним из самых значительных недостатков. Триггеры выполняются внутри транзакций и часто скрыты от пользователя, что затрудняет понимание того, что происходит в базе данных. Это может усложнить трассировку и повлиять на производительность, особенно если триггеры выполняют долгие операции.

Важно учитывать порядок выполнения триггеров, особенно когда несколько триггеров настроены на одно и то же событие. В PostgreSQL триггеры выполняются в том порядке, в котором они были созданы, что может вызвать неожиданные результаты, если одна операция зависит от другой.

Использование изменчивых функций может создать трудности при анализе данных, так как результат функции может не быть одинаковым для каждого вызова. Это может привести к непредсказуемому поведению и осложнить тестирование и поддержку.

Триггеры могут существенно повлиять на производительность базы данных, особенно если они выполняются на уровне каждой строки и включают сложные операции. При работе с большими объемами данных триггеры могут замедлять обработку данных, так как каждый триггер выполняется на каждую строку.

#### Примеры из практики
4. **Исторические таблицы**: Создание исторических таблиц для отслеживания всех изменений в таблице данных.
5. **Обновляемые представления**: Использование `INSTEAD OF` триггеров для обновления данных через представления.
6. **Ограничение отрицательных значений**: Предотвращение покупки товаров при недостаточности их на складе.
7. **Использование переходных таблиц для массовых изменений**: Анализ изменений зарплат сотрудников при массовом обновлении.
8. **Автоматическое создание исторических таблиц**: Создание исторической таблицы для каждой новой таблицы, создаваемой в базе данных.

#### Заключение и задачи на практику
Триггеры являются мощным инструментом для автоматического выполнения действий в базе данных при изменении данных. Они обеспечивают высокий уровень гибкости и могут быть использованы для выполнения различных операций, таких как проверка целостности данных, логирование изменений, автоматическое обновление данных, агрегатные операции и обработка исключений.

Важно понимать, что триггеры могут стать сложными для отладки и сопровождения, особенно если они включают сложную бизнес-логику или взаимозависимые триггеры. Кроме того, триггеры могут негативно повлиять на производительность, если их использование не оптимизировано, особенно при массовых изменениях данных.

Рекомендации:
- Используйте триггеры для автоматизации проверок и выполнения стандартных операций, таких как логирование изменений или выполнение каскадных обновлений.
- Не создавайте сложную бизнес-логику внутри триггеров, так как это может привести к трудностям при отладке и поддержке.
- Применяйте триггеры для обеспечения целостности данных, но старайтесь минимизировать их влияние на производительность.
- Тщательно отслеживайте порядок выполнения триггеров и убедитесь, что они не влияют друг на друга неожиданным образом.

Задачи на практику:
9. Реализация триггера для представления каталога (задача с обновлением представлений).
10. Реализация триггера для предотвращения отрицательных остатков.
11. Реализация триггера для логирования изменений в таблице `products`.
12. Использование переходных таблиц для массовых изменений.
13. Реализация событийного триггера для автоматического создания исторической таблицы.

Триггеры — это мощный инструмент, который позволяет значительно улучшить производительность и функциональность системы баз данных, автоматизируя задачи, которые иначе потребовали бы множества ручных операций. Работая с триггерами, важно учитывать производительность, сложность отладки и взаимодействие между триггерами, чтобы избежать ошибок и добиться оптимального функционирования системы.