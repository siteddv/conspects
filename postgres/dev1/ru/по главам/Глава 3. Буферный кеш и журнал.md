# Глава 3. Буферный кеш и журнал

## Содержание

- [[1. Введение в буферный кэш]] [1. Введение в буферный кэш](../полный/3. Буферный кеш и журнал/1. Введение в буферный кэш.md)
- [[2. Механизм работы буферного кэша]] [2. Механизм работы буферного кэша](../полный/3. Буферный кеш и журнал/2. Механизм работы буферного кэша.md)
- [[3. Организация и управление памятью в буферном кэше]] [3. Организация и управление памятью в буферном кэше](../полный/3. Буферный кеш и журнал/3. Организация и управление памятью в буферном кэше.md)
- [[4. Журнал предзаписи (WAL) и его роль]] [4. Журнал предзаписи (WAL) и его роль](../полный/3. Буферный кеш и журнал/4. Журнал предзаписи (WAL) и его роль.md)
- [[5. Контрольные точки (Checkpoints) и оптимизация работы с WAL]] [5. Контрольные точки (Checkpoints) и оптимизация работы с WAL](../полный/3. Буферный кеш и журнал/5. Контрольные точки (Checkpoints) и оптимизация работы с WAL.md)
- [[6. Разные подходы к записи данных на диск]] [6. Разные подходы к записи данных на диск](../полный/3. Буферный кеш и журнал/6. Разные подходы к записи данных на диск.md)
- [[7. Дополнительные возможности WAL]] [7. Дополнительные возможности WAL](../полный/3. Буферный кеш и журнал/7. Дополнительные возможности WAL.md)
- [[8. Практика и эксперименты с буферным кэшем и WAL]] [8. Практика и эксперименты с буферным кэшем и WAL](../полный/3. Буферный кеш и журнал/8. Практика и эксперименты с буферным кэшем и WAL.md)

---

## Буферный кэш и механизмы работы PostgreSQL

Буферный кэш представляет собой фундаментальный механизм в PostgreSQL, предназначенный для оптимизации работы с данными и уменьшения разницы в скорости между оперативной памятью и дисками. Основная задача буферного кэша заключается в временном хранении данных в оперативной памяти после их чтения с диска или перед записью на него. Это позволяет значительно сократить количество прямых обращений к дисковой подсистеме, что критически важно из-за существенной разницы в скорости доступа: оперативная память работает за ~100 наносекунд, SSD - за ~100 микросекунд, а HDD - за 5-10 миллисекунд.

Структурно буферный кэш представляет собой массив буферов, где каждый буфер содержит одну страницу данных размером 8 КБ (стандартный размер страницы в PostgreSQL) и дополнительную служебную информацию. Доступ к данным осуществляется постранично: если нужная страница уже находится в кэше, данные читаются напрямую из него; если нет - происходит обращение к операционной системе, которая проверяет свой файловый кэш, и только при отсутствии данных там выполняется физическое чтение с диска.

Механизм работы буферного кэша можно описать следующей последовательностью действий: при поступлении пользовательского запроса система сначала проверяет наличие нужных данных в собственном кэше PostgreSQL. Если данные отсутствуют, происходит обращение к кэшу операционной системы, и только при их отсутствии выполняется чтение с диска. После загрузки страницы она остается в кэше для последующего использования, что значительно ускоряет повторные запросы к тем же данным.

## Журнал предзаписи (WAL)

Однако использование буферного кэша создает потенциальную проблему потери данных в случае сбоя системы, так как измененные страницы (грязные данные) могут находиться только в оперативной памяти и не быть записанными на диск. Для решения этой проблемы PostgreSQL использует механизм журнала предзаписи (Write-Ahead Logging, WAL).

Журнал предзаписи (WAL) является критически важным компонентом системы, обеспечивающим надежность хранения данных. Его основной принцип заключается в том, что любые изменения данных сначала фиксируются в WAL, и только потом применяются к самим данным в буферном кэше. Это гарантирует, что даже в случае аварийного завершения работы системы все изменения могут быть восстановлены путем проигрывания записей WAL.

Работа WAL организована таким образом, что в журнал записываются не сами измененные страницы, а инструкции, описывающие произведенные изменения. При выполнении запроса UPDATE сначала создается соответствующая запись в WAL, которая затем синхронизируется на диск. Только после этого данные обновляются в буферном кэше. При восстановлении после сбоя система последовательно применяет записи WAL, восстанавливая согласованное состояние базы данных.

## Контрольные точки (Checkpoints)

Для управления объемом WAL и оптимизации процесса восстановления используются контрольные точки (Checkpoints). Эти точки фиксируют момент, когда все изменения из буферного кэша гарантированно записаны на диск, позволяя удалить старые записи WAL. По умолчанию контрольные точки создаются каждые 5 минут или при достижении размера WAL-логов в 1 ГБ, но эти параметры можно настраивать через конфигурационный файл postgresql.conf.

## Режимы записи данных

PostgreSQL предоставляет гибкие возможности настройки режимов записи данных, позволяя найти баланс между производительностью и надежностью. Основные режимы записи включают:

1. Синхронную запись (synchronous commit), при которой после COMMIT система дожидается записи изменений в WAL на диск перед подтверждением транзакции. Этот режим обеспечивает максимальную надежность, но снижает скорость работы из-за медленной операции записи на диск.

2. Асинхронную запись (asynchronous commit), где COMMIT выполняется мгновенно, а запись в WAL происходит фоновым процессом. Такой подход ускоряет работу, но создает риск потери данных при сбое, если транзакция была зафиксирована, но WAL еще не записан на диск.

Настройка режима записи осуществляется через параметр synchronous_commit: on (полная синхронная запись, надежно, но медленно), off (асинхронная запись, быстро, но может привести к потере данных), local (синхронно только для локального WAL при наличии репликации).

## Дополнительные возможности WAL

Журнал предзаписи (WAL) имеет дополнительные важные функции помимо обеспечения надежности данных. Одной из ключевых возможностей является Point-in-Time Recovery (PITR) - механизм восстановления базы данных до конкретного момента времени. Этот процесс включает создание базового резервного копирования (обычно с помощью pg_basebackup) и последующее применение WAL-журналов для восстановления данных на нужный момент времени.

Файлы WAL хранятся в каталоге pg_wal, их стандартный размер составляет 16 МБ. Можно настроить автоматическую архивацию WAL через параметр archive_mode = on. Это позволяет эффективно управлять процессом резервного копирования и восстановления.

## Репликация

Другой важной функцией WAL является поддержка репликации, которая реализуется двумя основными способами:

1. Потоковая репликация (Streaming Replication), при которой основной сервер (primary) записывает изменения в WAL, а реплики (standby) получают и применяют эти записи в реальном времени. Существует два типа потоковой репликации: синхронная репликация (synchronous_commit=on), гарантирующая завершение транзакции только после записи данных на все реплики, и асинхронная репликация (synchronous_commit=off), где транзакция завершается сразу, а данные реплицируются с задержкой.

2. Логическая репликация, отличающаяся от потоковой тем, что вместо передачи страниц данных передаются SQL-команды (INSERT, UPDATE, DELETE). Этот тип репликации позволяет реплицировать только отдельные таблицы, а не всю базу данных, и удобен для миграции данных между версиями PostgreSQL.

## Практическое применение

Практическое исследование работы буферного кэша и различных типов таблиц демонстрирует их особенности и области применения. В экспериментах с обычными таблицами четко видно влияние буферного кэша на производительность: первый запрос, требующий чтения данных с диска, выполняется значительно дольше, чем последующие, использующие данные из кэша.

Временные таблицы (TEMP TABLE) представляют собой особый тип таблиц, существующих только в рамках текущей сессии. Их главное преимущество заключается в том, что они не попадают в WAL, что делает работу с ними быстрее, но при этом они теряют все данные при завершении сессии. Не журналируемые таблицы (UNLOGGED) занимают промежуточное положение между обычными и временными таблицами. Они также не записываются в WAL, что обеспечивает высокую производительность, но сохраняют данные между сессиями. Однако такие таблицы теряют данные при сбое системы и не поддерживают репликацию.

**Подробнее:** [[3. Буферный кеш и журнал]] [3. Буферный кеш и журнал](../полный/3. Буферный кеш и журнал/резюме.md)

