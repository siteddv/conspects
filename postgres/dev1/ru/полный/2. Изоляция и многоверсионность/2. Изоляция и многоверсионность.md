# 2. Изоляция и многоверсионность

## Содержание

- [[1. Введение в проблему многоверсионности и изоляции транзакций]] [1. Введение в проблему многоверсионности и изоляции транзакций](части/1. Введение в проблему многоверсионности и изоляции транзакций.md)
- [[2. Как работает механизм многоверсионности (MVCC)]] [2. Как работает механизм многоверсионности (MVCC)](части/2. Как работает механизм многоверсионности (MVCC).md)
- [[3. Снимки данных и согласованность]] [3. Снимки данных и согласованность](части/3. Снимки данных и согласованность.md)
- [[4. Уровни изоляции транзакций]] [4. Уровни изоляции транзакций](части/4. Уровни изоляции транзакций.md)
- [[5. Примеры работы с транзакциями в PostgreSQL]] [5. Примеры работы с транзакциями в PostgreSQL](части/5. Примеры работы с транзакциями в PostgreSQL.md)
- [[6. Блокировки и их влияние на производительность]] [6. Блокировки и их влияние на производительность](части/6. Блокировки и их влияние на производительность.md)
- [[7. Очистка старых версий данных и процесс VACUUM]] [7. Очистка старых версий данных и процесс VACUUM](части/7. Очистка старых версий данных и процесс VACUUM.md)

---

### Конспект по работе транзакций, изоляции и очистке данных в PostgreSQL

PostgreSQL — это мощная реляционная СУБД, которая использует уникальные механизмы для обеспечения согласованности данных при параллельной работе нескольких транзакций. В этом конспекте мы подробно разберем, как работает многоверсионность (MVCC), как устроены транзакции, уровни изоляции, блокировки и процессы очистки данных.

---

### **1. Проблема параллельного доступа к данным**

Когда несколько транзакций работают с одной и той же базой данных, возникают ситуации, которые могут привести к несогласованности данных. Например:
- Две транзакции читают одну и ту же строку.
- Одна транзакция читает строку, а другая пытается её изменить.
- Обе транзакции пытаются изменить одну и ту же строку.

Если такие ситуации не контролировать, могут возникнуть конфликты обновлений или чтение некорректных данных. Для решения этой проблемы существуют два простых подхода:
1. **Полная блокировка**: Первая транзакция блокирует строку, пока не завершится, что гарантирует согласованность, но снижает производительность.
2. **Разрешение чтения незавершенных изменений**: Читающая транзакция видит изменения, сделанные другой транзакцией, даже если они ещё не зафиксированы. Это увеличивает производительность, но может привести к чтению несогласованных данных.

Оба этих подхода имеют недостатки, поэтому PostgreSQL использует более сложный механизм — **многоверсионность (MVCC)**.

---

### **2. Как работает MVCC**

#### **Принцип хранения нескольких версий строк**
В отличие от традиционных СУБД, которые перезаписывают данные в одной и той же строке, PostgreSQL хранит несколько версий одной строки. Это позволяет транзакциям:
- Читать данные без блокировки.
- Видеть разные версии строки в зависимости от момента начала транзакции.
- Гарантировать согласованность данных без потери производительности.

**Как это работает:**
- При выполнении `INSERT` создается новая строка с уникальным номером транзакции.
- При выполнении `UPDATE` PostgreSQL создает новую версию строки, а старая остается в истории.
- При выполнении `DELETE` строка не удаляется сразу, а становится невидимой для новых транзакций.

Таким образом, вместо перезаписи данных система просто создает новые версии строк, что минимизирует конфликты и блокировки.

#### **Метаданные строк: `xmin` и `xmax`**
Каждая версия строки в PostgreSQL хранит два специальных параметра:
- **`xmin`**: Номер транзакции, которая создала эту версию строки.
- **`xmax`**: Номер транзакции, которая сделала строку невидимой (например, обновила или удалила её).

Пример:
| id | data  | xmin | xmax |
|----|-------|------|------|
| 1  | "A"   | 100  | 102  |
| 1  | "B"   | 102  | 0    |

- Строка `"A"` была создана транзакцией **100**, а стала недоступной после выполнения транзакции **102**.
- Строка `"B"` была создана транзакцией **102** и пока ещё актуальна (`xmax = 0`).

---

### **3. Снимки данных и согласованность**

Снимок данных (Snapshot) — это логический срез базы данных на момент начала транзакции. Снимок данных создается при начале транзакции и состоит из номера текущей транзакции, списка активных транзакций и диапазона видимых `xmin` и `xmax`.

При построении снимка система отбрасывает невидимые версии строк, используя `xmin` и `xmax`. Каждая транзакция видит только те версии строк, которые соответствуют правилам видимости на момент её начала.

---

### **4. Уровни изоляции транзакций**

Стандарт SQL определяет четыре уровня изоляции: Read Uncommitted (не используется в PostgreSQL), Read Committed (по умолчанию), Repeatable Read и Serializable. Каждый уровень изоляции обеспечивает различную степень защиты от аномалий параллельного доступа к данным.

Read Committed — уровень изоляции по умолчанию в PostgreSQL. При этом уровне каждая команда в транзакции видит только те данные, которые были зафиксированы до начала выполнения команды. Это означает, что два последовательных SELECT в одной транзакции могут видеть разные данные, если между ними другая транзакция зафиксировала изменения.

Repeatable Read обеспечивает, что все команды в транзакции видят один и тот же снимок данных, созданный в момент начала транзакции. Это предотвращает неповторяющееся чтение, но не защищает от фантомных чтений.

Serializable — самый строгий уровень изоляции, который обеспечивает полную изоляцию транзакций. При этом уровне транзакции выполняются так, как будто они выполняются последовательно, одна за другой.

---

### **5. Блокировки и их влияние на производительность**

PostgreSQL использует различные типы блокировок для управления конкурентным доступом к данным. Блокировки на уровне строк (Row-Level Lock) блокируют только изменяемые строки. Блокировки на уровне таблицы (Table-Level Lock) блокируют всю таблицу.

MVCC снижает необходимость в блокировках для операций чтения: чтение (`SELECT`) не блокирует других пользователей, даже если кто-то обновляет данные (`UPDATE`), другие пользователи могут продолжать чтение, так как система возвращает старую версию строки из снимка данных.

---

### **6. Очистка старых версий данных и процесс VACUUM**

Из-за механизма MVCC старые версии строк остаются в файле таблицы, даже если они больше не нужны. Это приводит к разрастанию таблиц. Процесс `VACUUM` находит старые версии строк, которые больше не видны ни одной транзакции, помечает их как свободное место и обновляет служебную информацию о транзакциях.

PostgreSQL имеет встроенный процесс автоматической очистки (`autovacuum`), который работает в фоновом режиме и сам выполняет `VACUUM`. Автоматическая очистка запускается периодически и обрабатывает таблицы, в которых накопилось много "мертвых" строк.

Разница между `VACUUM` и `VACUUM FULL`: `VACUUM` удаляет старые версии строк, освобождая место внутри таблицы, но не уменьшает размер файла; `VACUUM FULL` полностью пересоздает таблицу, уменьшая её размер, но блокирует её на время выполнения.

