# 13. Динамические команды

## Описание

Эта глава посвящена динамическим SQL-командам в PostgreSQL и PL/pgSQL. Мы рассмотрим, что такое динамические SQL-команды, когда их следует использовать, и основные проблемы, связанные с их применением. Особое внимание будет уделено безопасности динамических команд, защите от SQL-инъекций с помощью `USING`, `quote_ident()`, `quote_literal()` и `FORMAT()`. Будут разобраны различные способы выполнения динамических команд (`EXECUTE`, `FOR ... IN EXECUTE`, `OPEN CURSOR FOR EXECUTE`, `RETURN QUERY EXECUTE`), а также практические примеры создания безопасных динамических запросов.

## Части главы

- [[части/1. Введение|1. Введение]] [1. Введение](части/1. Введение.md)
- [[части/2. Использование динамических команд|2. Использование динамических команд]] [2. Использование динамических команд](части/2. Использование динамических команд.md)
- [[части/3. Безопасность динамических команд|3. Безопасность динамических команд]] [3. Безопасность динамических команд](части/3. Безопасность динамических команд.md)
- [[части/4. Способы выполнения динамических команд|4. Способы выполнения динамических команд]] [4. Способы выполнения динамических команд](части/4. Способы выполнения динамических команд.md)
- [[части/5. Пример SQL-инъекции и защита от неё|5. Пример SQL-инъекции и защита от неё]] [5. Пример SQL-инъекции и защита от неё](части/5. Пример SQL-инъекции и защита от неё.md)
- [[части/6. Формирование безопасных динамических команд|6. Формирование безопасных динамических команд]] [6. Формирование безопасных динамических команд](части/6. Формирование безопасных динамических команд.md)
- [[части/7. Практические задания|7. Практические задания]] [7. Практические задания](части/7. Практические задания.md)

---

### Введение в динамические SQL-команды

Динамические SQL-команды представляют собой мощный инструмент в реляционных базах данных, позволяющий создавать и выполнять SQL-запросы непосредственно во время выполнения программы. В отличие от статических запросов, которые жестко закодированы в приложении, динамические команды формируются "на лету" как строки, содержащие SQL-код, который затем компилируется и исполняется системой управления базами данных (СУБД).

Основные сценарии использования динамических SQL-команд включают несколько ключевых ситуаций. Во-первых, они незаменимы при необходимости гибкого изменения структуры запроса. Например, когда требуется динамически добавлять или удалять условия WHERE или операторы JOIN в зависимости от входных параметров пользователя или логики приложения. Это особенно полезно в сложных системах, где структура запроса может значительно варьироваться.

Во-вторых, динамический SQL необходим при работе с неопределенными заранее таблицами и столбцами. Ситуации, когда имя таблицы или столбца передается как параметр, требуют использования динамических запросов, так как статические запросы не могут обрабатывать такие случаи. Типичным примером может служить система, работающая с разными версиями таблиц (например, users_2023, users_2024), где конкретная таблица определяется во время выполнения.

Третий важный сценарий - автоматическая генерация SQL-кода. Это особенно актуально для систем, где пользователи или администраторы должны иметь возможность управлять логикой SQL-запросов без необходимости изменения кода приложения. Например, в системах отчетности можно хранить SQL-команды в таблице настроек и выполнять их в зависимости от действий пользователя.

Наконец, динамический SQL широко применяется при формировании сложных аналитических отчетов, где структура запроса может значительно различаться в зависимости от выбранных параметров. Это позволяет создавать гибкие системы отчетности, способные адаптироваться к различным требованиям пользователей.

Однако использование динамических SQL-команд связано с рядом существенных сложностей. Первостепенной проблемой является безопасность, поскольку динамический SQL особенно подвержен атакам типа SQL-инъекций. Если формирование запроса происходит через простую конкатенацию строк без должной обработки входных данных, злоумышленники могут внедрить вредоносный код.

Производительность также представляет собой серьезную проблему. В отличие от подготовленных (prepared) запросов, динамические команды требуют парсинга и оптимизации каждый раз перед выполнением, что может привести к значительным накладным расходам при частом использовании. Кроме того, динамически формируемый SQL значительно сложнее отлаживать, тестировать и поддерживать из-за его изменчивой природы.

Разбор и планирование запроса также становятся более ресурсоемкими при использовании динамического SQL. Каждый раз, когда выполняется новый динамический запрос, сервер должен заново анализировать его структуру, строить план выполнения и оптимизировать доступ к данным. Это увеличивает нагрузку на сервер и может привести к снижению общей производительности системы.

### Использование динамических SQL-команд

При сравнении обычных статических SQL-запросов с динамическими становится очевидным фундаментальное различие в подходе к формированию и выполнению запросов. Статические запросы пишутся заранее и имеют фиксированную структуру:
```sql
SELECT * FROM users WHERE age > 25;
```
Такой запрос полностью определен на этапе написания кода и может быть выполнен без каких-либо модификаций. В то время как динамические SQL-команды формируются непосредственно во время выполнения программы:
```sql
EXECUTE format('SELECT * FROM %I WHERE age > %s', 'users', 25);
```
Эта гибкость позволяет менять различные части запроса в зависимости от условий программы, что открывает широкие возможности для создания более адаптивных и гибких приложений.

Автоматическая генерация SQL-запросов становится особенно важной в крупных системах, где администраторы или технические специалисты должны иметь возможность добавлять или модифицировать SQL-запросы без необходимости изменения кода приложения. Например, в системах отчетности можно хранить SQL-команды в специальной таблице настроек и выполнять их в зависимости от действий пользователя. Такой подход позволяет быстро адаптировать систему к новым требованиям без необходимости перекомпиляции или повторного развертывания приложения.

Динамическое добавление условий и соединений (JOIN) демонстрирует еще одну мощную возможность динамического SQL. Рассмотрим функцию, которая формирует SQL-запрос в зависимости от входных параметров:
```sql
CREATE FUNCTION get_users(min_age INT, include_address BOOLEAN) RETURNS SETOF users AS $$
DECLARE
    query TEXT;
BEGIN
    query := 'SELECT * FROM users';
    IF min_age IS NOT NULL THEN
	query := query || ' WHERE age > ' || min_age;
    END IF;
    IF include_address THEN
	query := query || ' JOIN addresses ON users.id = addresses.user_id';
    END IF;
    RETURN QUERY EXECUTE query;
END;
$$ LANGUAGE plpgsql;
```
Здесь запрос может динамически изменяться в зависимости от переданных аргументов (min_age, include_address). Это особенно полезно в ситуациях, когда невозможно заранее предсказать точную структуру запроса.

Работа с динамическими именами таблиц и столбцов представляет собой еще один важный аспект использования динамического SQL. В некоторых случаях требуется подставлять имена таблиц или столбцов непосредственно во время выполнения:
```sql
EXECUTE format('SELECT %I FROM %I', column_name, table_name);
```
Пример: если необходимо динамически обращаться к разным таблицам (users_2023, users_2024), то без динамического SQL это сделать невозможно. Такая возможность особенно ценна в системах, где данные организованы по временным периодам или другим динамическим критериям.

Генерация сложных аналитических отчетов часто требует использования динамического SQL. Например, при создании "матричных" отчетов, где структура данных меняется в зависимости от параметров, можно динамически формировать конструкции GROUP BY, PIVOT и другие. Это позволяет создавать гибкие системы отчетности, способные адаптироваться к различным требованиям пользователей.

Таким образом, динамические SQL-команды оказываются незаменимыми в следующих случаях:
1. Когда необходимо менять структуру SQL-запроса в зависимости от параметров.
2. При работе с динамическими таблицами или столбцами.
3. Для автоматизации выполнения SQL-команд.
4. При создании гибких систем отчетности.

Однако важно помнить, что динамический SQL следует использовать осознанно. В тех случаях, когда можно обойтись статическими запросами, лучше предпочесть их, так как они проще в сопровождении и менее подвержены потенциальным проблемам безопасности и производительности.

### Безопасность динамических SQL-команд

Главная проблема динамического SQL - это уязвимость к SQL-инъекциям. Эта угроза возникает, когда злоумышленник может внедрить вредоносный SQL-код через пользовательский ввод. Рассмотрим пример уязвимого кода:
```sql
CREATE FUNCTION get_user_info(user_name TEXT) RETURNS SETOF users AS $$
DECLARE
    query TEXT;
BEGIN
    query := 'SELECT * FROM users WHERE name = ''' || user_name || '''';
    RETURN QUERY EXECUTE query;
END;
$$ LANGUAGE plpgsql;
```
Если передать в `user_name` значение `'Oleg' OR '1' = '1'`, фактический SQL-запрос станет таким:
```sql
SELECT * FROM users WHERE name = 'Oleg' OR '1' = '1';
```
В результате вернутся все пользователи, что может быть критично для безопасности системы. Это демонстрирует, насколько опасной может быть простая конкатенация строк при формировании SQL-запросов.

Для защиты от SQL-инъекций существует несколько эффективных методов. Первый и наиболее рекомендуемый способ - использование параметров через `USING`. Этот метод обеспечивает максимальную безопасность:
```sql
CREATE FUNCTION get_user_info(user_name TEXT) RETURNS SETOF users AS $$
DECLARE
    query TEXT;
BEGIN
    query := 'SELECT * FROM users WHERE name = $1';
    RETURN QUERY EXECUTE query USING user_name;
END;
$$ LANGUAGE plpgsql;
```
Преимущества этого подхода включают:
- Безопасность: значения подставляются отдельно от SQL-запроса, делая SQL-инъекцию невозможной.
- Производительность: PostgreSQL может кешировать план выполнения запроса.
- Читаемость: код становится более понятным и поддерживаемым.

Второй важный метод защиты - экранирование идентификаторов с помощью функции `quote_ident()`. Это особенно важно при работе с динамическими именами таблиц и столбцов:
```sql
-- Небезопасный вариант
EXECUTE 'SELECT * FROM ' || table_name;

-- Безопасный вариант
EXECUTE 'SELECT * FROM ' || quote_ident(table_name);
```
Функция `quote_ident()` работает следующим образом:
- Если `table_name = 'users'`, результат будет просто `users`.
- Если `table_name = 'users; DROP TABLE users;'`, результат станет `"users; DROP TABLE users;"`, что вызовет ошибку, но предотвратит выполнение вредоносного кода.

Для строковых значений используется функция `quote_literal()`:
```sql
-- Небезопасно
EXECUTE 'INSERT INTO logs (message) VALUES (' || log_text || ')';

-- Безопасно
EXECUTE 'INSERT INTO logs (message) VALUES (' || quote_literal(log_text) || ')';
```
Функция `quote_literal()` преобразует:
- `log_text = 'Hello'` → `VALUES ('Hello')`
- `log_text = 'Hello'); DROP TABLE logs; --'` → `VALUES ('Hello''); DROP TABLE logs; --')`

Четвертый метод защиты - использование функции `FORMAT()`, которая автоматически экранирует передаваемые параметры:
```sql
EXECUTE FORMAT('SELECT * FROM %I WHERE id = %L', table_name, user_id);
```
Где:
- `%I` (`quote_ident`) используется для имён таблиц и столбцов.
- `%L` (`quote_literal`) используется для строковых значений.

Преимущества использования `FORMAT()` включают:
- Автоматическое экранирование параметров.
- Улучшенную читаемость кода.
- Снижение риска случайного пропуска защиты.

Для наглядного сравнения различных методов защиты можно использовать следующую таблицу:

| Задача | Неправильно ❌ | Правильно ✅ |
|---|---|---|
| Передача значений в `WHERE` | Конкатенация строк | `EXECUTE ... USING` |
| Передача имен таблиц/столбцов | Простая конкатенация | `quote_ident()` или `%I` в `FORMAT()` |
| Передача строковых значений | Прямое подставление | `quote_literal()` или `%L` в `FORMAT()` |

Важно отметить, что использование `USING` является наиболее предпочтительным методом защиты, когда это возможно. Однако в случаях, когда нужно работать с именами таблиц или столбцов, следует использовать комбинацию `quote_ident()` и `quote_literal()`, либо функцию `FORMAT()`.

Основные выводы по защите динамического SQL:
1. Никогда не используйте простую конкатенацию строк в SQL-запросах.
2. Используйте `USING` для передачи параметров значений.
3. Применяйте `quote_ident()` для имен таблиц и столбцов.
4. Используйте `quote_literal()` для строковых значений.
5. Предпочитайте использование `FORMAT()` для улучшения читаемости и безопасности кода.
6. Эти меры полностью защитят от SQL-инъекций и сделают код более безопасным и поддерживаемым.

### Способы выполнения динамических команд

PostgreSQL предоставляет несколько различных способов выполнения динамических SQL-команд, каждый из которых имеет свои особенности и области применения. Выбор конкретного метода зависит от контекста использования и требуемого результата.

Основным способом выполнения динамических SQL-команд является оператор `EXECUTE`. Он позволяет выполнить строку, содержащую SQL-запрос:
```sql
DO $$ 
DECLARE 
    query TEXT; 
BEGIN 
    query := 'SELECT COUNT(*) FROM users'; 
    EXECUTE query; 
END $$;
```
Здесь SQL-запрос формируется в строке `query` и передается в `EXECUTE` для выполнения. Этот метод прост и эффективен для выполнения одноразовых команд или запросов, не требующих возврата результатов.

Для безопасной передачи параметров используется расширение `EXECUTE ... USING`. Этот метод позволяет передавать параметры безопасно, предотвращая SQL-инъекции:
```sql
DO $$
DECLARE 
    user_count INT; 
BEGIN 
    EXECUTE 'SELECT COUNT(*) FROM users WHERE age > $1' INTO user_count USING 30;
    RAISE NOTICE 'Количество пользователей старше 30 лет: %', user_count;
END $$;
```
Преимущества этого подхода включают:
- Безопасность: SQL-инъекция невозможна благодаря разделению SQL-кода и параметров.
- Производительность: PostgreSQL может кешировать план выполнения запроса.
- Читаемость: код становится более понятным и поддерживаемым.

Когда необходимо проходить по строкам результата запроса, используется конструкция `FOR ... IN EXECUTE`:
```sql
DO $$
DECLARE 
    row RECORD;
BEGIN 
    FOR row IN EXECUTE 'SELECT id, name FROM users' 
    LOOP 
	RAISE NOTICE 'ID: %, Name: %', row.id, row.name;
    END LOOP;
END $$;
```
Этот метод особенно полезен:
- При переборе строк результата запроса.
- В реализации вложенных циклов в динамических процедурах.
- Для последовательной обработки больших объемов данных.

Для работы с большими наборами данных или когда результат нужно обработать позже, используется метод `OPEN CURSOR FOR EXECUTE`:
```sql
DO $$ 
DECLARE 
    cur REFCURSOR; 
BEGIN 
    OPEN cur FOR EXECUTE 'SELECT id, name FROM users'; 
	Курсор можно передавать в другие части кода и обрабатывать данные
END $$;
```
Преимущества использования курсоров:
- Возможность передачи курсора в клиентские приложения.
- Эффективное чтение больших объемов данных.
- Гибкость в управлении процессом выборки данных.

Когда функция должна возвращать результат динамического запроса, используется конструкция `RETURN QUERY EXECUTE`:
```sql
CREATE FUNCTION get_users_by_age(min_age INT) RETURNS SETOF users AS $$
BEGIN 
    RETURN QUERY EXECUTE 'SELECT * FROM users WHERE age > $1' USING min_age;
END;
$$ LANGUAGE plpgsql;
```
Этот метод особенно полезен:
- При создании API для работы с динамическими фильтрами.
- Для возвращения данных в другие процедуры и клиентские приложения.
- В реализации сложной бизнес-логики, требующей динамического формирования результатов.

Для наглядного сравнения различных способов выполнения динамических команд можно использовать следующую таблицу:

| Способ | Описание |
|---|---|
| `EXECUTE` | Просто выполняет SQL-запрос |
| `EXECUTE ... USING` | Выполняет запрос с безопасной передачей параметров |
| `FOR ... IN EXECUTE` | Позволяет перебрать строки результата запроса |
| `OPEN CURSOR FOR EXECUTE` | Открывает курсор для работы с данными |
| `RETURN QUERY EXECUTE` | Возвращает результат выполнения запроса |

Выбор конкретного метода зависит от конкретной задачи:
1. Если просто нужно выполнить команду - используйте `EXECUTE`.
2. Если требуется передавать параметры - используйте `EXECUTE ... USING`.
3. Если нужно перебрать результат запроса - используйте `FOR ... IN EXECUTE`.
4. Если необходим курсор для последующей обработки - используйте `OPEN CURSOR FOR EXECUTE`.
5. Если нужно вернуть результат из функции - используйте `RETURN QUERY EXECUTE`.

Важно отметить, что независимо от выбранного метода выполнения, необходимо всегда соблюдать меры безопасности и использовать соответствующие методы защиты от SQL-инъекций. Это особенно критично при работе с пользовательским вводом или внешними данными.

### Заключение

Динамический SQL представляет собой мощный инструмент в руках разработчиков баз данных, предоставляя уникальные возможности для создания гибких и адаптивных решений. Однако его использование требует глубокого понимания как потенциальных преимуществ, так и связанных с ним рисков.

Ключевые преимущества динамического SQL включают:
- Гибкость в формировании запросов, позволяющая адаптировать их под различные условия выполнения.
- Возможность работы с динамически определяемыми объектами базы данных (таблицы, столбцы).
- Поддержка сложной бизнес-логики, требующей динамического построения запросов.
- Создание гибких систем отчетности и аналитики.

Однако использование динамического SQL сопряжено с несколькими важными вызовами:
- Безопасность: высокий риск SQL-инъекций при неправильном формировании запросов.
- Производительность: необходимость повторного парсинга и оптимизации запросов.
- Сложность сопровождения: динамически формируемый SQL труднее отлаживать и тестировать.

Следуя принципам безопасного формирования динамических SQL-команд и используя соответствующие методы защиты, можно эффективно применять динамический SQL в реальных проектах, получая при этом все преимущества гибкости и адаптивности.

