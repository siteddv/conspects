Введение в динамические SQL-команды

Динамические SQL-команды представляют собой мощный инструмент в реляционных базах данных, позволяющий создавать и выполнять SQL-запросы непосредственно во время выполнения программы. В отличие от статических запросов, которые жестко закодированы в приложении, динамические команды формируются "на лету" как строки, содержащие SQL-код, который затем компилируется и исполняется системой управления базами данных (СУБД).

Основные сценарии использования динамических SQL-команд включают несколько ключевых ситуаций. Во-первых, они незаменимы при необходимости гибкого изменения структуры запроса. Например, когда требуется динамически добавлять или удалять условия WHERE или операторы JOIN в зависимости от входных параметров пользователя или логики приложения. Это особенно полезно в сложных системах, где структура запроса может значительно варьироваться.

Во-вторых, динамический SQL необходим при работе с неопределенными заранее таблицами и столбцами. Ситуации, когда имя таблицы или столбца передается как параметр, требуют использования динамических запросов, так как статические запросы не могут обрабатывать такие случаи. Типичным примером может служить система, работающая с разными версиями таблиц (например, users_2023, users_2024), где конкретная таблица определяется во время выполнения.

Третий важный сценарий - автоматическая генерация SQL-кода. Это особенно актуально для систем, где пользователи или администраторы должны иметь возможность управлять логикой SQL-запросов без необходимости изменения кода приложения. Например, в системах отчетности можно хранить SQL-команды в таблице настроек и выполнять их в зависимости от действий пользователя.

Наконец, динамический SQL широко применяется при формировании сложных аналитических отчетов, где структура запроса может значительно различаться в зависимости от выбранных параметров. Это позволяет создавать гибкие системы отчетности, способные адаптироваться к различным требованиям пользователей.

Однако использование динамических SQL-команд связано с рядом существенных сложностей. Первостепенной проблемой является безопасность, поскольку динамический SQL особенно подвержен атакам типа SQL-инъекций. Если формирование запроса происходит через простую конкатенацию строк без должной обработки входных данных, злоумышленники могут внедрить вредоносный код.

Производительность также представляет собой серьезную проблему. В отличие от подготовленных (prepared) запросов, динамические команды требуют парсинга и оптимизации каждый раз перед выполнением, что может привести к значительным накладным расходам при частом использовании. Кроме того, динамически формируемый SQL значительно сложнее отлаживать, тестировать и поддерживать из-за его изменчивой природы.

Разбор и планирование запроса также становятся более ресурсоемкими при использовании динамического SQL. Каждый раз, когда выполняется новый динамический запрос, сервер должен заново анализировать его структуру, строить план выполнения и оптимизировать доступ к данным. Это увеличивает нагрузку на сервер и может привести к снижению общей производительности системы.

Использование динамических SQL-команд

При сравнении обычных статических SQL-запросов с динамическими становится очевидным фундаментальное различие в подходе к формированию и выполнению запросов. Статические запросы пишутся заранее и имеют фиксированную структуру:
```sql
SELECT * FROM users WHERE age > 25;
```
Такой запрос полностью определен на этапе написания кода и может быть выполнен без каких-либо модификаций. В то время как динамические SQL-команды формируются непосредственно во время выполнения программы:
```sql
EXECUTE format('SELECT * FROM %I WHERE age > %s', 'users', 25);
```
Эта гибкость позволяет менять различные части запроса в зависимости от условий программы, что открывает широкие возможности для создания более адаптивных и гибких приложений.

Автоматическая генерация SQL-запросов становится особенно важной в крупных системах, где администраторы или технические специалисты должны иметь возможность добавлять или модифицировать SQL-запросы без необходимости изменения кода приложения. Например, в системах отчетности можно хранить SQL-команды в специальной таблице настроек и выполнять их в зависимости от действий пользователя. Такой подход позволяет быстро адаптировать систему к новым требованиям без необходимости перекомпиляции или повторного развертывания приложения.

Динамическое добавление условий и соединений (JOIN) демонстрирует еще одну мощную возможность динамического SQL. Рассмотрим функцию, которая формирует SQL-запрос в зависимости от входных параметров:
```sql
CREATE FUNCTION get_users(min_age INT, include_address BOOLEAN) RETURNS SETOF users AS $$
DECLARE
    query TEXT;
BEGIN
    query := 'SELECT * FROM users';
    IF min_age IS NOT NULL THEN
	query := query || ' WHERE age > ' || min_age;
    END IF;
    IF include_address THEN
	query := query || ' JOIN addresses ON users.id = addresses.user_id';
    END IF;
    RETURN QUERY EXECUTE query;
END;
$$ LANGUAGE plpgsql;
```
Здесь запрос может динамически изменяться в зависимости от переданных аргументов (min_age, include_address). Это особенно полезно в ситуациях, когда невозможно заранее предсказать точную структуру запроса.

Работа с динамическими именами таблиц и столбцов представляет собой еще один важный аспект использования динамического SQL. В некоторых случаях требуется подставлять имена таблиц или столбцов непосредственно во время выполнения:
```sql
EXECUTE format('SELECT %I FROM %I', column_name, table_name);
```
Пример: если необходимо динамически обращаться к разным таблицам (users_2023, users_2024), то без динамического SQL это сделать невозможно. Такая возможность особенно ценна в системах, где данные организованы по временным периодам или другим динамическим критериям.

Генерация сложных аналитических отчетов часто требует использования динамического SQL. Например, при создании "матричных" отчетов, где структура данных меняется в зависимости от параметров, можно динамически формировать конструкции GROUP BY, PIVOT и другие. Это позволяет создавать гибкие системы отчетности, способные адаптироваться к различным требованиям пользователей.

Таким образом, динамические SQL-команды оказываются незаменимыми в следующих случаях:
1. Когда необходимо менять структуру SQL-запроса в зависимости от параметров.
2. При работе с динамическими таблицами или столбцами.
3. Для автоматизации выполнения SQL-команд.
4. При создании гибких систем отчетности.

Однако важно помнить, что динамический SQL следует использовать осознанно. В тех случаях, когда можно обойтись статическими запросами, лучше предпочесть их, так как они проще в сопровождении и менее подвержены потенциальным проблемам безопасности и производительности.

Безопасность динамических SQL-команд

Главная проблема динамического SQL - это уязвимость к SQL-инъекциям. Эта угроза возникает, когда злоумышленник может внедрить вредоносный SQL-код через пользовательский ввод. Рассмотрим пример уязвимого кода:
```sql
CREATE FUNCTION get_user_info(user_name TEXT) RETURNS SETOF users AS $$
DECLARE
    query TEXT;
BEGIN
    query := 'SELECT * FROM users WHERE name = ''' || user_name || '''';
    RETURN QUERY EXECUTE query;
END;
$$ LANGUAGE plpgsql;
```
Если передать в `user_name` значение `'Oleg' OR '1' = '1'`, фактический SQL-запрос станет таким:
```sql
SELECT * FROM users WHERE name = 'Oleg' OR '1' = '1';
```
В результате вернутся все пользователи, что может быть критично для безопасности системы. Это демонстрирует, насколько опасной может быть простая конкатенация строк при формировании SQL-запросов.

Для защиты от SQL-инъекций существует несколько эффективных методов. Первый и наиболее рекомендуемый способ - использование параметров через `USING`. Этот метод обеспечивает максимальную безопасность:
```sql
CREATE FUNCTION get_user_info(user_name TEXT) RETURNS SETOF users AS $$
DECLARE
    query TEXT;
BEGIN
    query := 'SELECT * FROM users WHERE name = $1';
    RETURN QUERY EXECUTE query USING user_name;
END;
$$ LANGUAGE plpgsql;
```
Преимущества этого подхода включают:
- Безопасность: значения подставляются отдельно от SQL-запроса, делая SQL-инъекцию невозможной.
- Производительность: PostgreSQL может кешировать план выполнения запроса.
- Читаемость: код становится более понятным и поддерживаемым.

Второй важный метод защиты - экранирование идентификаторов с помощью функции `quote_ident()`. Это особенно важно при работе с динамическими именами таблиц и столбцов:
```sql
-- Небезопасный вариант
EXECUTE 'SELECT * FROM ' || table_name;

-- Безопасный вариант
EXECUTE 'SELECT * FROM ' || quote_ident(table_name);
```
Функция `quote_ident()` работает следующим образом:
- Если `table_name = 'users'`, результат будет просто `users`.
- Если `table_name = 'users; DROP TABLE users;'`, результат станет `"users; DROP TABLE users;"`, что вызовет ошибку, но предотвратит выполнение вредоносного кода.

Для строковых значений используется функция `quote_literal()`:
```sql
-- Небезопасно
EXECUTE 'INSERT INTO logs (message) VALUES (' || log_text || ')';

-- Безопасно
EXECUTE 'INSERT INTO logs (message) VALUES (' || quote_literal(log_text) || ')';
```
Функция `quote_literal()` преобразует:
- `log_text = 'Hello'` → `VALUES ('Hello')`
- `log_text = 'Hello'); DROP TABLE logs; --'` → `VALUES ('Hello''); DROP TABLE logs; --')`

Четвертый метод защиты - использование функции `FORMAT()`, которая автоматически экранирует передаваемые параметры:
```sql
EXECUTE FORMAT('SELECT * FROM %I WHERE id = %L', table_name, user_id);
```
Где:
- `%I` (`quote_ident`) используется для имён таблиц и столбцов.
- `%L` (`quote_literal`) используется для строковых значений.

Преимущества использования `FORMAT()` включают:
- Автоматическое экранирование параметров.
- Улучшенную читаемость кода.
- Снижение риска случайного пропуска защиты.

Для наглядного сравнения различных методов защиты можно использовать следующую таблицу:

| Задача | Неправильно ❌ | Правильно ✅ |
|---|---|---|
| Передача значений в `WHERE` | Конкатенация строк | `EXECUTE ... USING` |
| Передача имен таблиц/столбцов | Простая конкатенация | `quote_ident()` или `%I` в `FORMAT()` |
| Передача строковых значений | Прямое подставление | `quote_literal()` или `%L` в `FORMAT()` |

Важно отметить, что использование `USING` является наиболее предпочтительным методом защиты, когда это возможно. Однако в случаях, когда нужно работать с именами таблиц или столбцов, следует использовать комбинацию `quote_ident()` и `quote_literal()`, либо функцию `FORMAT()`.

Основные выводы по защите динамического SQL:
1. Никогда не используйте простую конкатенацию строк в SQL-запросах.
2. Используйте `USING` для передачи параметров значений.
3. Применяйте `quote_ident()` для имен таблиц и столбцов.
4. Используйте `quote_literal()` для строковых значений.
5. Предпочитайте использование `FORMAT()` для улучшения читаемости и безопасности кода.
6. Эти меры полностью защитят от SQL-инъекций и сделают код более безопасным и поддерживаемым.

Способы выполнения динамических команд

PostgreSQL предоставляет несколько различных способов выполнения динамических SQL-команд, каждый из которых имеет свои особенности и области применения. Выбор конкретного метода зависит от контекста использования и требуемого результата.

Основным способом выполнения динамических SQL-команд является оператор `EXECUTE`. Он позволяет выполнить строку, содержащую SQL-запрос:
```sql
DO $$ 
DECLARE 
    query TEXT; 
BEGIN 
    query := 'SELECT COUNT(*) FROM users'; 
    EXECUTE query; 
END $$;
```
Здесь SQL-запрос формируется в строке `query` и передается в `EXECUTE` для выполнения. Этот метод прост и эффективен для выполнения одноразовых команд или запросов, не требующих возврата результатов.

Для безопасной передачи параметров используется расширение `EXECUTE ... USING`. Этот метод позволяет передавать параметры безопасно, предотвращая SQL-инъекции:
```sql
DO $$
DECLARE 
    user_count INT; 
BEGIN 
    EXECUTE 'SELECT COUNT(*) FROM users WHERE age > $1' INTO user_count USING 30;
    RAISE NOTICE 'Количество пользователей старше 30 лет: %', user_count;
END $$;
```
Преимущества этого подхода включают:
- Безопасность: SQL-инъекция невозможна благодаря разделению SQL-кода и параметров.
- Производительность: PostgreSQL может кешировать план выполнения запроса.
- Читаемость: код становится более понятным и поддерживаемым.

Когда необходимо проходить по строкам результата запроса, используется конструкция `FOR ... IN EXECUTE`:
```sql
DO $$
DECLARE 
    row RECORD;
BEGIN 
    FOR row IN EXECUTE 'SELECT id, name FROM users' 
    LOOP 
	RAISE NOTICE 'ID: %, Name: %', row.id, row.name;
    END LOOP;
END $$;
```
Этот метод особенно полезен:
- При переборе строк результата запроса.
- В реализации вложенных циклов в динамических процедурах.
- Для последовательной обработки больших объемов данных.

Для работы с большими наборами данных или когда результат нужно обработать позже, используется метод `OPEN CURSOR FOR EXECUTE`:
```sql
DO $$ 
DECLARE 
    cur REFCURSOR; 
BEGIN 
    OPEN cur FOR EXECUTE 'SELECT id, name FROM users'; 
	Курсор можно передавать в другие части кода и обрабатывать данные
END $$;
```
Преимущества использования курсоров:
- Возможность передачи курсора в клиентские приложения.
- Эффективное чтение больших объемов данных.
- Гибкость в управлении процессом выборки данных.

Когда функция должна возвращать результат динамического запроса, используется конструкция `RETURN QUERY EXECUTE`:
```sql
CREATE FUNCTION get_users_by_age(min_age INT) RETURNS SETOF users AS $$
BEGIN 
    RETURN QUERY EXECUTE 'SELECT * FROM users WHERE age > $1' USING min_age;
END;
$$ LANGUAGE plpgsql;
```
Этот метод особенно полезен:
- При создании API для работы с динамическими фильтрами.
- Для возвращения данных в другие процедуры и клиентские приложения.
- В реализации сложной бизнес-логики, требующей динамического формирования результатов.

Для наглядного сравнения различных способов выполнения динамических команд можно использовать следующую таблицу:

| Способ | Описание |
|---|---|
| `EXECUTE` | Просто выполняет SQL-запрос |
| `EXECUTE ... USING` | Выполняет запрос с безопасной передачей параметров |
| `FOR ... IN EXECUTE` | Позволяет перебрать строки результата запроса |
| `OPEN CURSOR FOR EXECUTE` | Открывает курсор для работы с данными |
| `RETURN QUERY EXECUTE` | Возвращает результат выполнения запроса |

Выбор конкретного метода зависит от конкретной задачи:
1. Если просто нужно выполнить команду - используйте `EXECUTE`.
2. Если требуется передавать параметры - используйте `EXECUTE ... USING`.
3. Если нужно перебрать результат запроса - используйте `FOR ... IN EXECUTE`.
4. Если необходим курсор для последующей обработки - используйте `OPEN CURSOR FOR EXECUTE`.
5. Если нужно вернуть результат из функции - используйте `RETURN QUERY EXECUTE`.

Важно отметить, что независимо от выбранного метода выполнения, необходимо всегда соблюдать меры безопасности и использовать соответствующие методы защиты от SQL-инъекций. Это особенно критично при работе с пользовательским вводом или внешними данными.

Пример SQL-инъекции и защита от неё

SQL-инъекция представляет собой серьезную уязвимость, возникающую, когда пользователь может вставить в SQL-запрос вредоносный код. Последствия такой атаки могут быть катастрофическими, включая:
- Неавторизованный доступ к данным.
- Изменение, удаление или добавление информации.
- Выполнение произвольных SQL-команд, таких как `DROP TABLE`.

Рассмотрим конкретный пример уязвимого кода:
```sql
CREATE FUNCTION get_user_info(username TEXT) RETURNS SETOF users AS $$
DECLARE
    query TEXT;
BEGIN
    query := 'SELECT * FROM users WHERE name = ''' || username || '''';
    RETURN QUERY EXECUTE query;
END;
$$ LANGUAGE plpgsql;
```
Этот код содержит критическую уязвимость из-за использования конкатенации строк (`'|| username ||'`). Злоумышленник может воспользоваться этим, передав специально сконструированное значение:
```sql
SELECT * FROM get_user_info('Oleg''; DELETE FROM users; --');
```
Фактический SQL-запрос станет таким:
```sql
SELECT * FROM users WHERE name = 'Oleg'; DELETE FROM users; --'
```
Результатом будет удаление всех данных из таблицы `users`, что может привести к катастрофическим последствиям для системы.

Для защиты от SQL-инъекций существует несколько надежных методов. Первый и наиболее рекомендуемый способ - использование `USING`:
```sql
CREATE FUNCTION get_user_info(username TEXT) RETURNS SETOF users AS $$
DECLARE
    query TEXT;
BEGIN
    query := 'SELECT * FROM users WHERE name = $1';
    RETURN QUERY EXECUTE query USING username;
END;
$$ LANGUAGE plpgsql;
```
Этот метод безопасен потому, что:
- Параметры передаются отдельно от SQL-запроса.
- PostgreSQL автоматически экранирует все специальные символы.
- План выполнения запроса может быть закэширован, что повышает производительность.

Второй метод защиты - экранирование строк с помощью функции `quote_literal()`:
```sql
CREATE FUNCTION get_user_info(username TEXT) RETURNS SETOF users AS $$
DECLARE
    query TEXT;
BEGIN
    query := 'SELECT * FROM users WHERE name = ' || quote_literal(username);
    RETURN QUERY EXECUTE query;
END;
$$ LANGUAGE plpgsql;
```
Функция `quote_literal()` работает следующим образом:
- Преобразует `Oleg` в `'Oleg'`.
- Преобразует `Oleg'; DELETE FROM users; --` в `'Oleg''; DELETE FROM users; --'`.
Таким образом, любая попытка SQL-инъекции превращается в обычную строку поиска.

Для защиты имен таблиц и столбцов используется функция `quote_ident()`:
```sql
EXECUTE 'SELECT * FROM ' || quote_ident(table_name);
```
Эта функция:
- Преобразует `users` в `users`.
- Преобразует `users; DROP TABLE users;` в `"users; DROP TABLE users;"`.
Любая попытка внедрения вредоносного кода в имя таблицы или столбца приведет к ошибке, но не к выполнению вредоносных команд.

Четвертый метод защиты - использование функции `FORMAT()`, которая объединяет преимущества предыдущих методов:
```sql
EXECUTE FORMAT('SELECT * FROM %I WHERE name = %L', table_name, username);
```
Функция `FORMAT()` работает следующим образом:
- `%I` (`quote_ident()`) защищает имена таблиц и столбцов.
- `%L` (`quote_literal()`) защищает строковые значения.
Пример преобразования:
- `FORMAT('%I', 'users')` → `users`
- `FORMAT('%L', 'Oleg')` → `'Oleg'`
- `FORMAT('%L', 'Oleg''; DROP TABLE users;')` → `'''Oleg''; DROP TABLE users;'''`

Для наглядного сравнения различных методов защиты можно использовать следующую таблицу:

| Проблема | Неправильно ❌ | Правильно ✅ |
|---|---|---|
| Передача строковых данных | Конкатенация строк | `USING` или `quote_literal()` |
| Передача имен таблиц | Простая конкатенация | `quote_ident()` или `%I` в `FORMAT()` |
| Общий метод защиты | Конкатенация строк | Комбинация методов выше |

Основные выводы по защите от SQL-инъекций:
6. Лучший вариант защиты - использовать `USING`.
7. Если использование `USING` невозможно, применять `quote_ident()`, `quote_literal()` или `FORMAT()`.
8. Никогда не использовать простую конкатенацию строк для SQL-команд.
9. Всегда применять один из безопасных методов защиты.
10. Такой подход полностью исключит возможность SQL-инъекций.

Формирование безопасных динамических команд

Правильное формирование безопасных динамических SQL-запросов требует тщательного подхода и понимания различных методов защиты. Рассмотрим подробно основные аспекты безопасного формирования динамических команд.

Подстановка имен таблиц и столбцов требует особого внимания, так как эти элементы нельзя передавать как параметры через `USING`. Для безопасной подстановки используются функции `quote_ident()` или `FORMAT('%I')`:
```sql
DO $$ 
DECLARE 
    table_name TEXT := 'users';
    query TEXT;
BEGIN 
    query := 'SELECT * FROM ' || quote_ident(table_name);
    EXECUTE query;
END $$;
```
Функция `quote_ident()` работает следующим образом:
- Преобразует `users` в `users`.
- Преобразует `users; DROP TABLE users;` в `"users; DROP TABLE users;"`.
Таким образом, любая попытка внедрения вредоносного кода в имя таблицы приведет к ошибке, но не к выполнению опасных команд.

Альтернативный способ через `FORMAT()`:
```sql
DO $$ 
DECLARE 
    table_name TEXT := 'users';
BEGIN 
    EXECUTE FORMAT('SELECT * FROM %I', table_name);
END $$;
```
Преимущества использования `FORMAT()`:
- Улучшенная читаемость кода.
- Отсутствие необходимости вручную объединять строки.
- Автоматическое экранирование имен таблиц и столбцов.

Подстановка значений в SQL-запросы должна выполняться безопасным способом. Неправильный подход с использованием конкатенации строк:
```sql
DO $$ 
DECLARE 
    user_name TEXT := 'Oleg';
    query TEXT;
BEGIN 
    query := 'SELECT * FROM users WHERE name = ''' || user_name || '''';
    EXECUTE query;
END $$;
```
Этот метод уязвим к SQL-инъекциям и должен быть заменен на безопасный вариант с использованием `USING`:
```sql
DO $$ 
DECLARE 
    user_name TEXT := 'Oleg';
BEGIN 
    EXECUTE 'SELECT * FROM users WHERE name = $1' USING user_name;
END $$;
```
Преимущества этого подхода:
- Параметры передаются отдельно от SQL-кода.
- PostgreSQL автоматически экранирует все специальные символы.
- Возможность кэширования плана выполнения запроса.

Если использование `USING` невозможно, применяется функция `quote_literal()`:
```sql
DO $$ 
DECLARE 
    user_name TEXT := 'Oleg';
    query TEXT;
BEGIN 
    query := 'SELECT * FROM users WHERE name = ' || quote_literal(user_name);
    EXECUTE query;
END $$;
```
Функция `quote_literal()` работает следующим образом:
- Преобразует `Oleg` в `'Oleg'`.
- Преобразует `Oleg'; DROP TABLE users; --` в `'Oleg''; DROP TABLE users; --'`.
Таким образом, любая попытка SQL-инъекции превращается в обычную строку поиска.

Наиболее удобным и безопасным методом является использование функции `FORMAT()`, которая объединяет все преимущества предыдущих методов:
```sql
DO $$ 
DECLARE 
    table_name TEXT := 'users';
    user_name TEXT := 'Oleg';
BEGIN 
    EXECUTE FORMAT('SELECT * FROM %I WHERE name = %L', table_name, user_name);
END $$;
```
Функция `FORMAT()` работает следующим образом:
- `%I` (`quote_ident()`) защищает имена таблиц и столбцов.
- `%L` (`quote_literal()`) защищает строковые значения.
Пример преобразования:
- `FORMAT('%I', 'users')` → `users`
- `FORMAT('%L', 'Oleg')` → `'Oleg'`
- `FORMAT('%L', 'Oleg''; DROP TABLE users;')` → `'''Oleg''; DROP TABLE users;'''`

Для наглядного сравнения различных методов формирования безопасных динамических команд можно использовать следующую таблицу:

| Задача | Неправильно ❌ | Правильно ✅ |
|---|---|---|
| Передача значений в `WHERE` | Конкатенация строк | `USING` или `quote_literal()` |
| Передача имен таблиц | Простая конкатенация | `quote_ident()` или `%I` в `FORMAT()` |
| Передача строковых значений | Прямое подставление | `quote_literal()` или `%L` в `FORMAT()` |

Основные принципы формирования безопасных динамических SQL-команд:
11. Всегда использовать `USING` для передачи параметров значений.
12. Применять `quote_ident()` для имен таблиц и столбцов.
13. Использовать `quote_literal()` для строковых значений.
14. Предпочитать использование `FORMAT()` для улучшения читаемости и безопасности кода.
15. Избегать любой формы конкатенации строк при формировании SQL-запросов.
16. Тщательно проверять все входные данные, даже если они используются в безопасном контексте.

Следуя этим принципам, можно гарантировать безопасность динамических SQL-команд и предотвратить возможность SQL-инъекций.

Практические задания

Рассмотрим две практические задачи, демонстрирующие применение динамического SQL в реальных сценариях. Первая задача связана с созданием функции каталога книг, а вторая - с формированием сложного матричного отчета.

Функция `get_catalog()` демонстрирует динамическое построение запроса с безопасной подстановкой параметров. Задача состоит в создании функции, возвращающей список книг из базы данных с учетом различных фильтров (категория, цена, автор), при этом функция должна быть защищена от SQL-инъекций.

Структура таблицы `books` выглядит следующим образом:
```sql
CREATE TABLE books (
    id SERIAL PRIMARY KEY,
    title TEXT,
    author TEXT,
    category TEXT,
    price NUMERIC
);
```
Пример уязвимой реализации показывает типичные ошибки:
```sql
CREATE FUNCTION get_catalog(category TEXT, max_price NUMERIC) RETURNS SETOF books AS $$
DECLARE
    query TEXT;
BEGIN
    query := 'SELECT * FROM books WHERE 1=1';
    IF category IS NOT NULL THEN
	query := query || ' AND category = ''' || category || '''';
    END IF;
    IF max_price IS NOT NULL THEN
	query := query || ' AND price <= ' || max_price;
    END IF;
    RETURN QUERY EXECUTE query;
END;
$$ LANGUAGE plpgsql;
```
Этот код уязвим к SQL-инъекциям из-за использования конкатенации строк. Например, передача `category = '''; DROP TABLE books; --'` приведет к удалению таблицы.

Безопасная реализация использует массив параметров и `USING`:
```sql
CREATE FUNCTION get_catalog(category TEXT, max_price NUMERIC) RETURNS SETOF books AS $$
DECLARE
    query TEXT := 'SELECT * FROM books WHERE 1=1';
    param_list TEXT[] := ARRAY[]::TEXT[];
BEGIN
    IF category IS NOT NULL THEN
	query := query || ' AND category = $' || array_length(param_list, 1) + 1;
	param_list := param_list || category;
    END IF;
    IF max_price IS NOT NULL THEN
	query := query || ' AND price <= $' || array_length(param_list, 1) + 1;
	param_list := param_list || max_price::TEXT;
    END IF;
    RETURN QUERY EXECUTE query USING unpack(param_list);
END;
$$ LANGUAGE plpgsql;
```
Этот подход гарантирует безопасность благодаря:
- Использованию `USING` для всех параметров.
- Динамическому управлению номерами параметров через массив.
- Защите от любых попыток SQL-инъекций.

Вторая задача - создание матричного отчета - демонстрирует более сложное использование динамического SQL. Задача состоит в построении отчета, где:
- Строки представляют схемы БД.
- Столбцы - пользователи, создавшие функции.
- Ячейки содержат количество функций в каждой схеме от каждого пользователя.

Пример результата:
| Схема | user1 | user2 | user3 |
|-------|-------|-------|-------|
| public | 12 | 5 | 8 |
| auth | 3 | 2 | 6 |
| logs | 7 | 9 | 4 |

Решение состоит из нескольких шагов:
17. Получение списка пользователей, создавших функции:
```sql
SELECT DISTINCT pg_proc.proowner::regrole::text 
FROM pg_proc;
```
18. Получение списка схем:
```sql
SELECT DISTINCT nspname FROM pg_namespace;
```
19. Формирование динамического SQL-запроса с использованием `crosstab()` из расширения `tablefunc`:
```sql
DO $$ 
DECLARE 
    col_list TEXT := '';
    sql_query TEXT;
BEGIN 
    SELECT string_agg(DISTINCT format('%I TEXT', proowner::regrole::text), ', ')
    INTO col_list
    FROM pg_proc;
    
    sql_query := FORMAT(
	'SELECT * FROM crosstab(
	$$SELECT nspname, proowner::regrole::text, COUNT(*) 
	FROM pg_proc 
	JOIN pg_namespace ON pg_proc.pronamespace = pg_namespace.oid 
	GROUP BY 1,2 ORDER BY 1,2$$
	) AS t (schema_name TEXT, %s);', 
	col_list
    );
    
    EXECUTE sql_query;
END $$;
```
Этот код работает следующим образом:
20. Формирует список пользователей для `crosstab`.
21. Создает динамический запрос с использованием `FORMAT()`.
22. Выполняет сформированный запрос.

Использование `crosstab()` позволяет:
- Динамически формировать столбцы отчета.
- Обрабатывать неизвестное заранее количество пользователей.
- Создавать сложные матричные отчеты.

Оба примера демонстрируют важные аспекты работы с динамическим SQL:
23. Безопасное формирование запросов с использованием `USING` и `FORMAT()`.
24. Динамическое управление параметрами и структурой запроса.
25. Обработка неизвестного заранее количества строк и столбцов.
26. Создание гибких и масштабируемых решений.

Заключение

Динамический SQL представляет собой мощный инструмент в руках разработчиков баз данных, предоставляя уникальные возможности для создания гибких и адаптивных решений. Однако его использование требует глубокого понимания как потенциальных преимуществ, так и связанных с ним рисков.

Ключевые преимущества динамического SQL включают:
27. Гибкость в формировании запросов, позволяющая адаптировать их под различные условия выполнения.
28. Возможность работы с динамически определяемыми объектами базы данных (таблицы, столбцы).
29. Поддержка сложной бизнес-логики, требующей динамического построения запросов.
30. Создание гибких систем отчетности и аналитики.

Однако использование динамического SQL сопряжено с несколькими важными вызовами:
31. Безопасность: высокий риск SQL-инъекций при неправильном формировании запросов.
32. Производительность: необходимость повторного парсинга и