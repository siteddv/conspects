## **Часть 4: Работа с курсорами в PostgreSQL**

### **1. Введение**

Курсоры в PostgreSQL позволяют **поэтапно извлекать данные из запроса**, а не загружать их все сразу. Это особенно полезно при работе с большими выборками, когда данные не помещаются в оперативную память.

В отличие от обычного `SELECT`, который сразу возвращает все строки, курсоры позволяют **получать данные частями**, что снижает нагрузку на сервер и клиент.

---

### **2. Создание курсоров**

Чтобы создать курсор, необходимо:

1. **Начать транзакцию (`BEGIN`)** – курсоры работают только внутри транзакции.
2. **Определить курсор (`DECLARE`)** – задать запрос, который будет выполняться.
3. **Извлекать данные (`FETCH`)** – получать строки из курсора.
4. **Закрыть курсор (`CLOSE`)** – освободить ресурсы.

Пример:

```sql
BEGIN;
DECLARE user_cursor CURSOR FOR
SELECT id, name FROM users;
FETCH 5 FROM user_cursor;  -- Получаем первые 5 строк
FETCH 5 FROM user_cursor;  -- Еще 5 строк
CLOSE user_cursor;
COMMIT;
```

Этот процесс позволяет **избежать загрузки всей таблицы в память**.

---

### **3. Управление курсорами**

#### **3.1 Команда `FETCH`**

Команда `FETCH` используется для получения данных из курсора.

Синтаксис:

```sql
FETCH [количество строк] FROM курсор;
```

Пример:

```sql
FETCH 10 FROM user_cursor;
```

Выбирает 10 строк.

Дополнительные параметры `FETCH`:

- `NEXT` – выбрать следующую строку (по умолчанию).
- `PRIOR` – выбрать предыдущую строку.
- `FIRST` – выбрать первую строку.
- `LAST` – выбрать последнюю строку.
- `ABSOLUTE n` – перейти к строке `n`.
- `RELATIVE n` – перейти вперед/назад на `n` строк.

Пример:

```sql
FETCH RELATIVE 3 FROM user_cursor;  -- Пропускаем 3 строки вперед
```

---

### **4. Закрытие курсоров**

Курсоры нужно **закрывать**, когда они больше не нужны, иначе они занимают память.

Синтаксис:

```sql
CLOSE курсор;
```

Пример:

```sql
CLOSE user_cursor;
```

Если курсор не закрыть, он будет автоматически закрыт при завершении транзакции.

---

### **5. Разница между курсорами и обычным `SELECT`**

|**Функция**|**Курсор**|**Обычный SELECT**|
|---|---|---|
|Количество строк|Выбирает строки **постепенно**|Выбирает все сразу|
|Использование памяти|Экономит память сервера|Может перегружать память|
|Производительность|Оптимален для больших таблиц|Хорош для небольших выборок|
|Гибкость|Позволяет **перемещаться** по результатам|Только полный результат|

Курсоры особенно полезны, если **таблица содержит миллионы строк**, а клиенту **не нужно сразу загружать все данные**.

---

### **6. Работа с `WITH HOLD` (персистентные курсоры)**

Обычные курсоры **существуют только внутри транзакции**. Если транзакция завершается (`COMMIT`), курсор исчезает.

Но PostgreSQL поддерживает **персистентные курсоры** с флагом `WITH HOLD`. Они продолжают существовать после `COMMIT`.

Пример:

```sql
BEGIN;
DECLARE user_cursor CURSOR WITH HOLD FOR
SELECT id, name FROM users;
COMMIT;
FETCH 5 FROM user_cursor;
CLOSE user_cursor;
```

**Особенность**: такие курсоры хранят данные во временных файлах на диске.

---

### **7. Итоги четвертой части**

- Курсоры позволяют **постепенно извлекать данные**, что снижает нагрузку на память.
- Используются в **транзакциях** и управляются с помощью `DECLARE`, `FETCH`, `CLOSE`.
- `WITH HOLD` позволяет сохранять курсоры **после завершения транзакции**.
- Курсоры полезны для работы с **большими таблицами**, но требуют осторожного управления.

---

### **Что дальше?**

Следующая часть будет посвящена **архитектуре PostgreSQL: процессам, памяти и их взаимодействию**. Готов продолжить?