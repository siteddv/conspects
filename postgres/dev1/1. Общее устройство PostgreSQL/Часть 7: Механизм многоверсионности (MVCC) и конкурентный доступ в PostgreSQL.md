Часть 7: Механизм многоверсионности (MVCC) и конкурентный доступ в PostgreSQL

1. Введение

PostgreSQL использует механизм MVCC (Multi-Version Concurrency Control), который позволяет нескольким транзакциям работать одновременно без блокировок чтения.

Основные принципы MVCC:

Каждая транзакция видит свою версию данных, независимо от изменений других транзакций.

Изменения не перезаписывают старые строки, а создают новые версии строк.

Старые версии остаются в таблице до очистки (VACUUM).


Этот механизм позволяет ускорить выполнение запросов, избегая долгих блокировок.


---

2. Как работает MVCC

В PostgreSQL каждая строка в таблице содержит дополнительные скрытые поля:

xmin – ID транзакции, которая создала строку.

xmax – ID транзакции, которая удалила строку (если удалена).

ctid – физический адрес строки в таблице.


Пример работы MVCC

1. Транзакция A вставляет данные:

BEGIN;
INSERT INTO users (id, name) VALUES (1, 'Alice');
COMMIT;

xmin = 100 (номер транзакции A)

xmax = NULL (строка не удалена)



2. Транзакция B обновляет строку:

BEGIN;
UPDATE users SET name = 'Alice Updated' WHERE id = 1;
COMMIT;

PostgreSQL не изменяет строку, а создает новую версию:

Старая строка: xmin = 100, xmax = 101 (заменена транзакцией 101)

Новая строка: xmin = 101, xmax = NULL





Транзакция C, запущенная до завершения транзакции B, увидит только старую версию строки.


---

3. Уровни изоляции транзакций

MVCC позволяет задавать уровень изоляции, чтобы управлять видимостью данных.

3.1 Read Committed (по умолчанию)

Транзакция видит только зафиксированные изменения.

Данные могут изменяться между запросами.


Пример:

Session 1:
BEGIN;
UPDATE products SET price = 500 WHERE id = 1;

Session 2:
SELECT price FROM products WHERE id = 1;  -- Видит старую цену

Пока Session 1 не выполнит COMMIT, вторая сессия не увидит изменений.


---

3.2 Repeatable Read

Все данные в транзакции остаются неизменными с момента ее начала.

Даже если другая транзакция обновит данные, внутри текущей сессии они не изменятся.


Пример:

Session 1:
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM accounts WHERE id = 1;  -- Видит баланс = 1000

Session 2:
UPDATE accounts SET balance = 500 WHERE id = 1;
COMMIT;

Session 1:
SELECT * FROM accounts WHERE id = 1;  -- Все еще видит баланс = 1000

Транзакция Session 1 не видит изменений, потому что работает в режиме Repeatable Read.


---

3.3 Serializable

Полная изоляция – транзакции выполняются как будто по очереди.

Если возникает конфликт (изменение тех же данных), одна из транзакций откатится (ROLLBACK).


Пример:

Session 1:
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT SUM(balance) FROM accounts;  -- Видит сумму 5000

Session 2:
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;

Session 1:
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;  -- Ошибка: "could not serialize access due to concurrent update"

PostgreSQL откатит Session 1, потому что баланс мог измениться параллельно.


---

4. Очистка старых версий строк (VACUUM)

Из-за MVCC старые версии строк не удаляются сразу, а остаются в таблице. Чтобы очистить их, PostgreSQL использует VACUUM.

4.1 Автоматическая очистка (Autovacuum)

PostgreSQL автоматически запускает VACUUM, когда в таблице накапливается много "мусора".

Процесс работает в фоновом режиме и не блокирует запросы.


Проверить статус:

SHOW autovacuum;

Настроить параметры:

SHOW autovacuum_vacuum_threshold;

4.2 Ручной запуск VACUUM

Обычная очистка:

VACUUM;

Анализ статистики таблицы:

VACUUM ANALYZE;

Полная очистка (но блокирует таблицу!):

VACUUM FULL;


---

5. Проблемы конкурентного доступа и их решения

5.1 Фантомные чтения (Phantom Reads)

Когда одна транзакция вставляет или удаляет строки, а другая видит изменения между запросами.

Решение: Serializable уровень изоляции.


5.2 Грязное чтение (Dirty Reads)

Если транзакция читает неподтвержденные изменения другой транзакции.

PostgreSQL защищен от грязного чтения: Read Uncommitted НЕ используется.


5.3 Потерянные обновления (Lost Updates)

Две транзакции одновременно обновляют одну строку, и одно изменение перезаписывает другое.

Решение: FOR UPDATE.


Пример:

BEGIN;
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;  -- Блокируем строку
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;


---

6. Итоги седьмой части

PostgreSQL использует MVCC, позволяя транзакциям работать без блокировок.

Каждая транзакция видит свою версию данных.

Старые версии строк удаляются с помощью VACUUM.

Уровни изоляции:

Read Committed – видит только зафиксированные изменения.

Repeatable Read – видит данные на момент начала транзакции.

Serializable – гарантирует отсутствие конфликтов, но может вызывать откаты (ROLLBACK).




---

Что дальше?

Следующая часть будет посвящена оптимизации работы PostgreSQL: настройке памяти, индексов, параллельному выполнению запросов. Готов продолжить?

