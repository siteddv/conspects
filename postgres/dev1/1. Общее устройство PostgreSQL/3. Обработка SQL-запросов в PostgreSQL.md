## **Часть 3: Обработка SQL-запросов в PostgreSQL**

### **1. Введение**

PostgreSQL является декларативной системой управления базами данных: мы описываем **что** мы хотим получить, а сервер сам решает **как** это сделать. Этот процесс включает разбор, оптимизацию и выполнение запроса.

Когда клиент отправляет SQL-запрос, PostgreSQL выполняет несколько шагов:

1. **Разбор (Parsing)** – проверка синтаксиса и структуры запроса.
2. **Анализ (Semantic Analysis)** – определение таблиц, колонок и прав доступа.
3. **Оптимизация (Planning)** – выбор наилучшего способа выполнения запроса.
4. **Исполнение (Execution)** – получение и возврат данных клиенту.

Каждый этап играет важную роль в производительности запросов.

---

### **2. Разбор запроса (Parsing)**

Когда клиент отправляет SQL-запрос, PostgreSQL сначала проверяет его синтаксис.

Этапы разбора:

- **Лексический анализ** – разделение SQL-запроса на отдельные токены (ключевые слова, идентификаторы, операторы).
- **Синтаксический анализ** – проверка структуры запроса (правильность написания).
- **Семантический анализ** – проверка существования таблиц, колонок, привилегий.

Пример разбора запроса:

```sql
SELECT name FROM users WHERE age > 18;
```

- PostgreSQL сначала **разбирает** его на ключевые слова (`SELECT`, `FROM`, `WHERE`).
- Затем он проверяет, **существует ли таблица `users`** и колонка `age`.
- Если ошибок нет, запрос передается дальше на обработку.

Ошибки на этом этапе:

- **Синтаксическая ошибка** (`SELECTT * FROM users;`) – неверное ключевое слово.
- **Семантическая ошибка** (`SELECT unknown_column FROM users;`) – нет такой колонки.

---

### **3. Оптимизация запроса (Query Planning)**

После разбора PostgreSQL ищет **наилучший способ выполнения** запроса. Для этого используется **планировщик запросов (Query Planner)**.

**Что делает планировщик?**

1. Анализирует **статистику данных** (сколько строк в таблице, индексы, селективность условий).
2. Выбирает наилучший способ чтения данных (`Seq Scan`, `Index Scan` и т. д.).
3. Оптимизирует порядок соединений таблиц (`JOIN Order`).
4. Выбирает алгоритм выполнения (Nested Loop, Hash Join и др.).

Пример анализа запроса:

```sql
EXPLAIN ANALYZE SELECT * FROM users WHERE age > 30;
```

Вывод может быть таким:

```
Seq Scan on users  (cost=0.00..100.00 rows=100 width=20)
```

Это означает, что PostgreSQL выбрал **последовательное сканирование (Seq Scan)**, так как нет индекса.

**Типы сканирования:**

- **Sequential Scan (Seq Scan)** – последовательное чтение всей таблицы.
- **Index Scan** – поиск через индекс (если есть индекс).
- **Bitmap Index Scan** – комбинация нескольких индексов.
- **Parallel Seq Scan** – параллельное чтение таблицы.

---

### **4. Выполнение запроса (Execution)**

После выбора оптимального плана сервер выполняет запрос.

Процесс выполнения:

1. **Чтение данных из таблицы или индекса.**
2. **Фильтрация строк по условиям (`WHERE`).**
3. **Сортировка (`ORDER BY`).**
4. **Агрегация (`GROUP BY`).**
5. **Соединение таблиц (`JOIN`).**
6. **Возврат данных клиенту.**

Пример запроса:

```sql
SELECT name FROM users WHERE age > 25 ORDER BY name;
```

PostgreSQL:

1. Сканирует таблицу `users` (или использует индекс).
2. Отбирает строки с `age > 25`.
3. Сортирует их по `name`.
4. Возвращает клиенту.

---

### **5. Подготовленные операторы (Prepared Statements)**

Чтобы не разбирать один и тот же запрос несколько раз, можно использовать **подготовленные операторы**.

Пример:

```sql
PREPARE user_query (int) AS
SELECT name FROM users WHERE age > $1;
```

Теперь запрос **разбирается и оптимизируется один раз**, а затем используется с разными параметрами:

```sql
EXECUTE user_query(30);
```

Преимущества:

- **Быстрее, чем обычные запросы**, так как экономится время на разборе.
- **Меньшая нагрузка на сервер.**
- **Улучшенная безопасность (защита от SQL-инъекций).**

Некоторые драйверы (например, `psycopg2` в Python) автоматически используют подготовленные запросы.

---

### **6. Итоги третьей части**

- PostgreSQL проходит **4 этапа обработки запроса**: разбор, анализ, планирование, выполнение.
- **Планировщик запросов** выбирает наилучший способ выполнения запроса.
- Разные **методы сканирования** данных (Seq Scan, Index Scan, Hash Join и др.).
- Использование **`EXPLAIN ANALYZE`** помогает анализировать производительность.
- **Подготовленные операторы** (`PREPARE`) ускоряют выполнение повторяющихся запросов.

---

### **Что дальше?**

Следующая часть будет посвящена **работе с курсорами**, их преимуществам и влиянию на производительность. Готов продолжить?