## **Часть 5: Архитектура PostgreSQL: процессы и память**

### **1. Введение**

PostgreSQL — это **многопроцессная система**, в отличие от некоторых других СУБД, использующих многопоточный подход. Взаимодействие между процессами играет ключевую роль в обработке запросов, управлении памятью и обеспечении конкурентного доступа.

Основные элементы архитектуры:

- **Процессы PostgreSQL** – управление соединениями и фоновыми задачами.
- **Память PostgreSQL** – буферный кэш, локальная и общая память.
- **Файловая система** – хранение данных на диске.

Эта часть разберет устройство серверной стороны PostgreSQL.

---

### **2. Процессы в PostgreSQL**

Когда PostgreSQL запускается, он создает **главный процесс (postmaster)**, который управляет всеми остальными процессами.

Основные типы процессов:

- **Postmaster** – главный процесс сервера, управляет запуском других процессов.
- **Background Writer** – процесс фоновой записи, сбрасывает измененные данные на диск.
- **WAL Writer** – записывает изменения в **журнал транзакций (WAL)**.
- **Checkpointer** – периодически сбрасывает данные из буфера в файлы.
- **Autovacuum** – автоматически очищает старые версии строк для экономии места.
- **Client Backend** – создается для каждого подключенного клиента.

Пример структуры процессов:

```
Postmaster (главный процесс)
 ├── Background Writer
 ├── WAL Writer
 ├── Checkpointer
 ├── Autovacuum
 ├── Клиентские процессы (Backend)
```

---

### **3. Как работает клиентское подключение**

Когда клиент подключается к PostgreSQL:

1. **Postmaster** принимает запрос на подключение.
2. Создается **новый процесс Client Backend** для обработки запросов.
3. Клиент отправляет SQL-запросы, а серверные процессы выполняют их и возвращают результат.

Пример работы:

```sql
SELECT * FROM orders WHERE amount > 100;
```

- Клиент отправляет запрос.
- **Client Backend** разбирает, оптимизирует и выполняет запрос.
- Данные извлекаются из буфера или считываются с диска.
- Результат передается клиенту.

Важно! **Каждое соединение создаёт отдельный процесс.** Если одновременно подключены 1000 клиентов, PostgreSQL создаст 1000 процессов, что может привести к перегрузке.

---

### **4. Управление памятью в PostgreSQL**

PostgreSQL использует несколько уровней памяти:

4. **Локальная память процесса** – хранит временные данные конкретного запроса.
5. **Общая память сервера** – используется всеми процессами для кеширования данных.
6. **Буферный кэш (Shared Buffers)** – основной кэш данных.
7. **Операционная система (Page Cache)** – ОС также кэширует дисковые данные.

|**Компонент**|**Описание**|
|---|---|
|**Work Mem**|Память для сортировок и хеш-таблиц|
|**Shared Buffers**|Основной кэш данных PostgreSQL|
|**WAL Buffers**|Кэш журнала транзакций|
|**Temp Buffers**|Временные буферы для запросов|

Пример настройки:

```sql
SHOW shared_buffers;
```

Обычно **shared_buffers** составляет 25-40% от объема оперативной памяти.

---

### **5. Как PostgreSQL работает с диском**

PostgreSQL хранит данные в **файлах на диске**. При выполнении запроса он:

8. Проверяет, есть ли данные в буфере (`shared_buffers`).
9. Если данных нет, загружает их с диска.
10. После изменения данные **сначала пишутся в буфер**, затем сбрасываются в файлы.

#### **Файловая структура PostgreSQL**

|**Компонент**|**Описание**|
|---|---|
|`base/`|Таблицы базы данных|
|`pg_wal/`|Журнал транзакций (WAL)|
|`pg_stat/`|Статистика базы|
|`pg_tblspc/`|Табличные пространства|

Пример расположения файлов:

```
/var/lib/postgresql/15/main/base/12345/
 ├── 16384 (таблица users)
 ├── 16384_fsm (карта свободных страниц)
 ├── 16384_vm (карта видимости)
```

---

### **6. Буферный пул и кэширование**

PostgreSQL использует **Shared Buffers** для хранения часто запрашиваемых данных.

Как это работает:

11. Клиент запрашивает данные (`SELECT * FROM orders`).
12. PostgreSQL сначала **ищет их в буфере** (`shared_buffers`).
13. Если данных нет, загружает с диска и кеширует в буфере.

Это **ускоряет повторные запросы**, снижая нагрузку на диск.

Пример:

```sql
EXPLAIN ANALYZE SELECT * FROM orders;
```

Если в отчете `EXPLAIN` указано **"Shared Hit"**, значит, данные взяты из кеша.

---

### **7. WAL (Write-Ahead Logging)**

PostgreSQL использует **журнал транзакций (WAL)**, чтобы гарантировать надежность данных.

При изменении данных:

14. PostgreSQL сначала **записывает изменения в WAL** (`pg_wal`).
15. Затем измененные данные **обновляются в буфере**.
16. Только после этого **сбрасываются на диск**.

Это гарантирует, что при сбое системы данные не потеряются.

Пример просмотра WAL-файлов:

```bash
ls -lh /var/lib/postgresql/15/main/pg_wal/
```

---

### **8. Ограничения многопроцессной архитектуры**

17. **Большое количество подключений → высокая нагрузка.**
    
    - Каждое подключение создает **отдельный процесс**.
    - Решение: использовать **пул соединений (PgBouncer)**.
18. **Высокая нагрузка на память.**
    
    - Каждое соединение использует ресурсы.
    - Решение: увеличивать `work_mem`, `shared_buffers`, `effective_cache_size`.
19. **Операционная система кэширует файлы.**
    
    - PostgreSQL использует **Page Cache** ОС.
    - Иногда это приводит к задержкам при выгрузке старых страниц.

---

### **9. Итоги пятой части**

- PostgreSQL – **многопроцессная** СУБД: каждое подключение – отдельный процесс.
- Основные фоновые процессы: **Postmaster, WAL Writer, Checkpointer, Autovacuum**.
- PostgreSQL активно использует **буферный кэш** (`shared_buffers`), снижая нагрузку на диск.
- Данные сначала записываются в **WAL (журнал транзакций)**, затем сбрасываются в файлы.
- **Много подключений = высокая нагрузка.** Используйте **PgBouncer** для оптимизации.

---

### **Что дальше?**

Следующая часть будет посвящена **хранению данных в PostgreSQL, файловой системе и механизму журналирования (WAL)**. Готов продолжить?