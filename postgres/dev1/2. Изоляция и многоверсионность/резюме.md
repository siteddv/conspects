### Конспект по работе транзакций, изоляции и очистке данных в PostgreSQL

PostgreSQL — это мощная реляционная СУБД, которая использует уникальные механизмы для обеспечения согласованности данных при параллельной работе нескольких транзакций. В этом конспекте мы подробно разберем, как работает многоверсионность (MVCC), как устроены транзакции, уровни изоляции, блокировки и процессы очистки данных.

---

### **1. Проблема параллельного доступа к данным**

Когда несколько транзакций работают с одной и той же базой данных, возникают ситуации, которые могут привести к несогласованности данных. Например:
- Две транзакции читают одну и ту же строку.
- Одна транзакция читает строку, а другая пытается её изменить.
- Обе транзакции пытаются изменить одну и ту же строку.

Если такие ситуации не контролировать, могут возникнуть конфликты обновлений или чтение некорректных данных. Для решения этой проблемы существуют два простых подхода:
1. **Полная блокировка**: Первая транзакция блокирует строку, пока не завершится, что гарантирует согласованность, но снижает производительность.
2. **Разрешение чтения незавершенных изменений**: Читающая транзакция видит изменения, сделанные другой транзакцией, даже если они ещё не зафиксированы. Это увеличивает производительность, но может привести к чтению несогласованных данных.

Оба этих подхода имеют недостатки, поэтому PostgreSQL использует более сложный механизм — **многоверсионность (MVCC)**.

---

### **2. Как работает MVCC**

#### **Принцип хранения нескольких версий строк**
В отличие от традиционных СУБД, которые перезаписывают данные в одной и той же строке, PostgreSQL хранит несколько версий одной строки. Это позволяет транзакциям:
- Читать данные без блокировки.
- Видеть разные версии строки в зависимости от момента начала транзакции.
- Гарантировать согласованность данных без потери производительности.

**Как это работает:**
- При выполнении `INSERT` создается новая строка с уникальным номером транзакции.
- При выполнении `UPDATE` PostgreSQL создает новую версию строки, а старая остается в истории.
- При выполнении `DELETE` строка не удаляется сразу, а становится невидимой для новых транзакций.

Таким образом, вместо перезаписи данных система просто создает новые версии строк, что минимизирует конфликты и блокировки.

#### **Метаданные строк: `xmin` и `xmax`**
Каждая версия строки в PostgreSQL хранит два специальных параметра:
- **`xmin`**: Номер транзакции, которая создала эту версию строки.
- **`xmax`**: Номер транзакции, которая сделала строку невидимой (например, обновила или удалила её).

Пример:
| id | data  | xmin | xmax |
|----|-------|------|------|
| 1  | "A"   | 100  | 102  |
| 1  | "B"   | 102  | 0    |

- Строка `"A"` была создана транзакцией **100**, а стала недоступной после выполнения транзакции **102**.
- Строка `"B"` была создана транзакцией **102** и пока ещё актуальна (`xmax = 0`).

Таким образом, каждая транзакция может «видеть» только те версии строк, `xmin` и `xmax` которых соответствуют правилам видимости.

#### **Как работает обновление строк (`UPDATE`)**
В PostgreSQL операция `UPDATE` фактически является комбинацией `DELETE + INSERT`. Когда транзакция выполняет `UPDATE`, она создаёт новую версию строки, а старая версия остаётся в истории, но становится невидимой для новых транзакций.

Пример:
1. Изначально в таблице есть строка:
   ```
   id | name  | xmin | xmax
   ----+-------+------+------
   1  | "Alex" | 100  | 0
   ```

2. Транзакция 102 выполняет `UPDATE` и изменяет имя:
   - Создается новая версия строки.
   - Старая версия остается, но становится невидимой.
   ```
   id | name  | xmin | xmax
   ----+-------+------+------
   1  | "Alex" | 100  | 102  -- старая версия строки
   1  | "Alice" | 102  | 0    -- новая версия строки
   ```

3. После завершения транзакции (`COMMIT`) новые транзакции будут видеть только строку `"Alice"`, а `"Alex"` исчезнет.

#### **Как работает удаление (`DELETE`)**
Операция `DELETE` не уничтожает строку сразу, а просто делает её невидимой для будущих транзакций, изменяя `xmax`.

Пример:
4. Транзакция 200 выполняет `DELETE`:
   ```
   id | name  | xmin | xmax
   ----+-------+------+------
   1  | "Alice" | 102  | 200  -- строка удалена
   ```

5. Теперь эта строка не видна для новых транзакций, но физически она всё ещё существует в таблице. Только после очистки (`VACUUM`) такие строки полностью удаляются из базы.

---

### **3. Снимки данных и согласованность**

Чтобы обеспечить согласованность данных, PostgreSQL использует механизм **снимков данных (Snapshot)**. Это логический срез базы данных на момент начала транзакции.

#### **Как строится снимок данных**
Снимок данных создается при начале транзакции и состоит из трёх элементов:
6. Номер текущей транзакции (`txid`), которая запросила снимок.
7. Список активных транзакций, которые начались, но ещё не завершились.
8. Диапазон видимых `xmin` и `xmax` — какие версии строк будут видны этой транзакции.

При построении снимка система отбрасывает невидимые версии строк, используя `xmin` и `xmax`.

#### **Пример работы снимка данных**
Допустим, в таблице есть следующие версии строк:
| id | data  | xmin | xmax |
|----|-------|------|------|
| 1  | "A"   | 100  | 150  |
| 1  | "B"   | 150  | 200  |
| 1  | "C"   | 200  | 0    |

- Если новая транзакция началась после 150, но до 200, то она увидит строку `"B"`.
- Если транзакция началась после 200, она увидит строку `"C"`, а `"B"` уже не существует для неё.
- Если транзакция началась до 150, она увидит `"A"`, так как `"B"` ещё не существовала в тот момент.

---

### **4. Уровни изоляции транзакций**

Стандарт SQL определяет четыре уровня изоляции:
9. **Read Uncommitted**: Минимальная изоляция. Возможны грязное чтение, фантомные строки и неповторяющееся чтение.
10. **Read Committed** (по умолчанию): Видны только зафиксированные данные. Возможны фантомные строки и неповторяющееся чтение.
11. **Repeatable Read**: Все `SELECT` в рамках одной транзакции видят один и тот же снимок данных. Возможны фантомные строки.
12. **Serializable**: Полная изоляция. Транзакции выполняются так, будто они идут по очереди. Никаких аномалий.

#### **Примеры работы уровней изоляции**
- **Read Committed**: Каждое чтение использует новый снимок данных, поэтому два одинаковых `SELECT` могут дать разные результаты.
- **Repeatable Read**: Фиксирует снимок данных на момент начала транзакции, поэтому результаты `SELECT` всегда одинаковы.
- **Serializable**: Предотвращает любые конфликты, но может приводить к откатам (`ROLLBACK`).

---

### **5. Блокировки и их влияние на производительность**

#### **Типы блокировок**
PostgreSQL использует разные уровни блокировок:
- **Row-Level Lock**: Блокирует только изменяемые строки (`UPDATE`, `DELETE`, `SELECT ... FOR UPDATE`).
- **Table-Level Lock**: Блокирует всю таблицу (`ALTER TABLE`, `VACUUM FULL`).
- **Exclusive Lock**: Полный эксклюзивный доступ (`DROP TABLE`, `TRUNCATE`).

#### **Как MVCC снижает блокировки**
PostgreSQL использует MVCC, чтобы чтение (`SELECT`) не блокировало других пользователей. Даже если кто-то обновляет данные (`UPDATE`), другие пользователи могут продолжать чтение, так как система возвращает старую версию строки из снимка данных.

---

### **6. Очистка старых версий данных (VACUUM)**

#### **Почему таблицы со временем увеличиваются**
Из-за механизма MVCC старые версии строк остаются в файле таблицы, даже если они больше не нужны. Это приводит к разрастанию таблиц.

#### **Как работает VACUUM**
Процесс `VACUUM`:
13. Находит старые версии строк, которые больше не видны ни одной транзакции.
14. Помечает их как свободное место.
15. Обновляет служебную информацию о транзакциях.

Команда для ручного запуска:
```sql
VACUUM;
```

#### **Разница между VACUUM и VACUUM FULL**
- **VACUUM**: Удаляет старые версии строк, освобождая место внутри таблицы, но не уменьшает размер файла.
- **VACUUM FULL**: Полностью пересоздает таблицу, уменьшая её размер, но блокирует её.

#### **Автоматическая очистка (autovacuum)**
PostgreSQL имеет встроенный процесс автоматической очистки (`autovacuum`), который работает в фоновом режиме и сам выполняет `VACUUM`.

---

### **Заключение**

PostgreSQL использует мощные механизмы, такие как MVCC, уровни изоляции и автоматическую очистку данных, чтобы обеспечить высокую производительность и согласованность данных. Эти механизмы позволяют системе эффективно работать в условиях параллельного доступа к данным и предотвращать конфликты.