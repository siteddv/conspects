Пересказ четвертой логической части: Уровни изоляции транзакций в PostgreSQL

1. Что такое уровни изоляции и зачем они нужны?

Когда в базе данных работают несколько параллельных транзакций, они могут влиять друг на друга. Уровни изоляции определяют:

Какие изменения одна транзакция может видеть от других незавершенных транзакций.

Как сильно параллельные транзакции могут влиять на результат друг друга.

Баланс между согласованностью данных и производительностью.


Чем строже уровень изоляции, тем меньше влияния оказывают параллельные транзакции друг на друга. Но это увеличивает нагрузку на систему.

2. Четыре уровня изоляции в SQL-стандарте

Стандарт SQL определяет четыре уровня изоляции:


---

Разбор каждого уровня изоляции

1. Read Uncommitted (Чтение незавершенных данных)

Транзакция может читать данные, которые еще не были зафиксированы (COMMIT).

Возможна ситуация, когда одна транзакция читает грязные данные, которые потом могут быть отменены (ROLLBACK).

В PostgreSQL этот уровень изоляции не используется, так как даже Read Committed предотвращает грязное чтение.


Аномалии:
✅ Грязное чтение (Dirty Read) – транзакция читает данные, которые могут быть отменены.


---

2. Read Committed (Чтение зафиксированных данных) – уровень по умолчанию

Транзакция видит только те изменения, которые были зафиксированы (COMMIT) другими транзакциями.

Однако снимок данных обновляется при каждом новом SQL-запросе, поэтому два одинаковых SELECT могут дать разные результаты.


Пример:

1. Транзакция TX1 выполняет:

BEGIN;
SELECT * FROM orders WHERE id = 1;

Она видит версию "A".



2. Параллельная транзакция TX2 выполняет UPDATE и COMMIT:

UPDATE orders SET status = 'shipped' WHERE id = 1;
COMMIT;


3. Транзакция TX1 снова выполняет:

SELECT * FROM orders WHERE id = 1;

Теперь она видит "shipped".




Аномалии:
✅ Неповторяющееся чтение (Non-Repeatable Read) – два одинаковых запроса в одной транзакции могут дать разные результаты.


---

3. Repeatable Read (Повторяемое чтение)

Все SELECT в рамках одной транзакции видят один и тот же снимок данных.

Даже если параллельная транзакция UPDATE или INSERT, транзакция не увидит эти изменения до своего завершения (COMMIT).


Пример:

1. Транзакция TX1 выполняет:

BEGIN;
SELECT * FROM products WHERE id = 1;

Она видит "цена = 100".



2. Параллельная транзакция TX2 изменяет цену и коммитит:

UPDATE products SET price = 150 WHERE id = 1;
COMMIT;


3. Транзакция TX1 снова выполняет тот же SELECT:

Она по-прежнему видит "цена = 100", а не "150", потому что снимок данных не меняется в рамках одной транзакции.




Аномалии:
✅ Фантомные строки (Phantom Read) – если одна транзакция вставляет новые строки, другая их может не увидеть.


---

4. Serializable (Полная изоляция транзакций)

Максимальная защита от всех аномалий.

Работает так, будто все транзакции выполняются строго последовательно, а не параллельно.

Если две транзакции пытаются обновить одни и те же данные, одна из них может быть отклонена (ROLLBACK) и должна быть повторена.


Пример:

1. Две транзакции TX1 и TX2 выполняют:

UPDATE accounts SET balance = balance - 100 WHERE id = 1;


2. Если обе транзакции выполняются параллельно, то одна из них может быть отменена, чтобы избежать некорректных результатов.



Аномалии:
❌ Никаких аномалий.


---

5. Какой уровень изоляции использовать?


---

Вывод

PostgreSQL поддерживает четыре уровня изоляции, но по умолчанию используется Read Committed.

Чем выше уровень изоляции, тем больше защита от аномалий, но ниже производительность.

Для критически важных операций (финансовые платежи, банковские переводы) используйте Serializable, но для большинства задач хватает Read Committed или Repeatable Read.



---

Продолжать пересказ? В следующей части мы разберем конкретные примеры работы с транзакциями в PostgreSQL – как BEGIN, COMMIT, ROLLBACK влияют на данные, а также посмотрим влияние уровней изоляции на блокировки.

 