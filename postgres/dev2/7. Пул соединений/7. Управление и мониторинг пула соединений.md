### **Седьмая логическая часть: Практические задания и примеры**

#### **1. Задание 1: Корзина покупок**
**Проблема:**
- При использовании пула соединений разные пользователи видят одну и ту же корзину.
- Например:
  - Пользователь A добавляет товар в корзину.
  - Пользователь B заходит в приложение и видит товары, добавленные пользователем A.

**Причина проблемы:**
- Корзина покупок реализована с использованием временных таблиц или переменных сеанса.
- Эти данные сохраняются на уровне сеанса, но пул соединений переиспользует соединения между разными пользователями.
- В результате данные одного пользователя становятся доступны другому.

**Решение:**
- Избегать использования временных таблиц или переменных сеанса для хранения данных корзины.
- Использовать постоянные таблицы с уникальным идентификатором пользователя (например, `user_id`) для хранения данных корзины.
- Пример структуры таблицы:
  ```sql
  CREATE TABLE shopping_cart (
      user_id INT,
      product_id INT,
      quantity INT,
      PRIMARY KEY (user_id, product_id)
  );
  ```
- При добавлении товара в корзину использовать `user_id` для фильтрации данных:
  ```sql
  INSERT INTO shopping_cart (user_id, product_id, quantity)
  VALUES (123, 456, 1)
  ON CONFLICT (user_id, product_id) DO UPDATE SET quantity = shopping_cart.quantity + 1;
  ```

---

#### **2. Задание 2: Трассировка действий пользователя**
**Задача:**
- Написать функции `web_trace` и `emp_trace`, которые позволят трассировать действия конкретного пользователя приложения.

**Описание проблемы:**
- Если включить трассировку на уровне сеанса PostgreSQL, в журнал попадают запросы всех пользователей, которые используют одно и то же соединение через пул.
- Это делает трассировку бесполезной, так как невозможно отличить действия одного пользователя от другого.

**Решение:**
- Реализовать трассировку на уровне приложения с использованием уникального идентификатора пользователя.
- Пример реализации функций:

1. **Функция `web_trace`:**
   ```sql
   CREATE OR REPLACE FUNCTION web_trace(user_id INT, action TEXT)
   RETURNS VOID AS $$
   BEGIN
       INSERT INTO user_actions (user_id, action, timestamp)
       VALUES (user_id, action, NOW());
   END;
   $$ LANGUAGE plpgsql;
   ```

2. **Функция `emp_trace`:**
   ```sql
   CREATE OR REPLACE FUNCTION emp_trace(employee_id INT, action TEXT)
   RETURNS VOID AS $$
   BEGIN
       INSERT INTO employee_actions (employee_id, action, timestamp)
       VALUES (employee_id, action, NOW());
   END;
   $$ LANGUAGE plpgsql;
   ```

3. **Таблицы для хранения действий:**
   ```sql
   CREATE TABLE user_actions (
       id SERIAL PRIMARY KEY,
       user_id INT,
       action TEXT,
       timestamp TIMESTAMP
   );

   CREATE TABLE employee_actions (
       id SERIAL PRIMARY KEY,
       employee_id INT,
       action TEXT,
       timestamp TIMESTAMP
   );
   ```

4. **Использование функций:**
   - При выполнении каждого действия вызывать соответствующую функцию:
     ```sql
     SELECT web_trace(123, 'Добавление товара в корзину');
     SELECT emp_trace(456, 'Обновление заказа');
     ```

---

#### **3. Задание 3: Рекомендательные блокировки**
**Проблема:**
- Рекомендательные блокировки (`pg_advisory_lock`) работают на уровне сеанса.
- Если клиент переключается на другое соединение через пул, блокировка теряется.

**Воспроизведение проблемы:**
1. Подключитесь к базе данных через пул соединений.
2. Выполните команду для установки рекомендательной блокировки:
   ```sql
   SELECT pg_advisory_lock(123);
   ```
3. Откройте новое соединение через тот же пул.
4. Попробуйте проверить наличие блокировки:
   ```sql
   SELECT pg_try_advisory_lock(123);
   ```
5. Результат: Блокировка не существует, так как используется другое соединение.

**Решение:**
- Использовать рекомендательные блокировки только внутри одной транзакции.
- Если требуется синхронизация между транзакциями, использовать альтернативные механизмы, например:
  - Таблицы с флагами.
  - Специальные механизмы синхронизации на уровне приложения.

---

#### **4. Задание 4: Проблема с подготовленными операторами**
**Проблема:**
- Подготовленные операторы хранятся в памяти обслуживающего процесса.
- Если клиент переключается на другое соединение через пул, подготовленный оператор становится недоступным.

**Воспроизведение проблемы:**
6. Подготовьте оператор:
   ```sql
   PREPARE x AS SELECT * FROM products WHERE id = $1;
   ```
7. Выполните оператор:
   ```sql
   EXECUTE x(456);
   ```
8. Откройте новое соединение через тот же пул.
9. Попробуйте выполнить оператор:
   ```sql
   EXECUTE x(456);
   ```
10. Результат: Ошибка, так как оператор не существует в новом соединении.

**Решение:**
- Избегать явного использования подготовленных операторов.
- Использовать автоматическую подготовку операторов на стороне драйвера базы данных (например, в JDBC или psycopg2).

---

#### **5. Заключение по практическим заданиям**
Практические задания помогают закрепить понимание особенностей работы с пулом соединений. Они демонстрируют, как правильно адаптировать приложение для корректной работы с пулом, избегая распространённых проблем:
- Разделение данных между пользователями.
- Трассировка действий конкретного пользователя.
- Обработка рекомендательных блокировок и подготовленных операторов.

Если у вас есть дополнительные вопросы или вы хотите обсудить конкретные аспекты выполнения заданий, дайте знать!