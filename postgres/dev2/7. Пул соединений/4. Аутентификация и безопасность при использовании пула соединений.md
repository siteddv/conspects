### **Четвертая логическая часть: Особенности разработки приложений с использованием пула соединений**

#### **1. Проблемы, возникающие при использовании пула соединений**
При использовании пула соединений важно учитывать, что сеансы работы клиентов могут быть распределены между несколькими обслуживающими процессами PostgreSQL. Это вызывает проблемы с функционалом, который зависит от состояния сеанса или транзакции. Рассмотрим основные категории таких проблем:

---

#### **2. Подготовленные операторы (Prepared Statements)**
- **Что это такое?**
  - Подготовленный оператор — это SQL-запрос, который предварительно компилируется и сохраняется в памяти обслуживающего процесса PostgreSQL.
  - После подготовки оператор можно многократно выполнять с разными параметрами, что повышает производительность.

- **Проблема:**
  - Подготовленный оператор хранится в памяти конкретного обслуживающего процесса. Если клиентский запрос перенаправляется в другое соединение через пул, то подготовленный оператор становится недоступным.
  - Например:
    1. Клиент A подготавливает оператор в одном соединении.
    2. При следующем запросе пул перенаправляет клиента A в другое соединение.
    3. В новом соединении подготовленный оператор отсутствует, что приводит к ошибке.

- **Пример из видео:**
  - Клиент A подготавливает оператор `PREPARE x AS SELECT ...`.
  - Второй клиент B пытается выполнить этот оператор через пул соединений.
  - Если оба клиента используют одно и то же соединение, оператор будет доступен. Однако если клиент A начинает новую транзакцию, пул перенаправляет его в другое соединение, где оператор уже не существует.

- **Решение:**
  - Избегать явного использования подготовленных операторов.
  - Использовать автоматическую подготовку операторов на стороне драйвера базы данных (например, в JDBC или psycopg2).
  - Настроить пул соединений так, чтобы он очищал состояние после каждой транзакции (параметр `server_reset_query`).

---

#### **3. Временные таблицы**
- **Что это такое?**
  - Временные таблицы создаются для хранения данных, которые существуют только в рамках текущего сеанса или транзакции.

- **Проблема:**
  - Если временная таблица создается на уровне сеанса, она становится недоступной при переключении на другое соединение через пул.
  - Например:
    1. Клиент A создает временную таблицу.
    2. Пул перенаправляет клиента A в другое соединение.
    3. Во втором соединении временная таблица отсутствует.

- **Исключение:**
  - Временные таблицы, созданные с предложением `ON COMMIT DROP`, уничтожаются сразу после завершения транзакции. Такие таблицы работают корректно с пулом соединений.

- **Решение:**
  - Использовать временные таблицы только внутри одной транзакции.
  - Если требуется хранение данных между транзакциями, использовать постоянные таблицы или другие механизмы.

---

#### **4. Функции `CURRVAL` и `NEXTVAL`**
- **Что это такое?**
  - Функции `CURRVAL` и `NEXTVAL` используются для работы с последовательностями (sequences). Они позволяют получать текущее значение последовательности или увеличивать его.

- **Проблема:**
  - Значение последовательности хранится в памяти обслуживающего процесса. Если клиент переключается на другое соединение, значение последовательности может быть потеряно или изменено.

- **Решение:**
  - Минимизировать использование последовательностей в приложении.
  - Если использование последовательностей необходимо, убедиться, что они вызываются в рамках одной транзакции.

---

#### **5. Параметры сеанса**
- **Что это такое?**
  - Параметры сеанса (например, `SET search_path`, `SET timezone`) устанавливаются на время работы сеанса и влияют на выполнение запросов.

- **Проблема:**
  - Если клиент переключается на другое соединение через пул, параметры сеанса теряются.

- **Решение:**
  - Устанавливать параметры сеанса в начале каждой транзакции.
  - Настроить пул соединений так, чтобы он автоматически сбрасывал параметры после каждой транзакции (параметр `server_reset_query`).

---

#### **6. Рекомендательные блокировки**
- **Что это такое?**
  - Рекомендательные блокировки (`pg_advisory_lock`) используются для синхронизации процессов на уровне приложения.

- **Проблема:**
  - Блокировки хранятся в памяти обслуживающего процесса. Если клиент переключается на другое соединение, блокировка теряется.

- **Решение:**
  - Использовать рекомендательные блокировки только внутри одной транзакции.
  - Если требуется синхронизация между транзакциями, использовать альтернативные механизмы (например, таблицы с флагами).

---

#### **7. Курсоры**
- **Что это такое?**
  - Курсоры используются для построчной обработки больших наборов данных.

- **Проблема:**
  - Курсоры хранятся в памяти обслуживающего процесса. Если клиент переключается на другое соединение, курсор теряется.

- **Решение:**
  - Использовать курсоры только внутри одной транзакции.
  - Если требуется работа с большими наборами данных, использовать другие методы (например, пакетную обработку).

---

#### **8. Расширения и переменные сеанса**
- **Что это такое?**
  - Некоторые расширения PostgreSQL (например, `pg_stat_statements`) или пользовательские переменные сеанса могут сохранять данные на уровне сеанса.

- **Проблема:**
  - Эти данные теряются при переключении на другое соединение через пул.

- **Решение:**
  - Избегать использования расширений и переменных, зависящих от состояния сеанса.
  - Если использование необходимо, настроить пул соединений так, чтобы он очищал состояние после каждой транзакции.

---

#### **9. Практические задания**
В видео предложены несколько практических заданий для закрепления материала:

1. **Задание 1: Корзина покупок**
   - Проблема: Разные пользователи видят одну и ту же корзину при использовании пула соединений.
   - Задача: Выяснить причину проблемы и исправить её.

2. **Задание 2: Трассировка действий пользователя**
   - Задача: Написать функции `web_trace` и `emp_trace`, которые позволят трассировать действия конкретного пользователя приложения.

3. **Задание 3: Рекомендательные блокировки**
   - Задача: Воспроизвести проблему с рекомендательными блокировками и подготовленными операторами.

---

#### **10. Заключение по четвертой части**
Использование пула соединений требует внимательного подхода к разработке приложений. Необходимо учитывать, что состояние сеанса может быть потеряно при переключении на другое соединение. Чтобы избежать проблем:
- Избегать использования функционала, зависящего от состояния сеанса.
- Настроить пул соединений так, чтобы он очищал состояние после каждой транзакции.
- Тестировать приложение на корректность работы с пулом соединений.

В следующей части мы рассмотрим управление и мониторинг пула соединений. Если вы хотите продолжить, дайте знать!