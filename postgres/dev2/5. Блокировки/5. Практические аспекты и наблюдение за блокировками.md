### Часть 5: Практические аспекты и наблюдение за блокировками

#### Анализ блокировок через `pg_locks`
`pg_locks` — это системное представление в PostgreSQL, которое предоставляет информацию о текущих блокировках в системе. Оно является основным инструментом для диагностики проблем с блокировками.

- **Структура `pg_locks`**:
  - `locktype`: Тип блокировки (например, `relation`, `tuple`, `transactionid`).
  - `database`: Идентификатор базы данных.
  - `relation`: Идентификатор таблицы или индекса.
  - `page`, `tuple`: Номер страницы и строки (для блокировок строк).
  - `virtualxid`, `transactionid`: Номера транзакций.
  - `mode`: Режим блокировки (например, `AccessShareLock`, `RowExclusiveLock`).
  - `granted`: Флаг, указывающий, была ли блокировка успешно получена (`true` или `false`).

##### Пример запроса к `pg_locks`:
```sql
SELECT locktype, relation::regclass, mode, granted
FROM pg_locks
WHERE pid = pg_backend_pid();
```
- Этот запрос показывает все блокировки, удерживаемые текущим процессом.

##### Интерпретация результатов:
- Если `granted = true`: Блокировка успешно получена.
- Если `granted = false`: Процесс ожидает освобождения блокировки.

#### Наблюдение за активностью процессов
Для анализа активности процессов используется представление `pg_stat_activity`. Оно позволяет отслеживать текущие запросы, их состояние и возможные блокировки.

- **Полезные поля**:
  - `pid`: Идентификатор процесса.
  - `query`: Текущий выполняемый запрос.
  - `state`: Состояние процесса (например, `active`, `idle in transaction`).
  - `wait_event_type`, `wait_event`: Тип и причина ожидания (например, `Lock`, `relation`).

##### Пример запроса:
```sql
SELECT pid, query, state, wait_event_type, wait_event
FROM pg_stat_activity
WHERE wait_event_type = 'Lock';
```
- Этот запрос показывает процессы, которые ожидают освобождения блокировки.

#### Практические упражнения с блокировками
Для лучшего понимания работы блокировок рекомендуется выполнить несколько практических упражнений:

1. **Чтение строки с использованием первичного ключа**:
   - Задание: Определите, какие блокировки создаются при чтении строки с использованием первичного ключа.
   - Проверка: Выполните запрос `SELECT ... WHERE id = 1` и проанализируйте `pg_locks`.

2. **Рекомендательные блокировки**:
   - Задание: Исследуйте, как работают рекомендательные блокировки (`pg_advisory_lock`).
   - Проверка: Используйте функции `pg_advisory_lock` и `pg_advisory_unlock` для управления пользовательскими блокировками.

3. **Проверка внешних ключей**:
   - Задание: Убедитесь, что проверка внешних ключей и обновление неключевых полей могут выполняться одновременно.
   - Проверка: Создайте две транзакции, одна из которых проверяет внешний ключ, а другая обновляет неключевые поля.

4. **Взаимная блокировка**:
   - Задание: Воспроизведите ситуацию взаимной блокировки между двумя транзакциями.
   - Проверка: Создайте две транзакции, каждая из которых удерживает ресурс, необходимый другой транзакции.

##### Пример взаимной блокировки:
1. Транзакция A:
   ```sql
   BEGIN;
   UPDATE accounts SET amount = amount + 100 WHERE id = 1;
   ```
2. Транзакция B:
   ```sql
   BEGIN;
   UPDATE accounts SET amount = amount - 50 WHERE id = 2;
   ```
3. Транзакция A пытается обновить строку с `id = 2`:
   ```sql
   UPDATE accounts SET amount = amount + 100 WHERE id = 2;
   ```
4. Транзакция B пытается обновить строку с `id = 1`:
   ```sql
   UPDATE accounts SET amount = amount - 50 WHERE id = 1;
   ```

- Результат: Обе транзакции будут ждать освобождения блокировок, что приведет к взаимной блокировке.

#### Задания для самостоятельной работы
1. **Анализ блокировок строк**:
   - Используйте расширение `pgrowlocks` для анализа блокировок строк.
   - Пример:
     ```sql
     SELECT * FROM pgrowlocks('accounts');
     ```

2. **Исследование очередей ожидания**:
   - Создайте несколько транзакций, пытающихся изменить одну и ту же строку.
   - Проанализируйте очередь ожидания через `pg_locks` и `pg_stat_activity`.

3. **Оптимизация горячих точек**:
   - Исследуйте, как часто обновляется конкретная строка в таблице.
   - Предложите способы оптимизации, чтобы избежать "горячих точек".

---

### Ключевые моменты для Obsidian:

#### Анализ блокировок через `pg_locks`
- **Типы блокировок**: `relation`, `tuple`, `transactionid`.
- **Полезные поля**: `locktype`, `relation`, `mode`, `granted`.
- **Пример запроса**: Анализ текущих блокировок.

#### Наблюдение за активностью процессов
- **Представление `pg_stat_activity`**: Отслеживание состояния процессов.
- **Полезные поля**: `pid`, `query`, `state`, `wait_event_type`, `wait_event`.

#### Практические упражнения
- **Чтение строки**: Анализ блокировок при чтении.
- **Рекомендательные блокировки**: Использование `pg_advisory_lock`.
- **Проверка внешних ключей**: Совместимость операций.
- **Взаимная блокировка**: Воспроизведение и анализ.

#### Задания для самостоятельной работы
- **Анализ блокировок строк**: Использование `pgrowlocks`.
- **Исследование очередей**: Анализ очередей через `pg_locks`.
- **Оптимизация горячих точек**: Поиск и устранение проблем.

#### Важные термины
- **`pg_locks`**: Представление для анализа блокировок.
- **`pg_stat_activity`**: Представление для отслеживания активности процессов.
- **Рекомендательные блокировки**: Пользовательские блокировки.
- **Горячие точки**: Часто обновляемые строки.

---

Это завершает пятую часть конспекта. Хотите перейти к следующей части или завершить?