### Часть 3: Уровни изоляции транзакций

#### Обзор уровней изоляции
Уровни изоляции определяют, насколько строго транзакции изолированы друг от друга. Чем выше уровень изоляции, тем меньше вероятность возникновения аномалий, но тем больше накладные расходы на блокировки и управление параллелизмом. Рассмотрим каждый уровень более подробно.

---

#### 1. **Read Uncommitted**  
Это самый слабый уровень изоляции. На этом уровне транзакция может видеть **незафиксированные изменения**, сделанные другими транзакциями. Это называется **грязное чтение**.

- **Проблема грязного чтения**:  
  Представьте, что одна транзакция изменила данные, но ещё не зафиксировала их (commit). Другая транзакция читает эти незафиксированные данные и принимает решения на их основе. Если первая транзакция откатывается (rollback), то вторая транзакция основывалась на данных, которых никогда не существовало.

- **Почему это опасно?**  
  Если транзакция видит незафиксированные изменения, она может принимать неверные решения. Например, если вы работаете с банковскими счетами, вы можете увидеть сумму, которая была временно списана, но затем возвращена из-за ошибки.

- **Особенности реализации в PostgreSQL**:  
  В PostgreSQL уровень `Read Uncommitted` фактически работает так же, как `Read Committed`. То есть даже если вы явно установите этот уровень, PostgreSQL всё равно не позволит вам видеть незафиксированные изменения.

---

#### 2. **Read Committed**  
Это уровень изоляции по умолчанию в PostgreSQL. На этом уровне транзакция **не может видеть незафиксированные изменения** других транзакций.

- **Что это значит?**  
  Если одна транзакция изменила данные, но ещё не зафиксировала их, другая транзакция не увидит эти изменения. Она будет работать с данными, которые были зафиксированы до начала её выполнения.

- **Аномалия: Неповторяющееся чтение**  
  На этом уровне возможна ситуация, когда одна и та же строка возвращает разные значения при повторном чтении внутри одной транзакции. Это происходит потому, что между двумя запросами другая транзакция могла изменить данные и зафиксировать их.

- **Пример**:  
  Предположим, у нас есть таблица `lights` с состоянием светофора:
  - Первая транзакция читает состояние красной лампы (она выключена).
  - Вторая транзакция включает красную лампу и фиксирует изменения.
  - Первая транзакция снова читает состояние красной лампы и видит, что она теперь включена.

  Таким образом, результаты запросов внутри одной транзакции могут быть несогласованными.

- **Рекомендации**:  
  На уровне `Read Committed` нельзя полагаться на результаты предыдущих запросов внутри транзакции. Каждый новый запрос может видеть уже зафиксированные изменения, сделанные другими транзакциями.

---

#### 3. **Repeatable Read**  
На этом уровне транзакция гарантирует, что одна и та же строка всегда возвращается с одинаковыми значениями при повторном чтении внутри одной транзакции. Это предотвращает **неповторяющееся чтение**.

- **Как это работает?**  
  Когда транзакция начинается, она "фиксирует" состояние базы данных на момент её начала. Все последующие запросы внутри этой транзакции будут видеть данные, которые существовали на момент начала транзакции, даже если другие транзакции внесли изменения и зафиксировали их.

- **Фантомное чтение**:  
  Хотя `Repeatable Read` предотвращает неповторяющееся чтение, он **не предотвращает фантомное чтение**. Это означает, что между двумя запросами могут появиться новые строки, которые удовлетворяют условию запроса.

- **Пример фантомного чтения**:  
  - Первая транзакция выполняет запрос, чтобы найти все выключенные лампы (например, красная и зелёная).
  - Вторая транзакция добавляет новую строку — жёлтую лампу, которая также выключена.
  - Первая транзакция повторяет запрос и видит новую строку (жёлтую лампу).

  Это называется **фантомным чтением**, и оно допускается на уровне `Repeatable Read`.

- **Особенности реализации в PostgreSQL**:  
  В PostgreSQL уровень `Repeatable Read` также предотвращает фантомное чтение, что делает его более строгим, чем требует стандарт SQL.

---

#### 4. **Serializable**  
Это самый строгий уровень изоляции. На этом уровне транзакции выполняются так, как будто они происходят последовательно, одна за другой, без какой-либо параллельности.

- **Что это значит?**  
  Все транзакции видят данные в том состоянии, в котором они находились на момент начала транзакции. Никакие изменения, сделанные другими транзакциями, не влияют на текущую транзакцию.

- **Конфликты сериализации**:  
  Если две транзакции пытаются изменить одни и те же данные одновременно, одна из них завершится с ошибкой сериализации. В этом случае транзакцию нужно повторить.

- **Пример**:  
  - Первая транзакция пытается включить все выключенные лампы.
  - Вторая транзакция пытается выключить все включённые лампы.
  - Если обе транзакции выполняются одновременно, PostgreSQL может не суметь выстроить их выполнение в правильном порядке. В результате одна из транзакций завершится с ошибкой сериализации.

- **Особенности использования**:  
  На уровне `Serializable` нельзя использовать реплики для записи данных, так как реплики предназначены только для чтения. Однако это нормально, так как на репликах используется уровень `Repeatable Read`.

---

#### Сравнение уровней изоляции
| Уровень изоляции      | Грязное чтение | Неповторяющееся чтение | Фантомное чтение | Потерянные обновления |
|-----------------------|---------------|------------------------|------------------|----------------------|
| **Read Uncommitted**  | Да            | Да                     | Да               | Да                   |
| **Read Committed**    | Нет           | Да                     | Да               | Да                   |
| **Repeatable Read**   | Нет           | Нет                    | Да (в стандарте)  | Нет                  |
| **Serializable**      | Нет           | Нет                    | Нет              | Нет                  |

---

#### Особые случаи и рекомендации
1. **Потерянные обновления**:  
   На уровне `Read Committed` возможны потерянные обновления, если транзакция разбивает операцию обновления на два шага: сначала чтение, затем обновление. Чтобы избежать этого, используйте уровень `Repeatable Read` или выше.

2. **Функции в PostgreSQL**:  
   Если функция имеет категорию изменчивости `VOLATILE`, она может видеть изменения, произведённые другими транзакциями, даже если сама транзакция работает на уровне `Read Committed`. Чтобы избежать этого, измените категорию изменчивости функции на `STABLE` или `IMMUTABLE`.

3. **Конфликты сериализации**:  
   На уровне `Serializable` транзакции могут завершаться с ошибкой сериализации, если невозможно выстроить их выполнение в правильном порядке. В этом случае транзакцию нужно повторить.

---

Это завершает третью часть конспекта. Хотите перейти к четвёртой части — "Демонстрация работы уровней изоляции"?