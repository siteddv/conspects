### Часть 6: Практические задания и выводы

#### Практические задания

##### Задание 1: Эксперименты с уровнями изоляции
Цель этого задания — убедиться, что на уровне `Read Committed`, который используется по умолчанию в PostgreSQL, **фантомное чтение** не предотвращается. Это означает, что новые строки, которые появляются после начала выполнения запроса, будут видны.

###### Пример:
1. **Транзакция 1**: Начинаем транзакцию с уровнем `Read Committed` и выполняем запрос, чтобы найти все выключенные лампы.
   ```sql
   BEGIN ISOLATION LEVEL READ COMMITTED;
   SELECT * FROM lights WHERE state = 'off';
   ```

2. **Транзакция 2**: Добавляем новую строку — жёлтую лампу, которая также выключена.
   ```sql
   INSERT INTO lights (lamp, state) VALUES ('yellow', 'off');
   COMMIT;
   ```

3. **Транзакция 1**: Повторно выполняем тот же запрос.
   ```sql
   SELECT * FROM lights WHERE state = 'off';
   ```

   - Результат: В первой транзакции мы увидим новую строку (жёлтую лампу), которая была добавлена второй транзакцией.

Это демонстрирует, что на уровне `Read Committed` фантомное чтение **не предотвращается**.

---

##### Задание 2: Изменение функций и видимость изменений
В этом задании предлагается проверить, как транзакция с уровнем изоляции `Read Committed` видит изменения, сделанные с функциями, которые хранятся в системном каталоге PostgreSQL.

###### Теория:
- Определения функций хранятся в системной таблице `pg_proc`.
- Если одна транзакция вызывает функцию, а другая транзакция изменяет её текст, то первая транзакция должна увидеть изменения после их фиксации.

###### Пример:
4. **Транзакция 1**: Вызываем функцию.
   ```sql
   BEGIN ISOLATION LEVEL READ COMMITTED;
   SELECT get_light_state('red'); -- Предположим, функция возвращает текущее состояние красной лампы.
   ```

5. **Транзакция 2**: Изменяем текст функции.
   ```sql
   CREATE OR REPLACE FUNCTION get_light_state(lamp_name TEXT) RETURNS TEXT AS $$
   BEGIN
       RETURN 'modified';
   END;
   $$ LANGUAGE plpgsql;
   COMMIT;
   ```

6. **Транзакция 1**: Снова вызываем функцию.
   ```sql
   SELECT get_light_state('red');
   ```

   - Результат: Первая транзакция увидит изменённый текст функции, так как уровень `Read Committed` позволяет видеть зафиксированные изменения.

---

##### Задание 3: Момент видимости изменений
Цель этого задания — понять, в какой момент транзакция начинает видеть зафиксированные изменения состояния базы данных.

###### Пример:
7. **Транзакция 1**: Открываем транзакцию, но не выполняем никаких команд.
   ```sql
   BEGIN ISOLATION LEVEL REPEATABLE READ;
   ```

8. **Транзакция 2**: Добавляем новую строку в таблицу.
   ```sql
   INSERT INTO lights (lamp, state) VALUES ('yellow', 'off');
   COMMIT;
   ```

9. **Транзакция 1**: Выполняем первый запрос.
   ```sql
   SELECT * FROM lights;
   ```

   - Результат: На уровне `Repeatable Read` первая транзакция **не увидит** новую строку, так как она "фиксирует" состояние базы данных на момент начала выполнения.

---

#### Выводы

10. **Уровни изоляции и их особенности**:
   - На уровне `Read Committed` возможны фантомные чтения, так как транзакция видит зафиксированные изменения между запросами.
   - На уровне `Repeatable Read` фантомное чтение предотвращается, даже если стандарт SQL допускает его.
   - На уровне `Serializable` достигается полная изоляция, но возможны ошибки сериализации.

11. **Функции и видимость изменений**:
   - Функции с категорией `VOLATILE` могут видеть изменения, произведённые другими транзакциями, даже на уровне `Read Committed`.
   - Для предотвращения этого можно изменить категорию изменчивости функции на `STABLE` или `IMMUTABLE`.

12. **Потерянные обновления**:
   - На уровне `Read Committed` возможны потерянные обновления, если операция разбивается на чтение и запись.
   - Чтобы избежать этого, используйте уровень `Repeatable Read` или выше.

13. **Конфликты сериализации**:
   - На уровне `Serializable` транзакции могут завершаться с ошибкой сериализации, если невозможно выстроить их выполнение в правильном порядке.
   - В этом случае транзакцию нужно повторить.

---

#### Заключение
Изучение уровней изоляции транзакций в PostgreSQL помогает понять, как управлять параллелизмом и предотвращать аномалии. Каждый уровень изоляции имеет свои преимущества и ограничения, и выбор уровня зависит от требований приложения.

Хотите вернуться к какой-либо части конспекта или есть вопросы?