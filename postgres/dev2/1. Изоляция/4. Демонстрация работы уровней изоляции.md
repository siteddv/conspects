### Часть 4: Демонстрация работы уровней изоляции

#### Практические примеры с таблицей светофоров
В этой части мы рассмотрим, как работают различные уровни изоляции на практике. Для демонстрации используется таблица `lights`, которая представляет собой пешеходный светофор с двумя лампами: красной и зелёной. Каждая лампа может быть либо включена (`on`), либо выключена (`off`). Мы будем наблюдать, как транзакции взаимодействуют с этими данными на разных уровнях изоляции.

---

#### 1. **Read Committed**  
На этом уровне транзакция не может видеть незафиксированные изменения других транзакций. Однако она может видеть зафиксированные изменения между запросами внутри одной транзакции.

##### Пример: Изменение состояния лампы
- **Транзакция 1**: Выключаем красную лампу.
  ```sql
  BEGIN;
  UPDATE lights SET state = 'off' WHERE lamp = 'red';
  -- Транзакция остаётся открыта (не фиксируется).
  ```

- **Транзакция 2**: Пытаемся прочитать состояние красной лампы.
  ```sql
  BEGIN ISOLATION LEVEL READ COMMITTED;
  SELECT * FROM lights WHERE lamp = 'red';
  ```

  - Результат: Вторая транзакция **не видит** изменений, сделанных первой транзакцией, пока они не зафиксированы.
  
- После выполнения `COMMIT` в первой транзакции:
  ```sql
  COMMIT;
  ```

  - Теперь вторая транзакция видит, что красная лампа выключена.

##### Аномалия: Неповторяющееся чтение
- Если первая транзакция зафиксирует изменения, а вторая транзакция повторно выполнит тот же запрос, она увидит разные результаты:
  ```sql
  SELECT * FROM lights WHERE lamp = 'red'; -- Первый запрос: лампа включена.
  -- Первая транзакция фиксирует изменения.
  SELECT * FROM lights WHERE lamp = 'red'; -- Второй запрос: лампа выключена.
  ```

  Это называется **неповторяющимся чтением**, и оно допускается на уровне `Read Committed`.

---

#### 2. **Repeatable Read**  
На этом уровне транзакция гарантирует, что одна и та же строка всегда возвращается с одинаковыми значениями при повторном чтении внутри одной транзакции.

##### Пример: Изменение состояния лампы
- **Транзакция 1**: Включаем красную лампу.
  ```sql
  BEGIN ISOLATION LEVEL REPEATABLE READ;
  SELECT * FROM lights WHERE lamp = 'red'; -- Лампа выключена.
  ```

- **Транзакция 2**: Включаем красную лампу и фиксируем изменения.
  ```sql
  BEGIN;
  UPDATE lights SET state = 'on' WHERE lamp = 'red';
  COMMIT;
  ```

- **Транзакция 1**: Повторно читаем состояние красной лампы.
  ```sql
  SELECT * FROM lights WHERE lamp = 'red'; -- Лампа всё ещё выключена.
  ```

  На уровне `Repeatable Read` первая транзакция видит данные в том состоянии, в котором они были на момент начала её выполнения.

##### Фантомное чтение
- Если между запросами появляются новые строки, которые удовлетворяют условию запроса, они могут быть видны на уровне `Repeatable Read`.
- **Пример**: Добавление жёлтой лампы.
  ```sql
  INSERT INTO lights (lamp, state) VALUES ('yellow', 'off');
  ```

  Однако в PostgreSQL уровень `Repeatable Read` также предотвращает фантомное чтение, что делает его более строгим, чем требует стандарт SQL.

---

#### 3. **Serializable**  
Это самый строгий уровень изоляции, который гарантирует полную изоляцию транзакций.

##### Пример: Конфликт сериализации
- **Транзакция 1**: Включает все выключенные лампы.
  ```sql
  BEGIN ISOLATION LEVEL SERIALIZABLE;
  UPDATE lights SET state = 'on' WHERE state = 'off';
  ```

- **Транзакция 2**: Выключает все включённые лампы.
  ```sql
  BEGIN ISOLATION LEVEL SERIALIZABLE;
  UPDATE lights SET state = 'off' WHERE state = 'on';
  ```

- Если обе транзакции попытаются зафиксировать изменения:
  ```sql
  COMMIT; -- Одна из транзакций завершится с ошибкой сериализации.
  ```

  Это происходит потому, что невозможно выстроить их выполнение в правильном порядке без конфликта.

---

#### Особые случаи и нюансы реализации

##### 1. **Работа с функциями**
- Если функция имеет категорию изменчивости `VOLATILE`, она может видеть изменения, произведённые другими транзакциями, даже если сама транзакция работает на уровне `Read Committed`.
- Чтобы избежать этого, измените категорию изменчивости функции на `STABLE` или `IMMUTABLE`.

##### 2. **Потерянные обновления**
- На уровне `Read Committed` возможны потерянные обновления, если транзакция разбивает операцию обновления на два шага:
  1. Чтение данных.
  2. Обновление данных.

  Чтобы избежать этого, используйте уровень `Repeatable Read` или выше.

##### 3. **Фантомное чтение**
- На уровне `Repeatable Read` в PostgreSQL фантомное чтение предотвращается, хотя стандарт SQL допускает его.

##### 4. **Конфликты сериализации**
- На уровне `Serializable` транзакции могут завершаться с ошибкой сериализации, если невозможно выстроить их выполнение в правильном порядке. В этом случае транзакцию нужно повторить.

---

#### Заключение
Уровни изоляции определяют, насколько строго транзакции изолированы друг от друга. Чем выше уровень изоляции, тем меньше вероятность возникновения аномалий, но тем больше накладные расходы на блокировки и управление параллелизмом. PostgreSQL предоставляет несколько уровней изоляции, каждый из которых имеет свои особенности и ограничения.

Хотите перейти к пятой части — "Особые случаи и нюансы"?