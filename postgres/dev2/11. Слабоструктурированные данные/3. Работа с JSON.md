### Часть 3: Работа с JSON

#### 3.1 Основы формата JSON
JSON (JavaScript Object Notation) — это легковесный формат обмена данными, основанный на JavaScript. Он представляет собой набор пар ключ-значение и массивы, что делает его более простым и удобным для чтения человеком по сравнению с XML.

Основные характеристики:
- **Объекты**: Заключены в фигурные скобки `{}`.
- **Массивы**: Заключены в квадратные скобки `[]`.
- **Ключи и значения**: Ключи всегда строки, значения могут быть строками, числами, логическими значениями, массивами или другими объектами.

Пример JSON-документа:
```json
{
  "computer": {
    "motherboard": {
      "ram": [
        {"size": 8, "type": "DDR4"},
        {"size": 16, "type": "DDR4"}
      ]
    },
    "disks": [
      {"model": "Toshiba", "size": 500},
      {"model": "Seagate", "size": 1000}
    ]
  }
}
```

#### 3.2 JSONB и его особенности
PostgreSQL поддерживает два типа данных для работы с JSON:
- **JSON**: Хранит данные как текстовую строку. При каждом запросе данные разбираются заново.
- **JSONB**: Хранит данные в бинарном формате с внутренней структурой. Это позволяет быстрее выполнять запросы и поддерживать индексирование.

Особенности JSONB:
- **Эффективность**: Разбор происходит один раз при записи.
- **Форматирование**: Исходное форматирование теряется (например, порядок ключей может измениться).
- **Индексация**: Поддерживает индексирование через GIN (Generalized Inverted Index).

#### 3.3 Языки запросов и функции
Для работы с JSON в PostgreSQL используются следующие инструменты:
- **JSONPath**: Стандартизированный язык запросов, похожий на XPath.
- **Стрелочная нотация**: Удобна для простых запросов.
- **Функции**: `jsonb_pretty()`, `jsonb_array_elements()`, `jsonb_each()` и другие.

Примеры запросов:

##### Пример 1: Выбор элементов
Запрос для выбора всех элементов RAM:
```sql
SELECT jsonb_path_query(data, '$.computer.motherboard.ram[*]');
```
Результат:
```json
[{"size": 8, "type": "DDR4"}, {"size": 16, "type": "DDR4"}]
```

##### Пример 2: Фильтрация по значению
Запрос для выбора дисков с размером больше 500:
```sql
SELECT jsonb_path_query(data, '$.computer.disks[?(@.size > 500)]');
```
Результат:
```json
[{"model": "Seagate", "size": 1000}]
```

##### Пример 3: Преобразование в реляционные данные
Функция `jsonb_to_recordset()` позволяет преобразовать JSONB в таблицу:
```sql
SELECT *
FROM jsonb_to_recordset(data->'computer'->'disks')
AS disks(model TEXT, size INT);
```
Результат:
| model   | size |
|---------|------|
| Toshiba | 500  |
| Seagate | 1000 |

#### 3.4 Преобразование между JSON и реляционными данными
##### JSON → Реляционные данные
Используется функция `jsonb_to_recordset()` для разбора JSONB и преобразования его в строки таблицы.

##### Реляционные данные → JSON
Используется функция `jsonb_build_object()` для создания JSONB из таблиц:
```sql
SELECT jsonb_build_object('model', model, 'size', size)
FROM disks;
```

#### 3.5 Практические применения
- **Хранение сложных данных**: JSONB удобен для хранения данных с переменной структурой.
- **Транспортный формат**: Используется для обмена данными между системами.
- **Локализация**: Хранение переводов интерфейса в JSONB.

---

Это третья часть конспекта, посвященная работе с JSON. Если вы хотите продолжить со следующей частью (индексирование JSON), дайте знать!