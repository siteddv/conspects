### Часть 4: Индексирование JSON

#### 4.1 Методы индексирования JSON
Для ускорения работы с JSON-документами в PostgreSQL используются специализированные методы индексирования. Основной метод — это **GIN (Generalized Inverted Index)**, который позволяет индексировать части JSON-документа.

##### Особенности GIN:
- **Обратный индекс**: Аналог предметного указателя в книгах. Каждая часть документа (ключ или значение) связана с документом, где она встречается.
- **Оптимизация для повторяющихся значений**: В отличие от B-дерева, GIN эффективен для данных, где одни и те же значения встречаются во многих документах.

#### 4.2 Типы операторных классов
Для JSONB поддерживаются два основных класса операторов:

1. **`jsonb_ops`**:
   - **Описание**: Индексирует все ключи и значения JSONB-документа.
   - **Преимущества**: Универсален, поддерживает множество операций.
   - **Недостатки**: Менее точен, так как индексирует все возможные вхождения, что может привести к ложным срабатываниям.

2. **`jsonb_path_ops`**:
   - **Описание**: Индексирует не только значения, но и пути к ним.
   - **Преимущества**: Более точный поиск, так как учитывает контекст (путь) значения.
   - **Недостатки**: Поддерживает меньшее количество операций по сравнению с `jsonb_ops`.

#### 4.3 Сравнение производительности
Рассмотрим пример таблицы с 100,000 записей о дисках, где информация хранится в формате JSONB.

##### Пример 1: Поиск без индекса
Запрос для поиска дисков с ёмкостью 10 ГБ:
```sql
SELECT COUNT(*)
FROM disks
WHERE data @> '{"capacity": 10}';
```
Результат:
- Время выполнения: ~35 мс.
- Полное сканирование таблицы.

##### Пример 2: Индекс `jsonb_ops`
Создание индекса:
```sql
CREATE INDEX idx_disks_jsonb_ops ON disks USING GIN (data);
```
Повторный запрос:
```sql
SELECT COUNT(*)
FROM disks
WHERE data @> '{"capacity": 10}';
```
Результат:
- Время выполнения: ~8 мс.
- Использование индекса с последующей перепроверкой.

##### Пример 3: Индекс `jsonb_path_ops`
Создание индекса:
```sql
CREATE INDEX idx_disks_jsonb_path_ops ON disks USING GIN (data jsonb_path_ops);
```
Повторный запрос:
```sql
SELECT COUNT(*)
FROM disks
WHERE data @> '{"capacity": 10}';
```
Результат:
- Время выполнения: <1 мс.
- Точный поиск благодаря учету пути.

#### 4.4 Практические примеры
##### Пример 1: Создание индекса по выражению
Иногда требуется индексировать конкретные поля JSONB:
```sql
CREATE INDEX idx_disks_capacity ON disks ((data->>'capacity')::INT);
```
Запрос:
```sql
SELECT COUNT(*)
FROM disks
WHERE (data->>'capacity')::INT = 10;
```

##### Пример 2: Размеры индексов
Сравнение размеров индексов:
- Таблица: 13 МБ.
- B-дерево: 32 МБ.
- `jsonb_ops`: 22 МБ.
- `jsonb_path_ops`: Наименьший размер (~15 МБ).

#### 4.5 Рекомендации
- **Точность**: Если важна точность поиска, используйте `jsonb_path_ops`.
- **Универсальность**: Для универсальных запросов подходит `jsonb_ops`.
- **Производительность**: При необходимости индексируйте конкретные поля через B-дерево.

---

Это четвертая часть конспекта, посвященная индексированию JSON. Если вы хотите продолжить с практическим применением, дайте знать!