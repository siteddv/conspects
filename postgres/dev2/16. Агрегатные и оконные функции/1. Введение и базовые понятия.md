### Часть 1: Введение и базовые понятия (0:00 - 6:00)

#### Введение
- **Приветствие и тема**: Автор начинает с приветствия и введения в тему, которая посвящена созданию собственных агрегатных и оконных функций.
- **Цель**: Показать, как работают эти функции изнутри, и научить создавать их самостоятельно. Также будет рассмотрен механизм параллельной обработки.

#### Основные определения агрегатных функций
- **Что такое агрегатные функции**:
  - Агрегатные функции — это стандартные функции, такие как `COUNT`, `MIN`, `MAX` и другие, которые используются для выполнения вычислений на множестве строк и возвращают одно значение.
  - Эти функции "схлопывают" множество строк в одну, то есть результатом является единственное значение.

#### Механизм работы агрегатных функций
- **Состояние**: Для работы агрегатной функции необходимо определить состояние, которое будет хранить промежуточные данные. Это состояние может быть значением произвольного типа.
- **Начальное состояние**: Перед началом обработки устанавливается начальное состояние.
- **Функция перехода**: Для каждой строки из выборки вызывается специальная функция перехода, которая изменяет текущее состояние. Эта функция принимает текущее состояние и значение из строки, а затем возвращает новое состояние.
- **Функция финализации**: После обработки всех строк вызывается функция финализации, которая преобразует последнее состояние в окончательный результат.

#### Пример: Создание функции для вычисления среднего значения
- **Таблица для примера**: Создается таблица с числами и дополнительным полем для группировки.
  ```sql
  CREATE TABLE test(numbers INT, group_field CHAR);
  INSERT INTO test VALUES (1, 'a'), (2, 'a'), (3, 'b'), (4, 'b'), (5, 'b');
  ```
- **Состояние**: Для вычисления среднего значения требуется два числа: сумма всех чисел и их количество.
  ```sql
  CREATE TYPE avg_state AS (accumulator INT, count INT);
  ```
- **Функция перехода**: Функция `avg_transition` принимает текущее состояние и значение из строки, добавляет значение к аккумулятору и увеличивает счетчик.
  ```sql
  CREATE OR REPLACE FUNCTION avg_transition(avg_state, INT) RETURNS avg_state AS $$
  BEGIN
      RETURN (state.accumulator + value, state.count + 1);
  END;
  $$ LANGUAGE plpgsql;
  ```
- **Функция финализации**: Функция `avg_final` вычисляет среднее значение, деля сумму на количество. Если количество равно нулю, возвращается `NULL`.
  ```sql
  CREATE OR REPLACE FUNCTION avg_final(avg_state) RETURNS FLOAT AS $$
  BEGIN
      IF state.count > 0 THEN
          RETURN state.accumulator::FLOAT / state.count;
      ELSE
          RETURN NULL;
      END IF;
  END;
  $$ LANGUAGE plpgsql;
  ```

#### Создание пользовательской агрегатной функции
- **Команда создания агрегата**: Используется команда `CREATE AGGREGATE` для объединения всех компонентов.
  ```sql
  CREATE AGGREGATE my_avg(INT) (
      SFUNC = avg_transition,
      STYPE = avg_state,
      INITCOND = '(0, 0)',
      FINALFUNC = avg_final
  );
  ```
- **Проверка работы функции**: Выполняется запрос для проверки работы новой функции.
  ```sql
  SELECT my_avg(numbers) FROM test;
  ```
  Результат: среднее значение всех чисел равно 3.

#### Группировка данных
- **Группировка**: Функция работает аналогично стандартным агрегатным функциям при использовании `GROUP BY`. Для каждой группы создается отдельное состояние.
  ```sql
  SELECT group_field, my_avg(numbers) FROM test GROUP BY group_field;
  ```
  Результат:
  - Группа 'a': среднее значение = 1.5
  - Группа 'b': среднее значение = 4

---

Это завершает первую часть конспекта. Хотите перейти ко второй части?