### Часть 5: Практическое применение полнотекстового поиска

#### Пример использования в книжном магазине
Теперь, когда мы рассмотрели основные принципы работы и настройки полнотекстового поиска, давайте перейдем к практическому примеру его применения. Предположим, что у нас есть **книжный магазин**, и мы хотим внедрить функционал поиска, который позволит пользователям находить книги по различным параметрам, таким как название, имя автора и аннотация.

1. **Задача**:
   - У нас есть база данных книг, где каждая запись содержит следующие поля:
     - Название книги (`title`)
     - Имя автора (`author`)
     - Аннотация (`annotation`)
   - Мы хотим реализовать форму поиска, которая будет искать книги по этим полям с использованием полнотекстового поиска.
   - Поиск должен быть эффективным, поддерживать ранжирование результатов и работать с учетом различных словоформ.

2. **Настройка таблицы для полнотекстового поиска**:
   - Для начала нам нужно создать таблицу, которая будет хранить информацию о книгах. Например:
     ```sql
     CREATE TABLE books (
         id SERIAL PRIMARY KEY,
         title TEXT NOT NULL,
         author TEXT NOT NULL,
         annotation TEXT
     );
     ```
   - После этого мы можем добавить данные в таблицу:
     ```sql
     INSERT INTO books (title, author, annotation) VALUES
     ('The Magic Mountain', 'Thomas Mann', 'A novel about a sanatorium in the Swiss Alps.'),
     ('Harry Potter and the Philosopher''s Stone', 'J.K. Rowling', 'The first book in the Harry Potter series.'),
     ('The Time Machine', 'H.G. Wells', 'A science fiction novel about time travel.');
     ```

3. **Создание индекса для ускорения поиска**:
   - Чтобы ускорить поиск, мы можем создать GIN-индекс для полнотекстового поиска. Однако перед этим нам нужно определиться, какие поля будут участвовать в поиске.
   - Мы будем искать по названию, имени автора и аннотации, поэтому создадим дополнительный столбец `tsvector`, который будет содержать объединенные данные из этих полей:
     ```sql
     ALTER TABLE books ADD COLUMN search_vector TSVECTOR;

     UPDATE books
     SET search_vector = to_tsvector('english', title || ' ' || author || ' ' || COALESCE(annotation, ''));
     ```

   - Теперь создаем GIN-индекс для этого столбца:
     ```sql
     CREATE INDEX idx_books_search ON books USING GIN(search_vector);
     ```

4. **Поиск по названиям, авторам и аннотациям книг**:
   - Теперь мы можем выполнять запросы с использованием полнотекстового поиска. Например, чтобы найти книги, связанные с "magic", можно использовать следующий запрос:
     ```sql
     SELECT title, author, annotation
     FROM books
     WHERE search_vector @@ to_tsquery('magic');
     ```

   - Этот запрос найдет все книги, где слово "magic" встречается в названии, имени автора или аннотации. Благодаря индексу, поиск будет выполняться быстро даже при большом количестве записей.

5. **Ранжирование результатов**:
   - Для улучшения пользовательского опыта мы можем ранжировать результаты поиска, используя функцию `ts_rank`. Например:
     ```sql
     SELECT title, author, annotation,
            ts_rank(search_vector, to_tsquery('magic')) AS rank
     FROM books
     WHERE search_vector @@ to_tsquery('magic')
     ORDER BY rank DESC
     LIMIT 10;
     ```
   - Здесь мы вычисляем релевантность каждого документа с помощью функции `ts_rank` и сортируем результаты по убыванию релевантности. Это позволяет показывать наиболее подходящие книги в начале списка.

6. **Логические связки и фразовый поиск**:
   - Мы также можем использовать логические операторы (`AND`, `OR`, `NOT`) для создания более сложных запросов. Например, чтобы найти книги, где есть слова "magic" и "time", можно использовать следующий запрос:
     ```sql
     SELECT title, author, annotation
     FROM books
     WHERE search_vector @@ to_tsquery('magic & time');
     ```

   - Если мы хотим выполнить фразовый поиск (то есть найти книги, где слова "magic" и "time" идут строго друг за другом), мы можем использовать оператор `<->`:
     ```sql
     SELECT title, author, annotation
     FROM books
     WHERE search_vector @@ to_tsquery('magic <-> time');
     ```

7. **Настройка и оптимизация поиска для конкретных задач**:
   - В зависимости от требований проекта, мы можем настроить поиск более детально. Например, если мы хотим, чтобы поиск был чувствителен к регистру или чтобы он учитывал специфические особенности языка, мы можем изменить конфигурацию полнотекстового поиска.
   - Например, если мы хотим убрать стоп-слова (например, артикли в английском языке), мы можем изменить цепочку словарей:
     ```sql
     ALTER TEXT SEARCH CONFIGURATION english
     ALTER MAPPING FOR word WITH simple;
     ```
   - Здесь мы заменили стандартный словарь на `simple`, который просто приводит слова к нижнему регистру и не удаляет стоп-слова.

8. **Обработка длинных текстов**:
   - Если аннотации книг длинные, мы можем использовать функцию `ts_headline`, чтобы вырезать и выделить фрагменты текста, содержащие найденные слова. Это полезно для отображения контекста найденного результата пользователю.
   - Пример использования `ts_headline`:
     ```sql
     SELECT title, author,
            ts_headline('english', annotation, to_tsquery('magic'), 'StartSel=<b>, StopSel=</b>') AS snippet
     FROM books
     WHERE search_vector @@ to_tsquery('magic');
     ```
   - Здесь мы используем HTML-теги `<b>` для выделения найденных слов в аннотации.

#### Итоги
Полнотекстовый поиск — это мощный инструмент, который может значительно улучшить функциональность вашего приложения. В нашем примере с книжным магазином мы:
- Реализовали поиск по названиям, именам авторов и аннотациям книг.
- Настроили индексацию для ускорения поиска.
- Добавили возможность ранжирования результатов и фразового поиска.
- Оптимизировали поиск для конкретных задач, таких как удаление стоп-слов и обработка длинных текстов.

Эта часть конспекта завершает подробное описание полнотекстового поиска. Мы рассмотрели теоретические основы, механизм работы, настройку и практическое применение полнотекстового поиска.