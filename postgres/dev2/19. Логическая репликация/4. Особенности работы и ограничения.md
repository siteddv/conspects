### Часть 4: Особенности работы и ограничения

#### Идентификация строк
Одним из ключевых аспектов логической репликации является **идентификация строк**. Когда изменения передаются со стороны публикующего сервера, подписчик должен уметь однозначно определить, к какой именно строке в таблице относится это изменение.

- **Использование первичного ключа**:  
  Наиболее распространённый способ идентификации строк — использование первичного ключа. Если таблица имеет первичный ключ, он автоматически используется для идентификации строк при применении изменений. Это наиболее эффективный и надёжный метод.
  
- **Альтернативные способы идентификации**:  
  Если первичный ключ отсутствует, можно использовать:
  - **Уникальные индексы**: Индексы с ограничением `NOT NULL` могут быть использованы для идентификации строк. Это похоже на использование первичного ключа, но менее строго.
  - **Все столбцы таблицы**: В крайнем случае, можно использовать все столбцы строки для её идентификации. Однако этот метод менее эффективен и может привести к проблемам производительности.
  - **Отключение идентификации**: Если идентификация строк невозможна, такие таблицы не смогут участвовать в логической репликации.

#### Обработка конфликтов
При работе с логической репликацией могут возникать **конфликты**, особенно если на стороне подписчика также происходят изменения данных. Конфликты чаще всего связаны с нарушением ограничений целостности, например, попыткой вставить строку с уже существующим первичным ключом.

- **Приостановка репликации**:  
  При возникновении конфликта процесс логической репликации приостанавливается. Подписчик ждёт, пока конфликт не будет разрешён вручную.

- **Способы разрешения конфликтов**:  
  - **Корректировка данных на стороне подписчика**: Можно вручную изменить данные на стороне подписчика, чтобы устранить конфликт (например, удалить или изменить конфликтующую строку).
  - **Пропуск конфликтующей записи**: Существуют специальные функции PostgreSQL, которые позволяют пропустить конфликтующую запись и продолжить репликацию с последующих изменений. Однако этот подход требует осторожности, так как может привести к потере данных.

#### Работа с триггерами
Триггеры на стороне подписчика имеют особенности работы в контексте логической репликации:

- **Отключение триггеров по умолчанию**:  
  При применении реплицированных изменений обычные триггеры (как `BEFORE`, так и `AFTER`) **не срабатывают**. Это связано с предположением, что структура таблиц и триггеров одинакова на обоих серверах, и триггер уже сработал на стороне публикующего сервера.

- **Управление поведением триггеров**:  
  Поведение триггеров можно настроить с помощью команды `ALTER TABLE ... ENABLE/DISABLE TRIGGER`:
  - `ENABLE REPLICA TRIGGER`: Триггер будет срабатывать только при применении реплицированных изменений.
  - `ENABLE ALWAYS TRIGGER`: Триггер будет срабатывать как при репликации, так и при обычных операциях.
  - `DISABLE TRIGGER`: Триггер полностью отключается.

- **Триггеры уровня операторов**:  
  Триггеры уровня `STATEMENT` (операторов) **не работают** при логической репликации, так как передаются только изменения строк, а не SQL-команды.

#### Ограничения логической репликации
Несмотря на гибкость, логическая репликация имеет ряд важных ограничений:

1. **Не реплицируются команды DDL**:  
   Логическая репликация передаёт только изменения данных, но не структуры таблиц. Это означает, что любые изменения схемы (например, добавление столбцов) должны выполняться вручную на стороне подписчика.

2. **Значения последовательностей**:  
   Значения последовательностей (`SEQUENCE`) не реплицируются. Если последовательности используются для генерации первичных ключей, необходимо вручную синхронизировать их значения между серверами.

3. **Большие объекты**:  
   Большие объекты (например, типы данных `BLOB`) не поддерживаются логической репликацией.

4. **Материализованные представления**:  
   Материализованные представления не обновляются автоматически при логической репликации. Их необходимо обновлять вручную.

5. **Секционированные таблицы**:  
   Логическая репликация поддерживает репликацию отдельных секций, но не всей секционированной таблицы целиком.

6. **Большие транзакции**:  
   Если транзакция на стороне публикующего сервера изменяет большое количество данных, это может вызвать задержки в репликации. Процесс `wal sender` ждёт завершения транзакции, сортирует данные и только затем передаёт их подписчику.

7. **Автоматическое разрешение конфликтов**:  
   На данный момент PostgreSQL не поддерживает автоматическое разрешение конфликтов. Все конфликты должны разрешаться вручную.

8. **Двунаправленная репликация одной таблицы**:  
   Логическая репликация не поддерживает двунаправленную репликацию одной и той же таблицы между серверами. Это может привести к бесконечным циклам репликации.

---

Это завершает четвёртую часть конспекта. Хотите продолжить с пятой частью?