### Часть 5: Практические задания и сравнение инструментов

#### Расчет рейтинга книг
- **Цель задачи**: Реализовать расчет рейтинга книг на основе голосов "за" и "против".
- **Наивная формула**: В комментариях к слайду приведена простая формула, которая может работать некорректно.
- **Улучшенная формула**: Необходимо разработать более точную формулу или использовать уже реализованную функцию `treating`.
- **Обновление таблицы**: Рейтинг должен быть помещен в таблицу. Однако, чтобы избежать значительного увеличения размера таблицы, обновление должно выполняться пакетами.

#### Обновление таблиц пакетами
- **Почему пакетное обновление**: Полное обновление таблицы может привести к ее значительному расширению (в два раза). Частичные обновления помогают избежать этого.
- **Процедура**:
  - **Шаг 1**: Обновить часть строк таблицы.
  - **Шаг 2**: Запустить очистку (`VACUUM`).
  - **Шаг 3**: Повторять шаги 1 и 2 до полного обновления таблицы.

#### Сравнение pg_background и dblink
- **Цель задачи**: Сравнить накладные расходы и производительность `pg_background` и `dblink`.
- **Методика сравнения**:
  - **Запуск процессов**: Запустить одинаковые задачи с использованием обоих инструментов.
  - **Измерение времени выполнения**: Засечь время выполнения каждой задачи.
  - **Анализ результатов**: Определить, какой инструмент работает быстрее и насколько.

#### Дополнительная практика
- **Обертка для pg_background**:
  - **Цель**: Написать обертку, которая будет пытаться запустить процесс, если он не смог запуститься сразу из-за превышения лимита фоновых процессов.
  - **Логика работы**:
    - **Проверка лимита**: Перед запуском проверить текущее количество активных фоновых процессов.
    - **Ожидание освобождения ресурсов**: Если лимит превышен, ждать освобождения ресурсов и повторять попытку запуска.

#### Пример реализации процедур
- **Расчет рейтинга и обновление таблицы**:
  ```sql
  CREATE OR REPLACE PROCEDURE update_book_ratings()
  AS $$
  DECLARE
      batch_size INT := 1000;
      total_rows INT;
      updated_rows INT := 0;
  BEGIN
      SELECT COUNT(*) INTO total_rows FROM books;

      WHILE updated_rows < total_rows LOOP
          UPDATE books
          SET rating = treating(up_votes, down_votes)
          WHERE id BETWEEN updated_rows + 1 AND updated_rows + batch_size;

          updated_rows := updated_rows + batch_size;

          -- Запуск очистки
          PERFORM background_launch('VACUUM books');
      END LOOP;
  END;
  $$ LANGUAGE plpgsql;
  ```

- **Сравнение производительности**:
  ```sql
  DO $$
  DECLARE
      start_time TIMESTAMP;
      end_time TIMESTAMP;
      duration INTERVAL;
  BEGIN
      -- Измерение времени для pg_background
      start_time := clock_timestamp();
      PERFORM background_launch('SELECT some_heavy_query()');
      SELECT * FROM pg_background_result(process_id);
      end_time := clock_timestamp();
      duration := end_time - start_time;
      RAISE NOTICE 'pg_background duration: %', duration;

      -- Измерение времени для dblink
      start_time := clock_timestamp();
      PERFORM dblink_connect('myconn', 'dbname=mydb');
      SELECT * FROM dblink('myconn', 'SELECT some_heavy_query()') AS t(result text);
      PERFORM dblink_disconnect('myconn');
      end_time := clock_timestamp();
      duration := end_time - start_time;
      RAISE NOTICE 'dblink duration: %', duration;
  END;
  $$ LANGUAGE plpgsql;
  ```

#### Выводы
- **Преимущества pg_background**:
  - **Производительность**: Быстрее, так как использует внутренние механизмы PostgreSQL.
  - **Экономия ресурсов**: Не требует установки полноценного соединения с базой данных.
- **Преимущества dblink**:
  - **Гибкость**: Может подключаться к другим серверам.
  - **Стандартное решение**: Входит в состав PostgreSQL, не требует дополнительной установки.

Таким образом, практические задания и сравнение инструментов позволяют глубже понять возможности и ограничения фоновых процессов в PostgreSQL. Это помогает эффективно использовать их для решения реальных задач и оптимизации работы системы.

Хотите перейти к следующей части?