# 8. Типы для больших значений

## Описание

Эта глава посвящена работе с большими объектами в PostgreSQL. Мы рассмотрим введение в работу с большими объектами, хранение данных в файловой системе, хранение данных внутри базы данных (TOAST), работу с типом данных bytea, подсистему больших объектов (Large Objects), а также практические задания и рекомендации.

## Части главы

- [[части/1. Введение в работу с большими объектами|1. Введение в работу с большими объектами]] [1. Введение в работу с большими объектами](части/1. Введение в работу с большими объектами.md)
- [[части/2. Хранение данных в файловой системе|2. Хранение данных в файловой системе]] [2. Хранение данных в файловой системе](части/2. Хранение данных в файловой системе.md)
- [[части/3. Хранение данных внутри базы данных (TOAST)|3. Хранение данных внутри базы данных (TOAST)]] [3. Хранение данных внутри базы данных (TOAST)](части/3. Хранение данных внутри базы данных (TOAST).md)
- [[части/4. Работа с типом данных bytea|4. Работа с типом данных bytea]] [4. Работа с типом данных bytea](части/4. Работа с типом данных bytea.md)
- [[части/5. Подсистема больших объектов (Large Objects)|5. Подсистема больших объектов (Large Objects)]] [5. Подсистема больших объектов (Large Objects)](части/5. Подсистема больших объектов (Large Objects).md)
- [[части/6. Практические задания и рекомендации|6. Практические задания и рекомендации]] [6. Практические задания и рекомендации](части/6. Практические задания и рекомендации.md)

---

В большинстве приложений используются относительно короткие типы данных: числа, строки (десятки или сотни символов), даты и логические типы. Однако иногда возникает необходимость работать с большими объектами, такими как файлы различных типов (картинки, видео, мультимедиа) и большие документы (PDF и т.д.).

Существует два основных варианта хранения больших объектов: хранение в файловой системе и хранение внутри базы данных. Хранение в файловой системе имеет преимущества в скорости (не используются механизмы WAL и буферный кэш) и не увеличивает размер базы данных, но имеет недостатки: отсутствие транзакционной работы и управления доступом средствами СУБД, риск потери согласованности данных и усложнение архитектуры системы.

Для хранения больших объектов внутри базы данных используются типы данных `bytea` (для двоичных данных) и `text` (для символьных данных). Механизм TOAST (The Oversized-Attribute Storage Technique) предназначен для хранения атрибутов большой длины, которые не помещаются на одной странице данных. При создании таблицы с потенциально большими атрибутами автоматически создается служебная таблица TOAST в схеме `pg_toast`. Структура служебной таблицы включает `chunk_id` (идентификатор длинного значения), `chunk_seq` (порядковый номер фрагмента) и `chunk_data` (значение фрагмента данных).

Стратегии хранения данных в TOAST включают: `extended` (использует сжатие данных), `main` (переносится в последнюю очередь, также использует сжатие), `external` (без сжатия, подходит для уже сжатых данных) и `plain` (только для столбцов фиксированной ширины, всегда остаются в основной таблице). Если значение не помещается на странице основной таблицы, оно выносится в служебную таблицу TOAST. При обращении к длинному атрибуту данные собираются из фрагментов в служебной таблице. При изменении строки новая версия строки ссылается на предыдущее значение, если длинные атрибуты не менялись.

Подсистема больших объектов (Large Objects) предоставляет отдельный интерфейс для работы с большими объектами. Все большие объекты хранятся в единой системной таблице `pg_largeobject`. Преимущества включают размер значения до 4 ТБ и возможность потокового чтения и записи отдельных фрагментов. Недостатки включают увеличение размера базы данных, более медленную работу по сравнению с файловой системой и ограничение на общее количество больших объектов (идентификатор типа OID ограничивает количество объектов до ~4 миллиардов).

Функции для работы с большими объектами включают `lo_import` (загружает файл в базу данных и возвращает OID), `lo_get` (читает часть данных по указанному OID) и другие. При удалении записи из пользовательской таблицы большой объект остается в `pg_largeobject`. Для очистки потерянных объектов используется утилита `vacuumlo` или расширение `lo` с триггерной функцией для автоматического удаления объектов.

При работе с типом данных `bytea` данные выводятся в шестнадцатеричном формате по умолчанию. При загрузке файла данные автоматически выносятся в служебную таблицу TOAST, если они превышают размер страницы. Размер данных в TOAST может быть меньше исходного размера файла благодаря сжатию данных. При изменении даже небольшого фрагмента данных в столбце типа `bytea` весь атрибут загружается в буферный кэш и изменяется целиком, что может привести к заполнению буферного кэша "грязными" буферами.

Рекомендации по выбору метода хранения: если приложение требует транзакционной работы и управления доступом средствами СУБД, лучше использовать тип `bytea` или подсистему больших объектов. Если важна скорость работы и размер базы данных не должен увеличиваться, можно рассмотреть вариант хранения файлов в файловой системе. При оптимизации запросов следует избегать использования `SELECT *`, особенно если в таблице есть большие столбцы, и перечислять только те столбцы, которые действительно нужны.

