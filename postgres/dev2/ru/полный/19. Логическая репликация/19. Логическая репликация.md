# 19. Логическая репликация

Логическая репликация — это механизм, который позволяет передавать изменения данных между серверами PostgreSQL на уровне строк, а не на уровне бинарных данных (как в случае физической репликации). Это дает возможность организовать более гибкую схему взаимодействия между серверами. Логическая репликация работает по принципу публикации и подписки. Один сервер (публикация) создает поток изменений для определенных таблиц, а другой сервер (подписчик) подписывается на эти изменения. В отличие от физической репликации, где есть четкое разделение на мастер и реплику, при логической репликации оба сервера могут быть основными и работать независимо друг от друга. При этом они могут как публиковать свои изменения, так и подписываться на изменения других серверов. Логическая репликация позволяет настраивать репликацию не только целых кластеров, но и отдельных таблиц. Это особенно полезно в сложных системах, где требуется точечная синхронизация данных.

Логическая репликация в PostgreSQL основана на механизме WAL (Write-Ahead Logging), но с важным отличием от физической репликации. В процессе логической репликации WAL-записи декодируются для выделения информации о конкретных изменениях строк таблиц, которые участвуют в публикации. Этот процесс позволяет передавать не бинарные данные, а именно изменения строк. Для работы логической репликации требуется установка параметра `wal_level` на уровень `logical`. Это обеспечивает запись в WAL дополнительной информации, которая необходима для декодирования изменений конкретных таблиц. Без этой настройки логическая репликация работать не сможет. Уровень `replica` (который используется для физической репликации) недостаточен для логической репликации, так как он не содержит детальной информации о изменениях строк. Установка `wal_level = logical` требует перезагрузки сервера, что важно учитывать при планировании внедрения логической репликации.

Для начала работы с логической репликацией необходимо создать публикацию на стороне сервера-источника. Это делается с помощью команды `CREATE PUBLICATION`. Публикация определяет, какие таблицы будут участвовать в репликации. На стороне подписчика создаётся подписка, которая указывает на публикацию, к которой нужно подключиться. Подписка создаётся с помощью команды `CREATE SUBSCRIPTION`. При создании подписки происходит автоматическая начальная синхронизация данных. Если таблица на стороне подписчика пустая, она будет заполнена данными из таблицы на стороне публикации. Это позволяет избежать ручной синхронизации данных перед началом репликации. При создании подписки на стороне публикующего сервера автоматически создаётся слот репликации. Этот объект отвечает за хранение информации о позиции WAL, до которой данные были переданы подписчику. Слот репликации гарантирует, что WAL-записи не будут удалены до тех пор, пока они не будут применены на стороне подписчика. Это особенно важно при временных задержках или обрывах связи между серверами.

Одним из ключевых аспектов логической репликации является идентификация строк. Когда изменения передаются со стороны публикующего сервера, подписчик должен уметь однозначно определить, к какой именно строке в таблице относится это изменение. Наиболее распространённый способ идентификации строк — использование первичного ключа. Если таблица имеет первичный ключ, он автоматически используется для идентификации строк при применении изменений. Это наиболее эффективный и надёжный метод. Если первичный ключ отсутствует, можно использовать уникальные индексы (индексы с ограничением `NOT NULL`) или все столбцы таблицы. При работе с логической репликацией могут возникать конфликты, особенно если на стороне подписчика также происходят изменения данных. Конфликты чаще всего связаны с нарушением ограничений целостности, например, попыткой вставить строку с уже существующим первичным ключом. При возникновении конфликта процесс логической репликации приостанавливается. Подписчик ждёт, пока конфликт не будет разрешён вручную. Можно вручную изменить данные на стороне подписчика, чтобы устранить конфликт, или пропустить конфликтующую запись с помощью специальных функций PostgreSQL.

Триггеры на стороне подписчика имеют особенности работы в контексте логической репликации. При применении реплицированных изменений обычные триггеры (как `BEFORE`, так и `AFTER`) не срабатывают. Это связано с предположением, что структура таблиц и триггеров одинакова на обоих серверах, и триггер уже сработал на стороне публикующего сервера. Поведение триггеров можно настроить с помощью команды `ALTER TABLE ... ENABLE/DISABLE TRIGGER`. Триггеры уровня `STATEMENT` (операторов) не работают при логической репликации, так как передаются только изменения строк, а не SQL-команды.

Несмотря на гибкость, логическая репликация имеет ряд важных ограничений. Логическая репликация передаёт только изменения данных, но не структуры таблиц. Это означает, что любые изменения схемы (например, добавление столбцов) должны выполняться вручную на стороне подписчика. Значения последовательностей (`SEQUENCE`) не реплицируются. Если последовательности используются для генерации первичных ключей, необходимо вручную синхронизировать их значения между серверами. Большие объекты (например, типы данных `BLOB`) не поддерживаются логической репликацией. Материализованные представления не обновляются автоматически при логической репликации. Их необходимо обновлять вручную. Логическая репликация поддерживает репликацию отдельных секций, но не всей секционированной таблицы целиком. Если транзакция на стороне публикующего сервера изменяет большое количество данных, это может вызвать задержки в репликации. Процесс `wal sender` ждёт завершения транзакции, сортирует данные и только затем передаёт их подписчику. На данный момент PostgreSQL не поддерживает автоматическое разрешение конфликтов. Все конфликты должны разрешаться вручную. Логическая репликация не поддерживает двунаправленную репликацию одной и той же таблицы между серверами. Это может привести к бесконечным циклам репликации.

Логическая репликация может быть использована для решения различных бизнес-задач. Типовые сценарии использования включают консолидацию данных из региональных филиалов в центральный офис, синхронизацию справочников между серверами и создание мастер-мастер репликации (хотя последнее пока имеет ограничения). Хотя PostgreSQL не поддерживает полноценную мастер-мастер репликацию через логическую репликацию, существуют сторонние решения, которые расширяют её возможности, такие как BDR (Bi-Directional Replication) и pglogical. Эти решения позволяют реплицировать одну и ту же таблицу в обоих направлениях, автоматически разрешать конфликты и организовывать более сложные схемы взаимодействия между серверами.

- [[части/1. Введение в логическую репликацию|1. Введение в логическую репликацию]] [1. Введение в логическую репликацию](части/1. Введение в логическую репликацию.md)
- [[части/2. Техническая реализация логической репликации|2. Техническая реализация логической репликации]] [2. Техническая реализация логической репликации](части/2. Техническая реализация логической репликации.md)
- [[части/3. Практическая настройка репликации|3. Практическая настройка репликации]] [3. Практическая настройка репликации](части/3. Практическая настройка репликации.md)
- [[части/4. Особенности работы и ограничения|4. Особенности работы и ограничения]] [4. Особенности работы и ограничения](части/4. Особенности работы и ограничения.md)
- [[части/5. Практическое применение в разработке|5. Практическое применение в разработке]] [5. Практическое применение в разработке](части/5. Практическое применение в разработке.md)
- [[части/6. Практические задания|6. Практические задания]] [6. Практические задания](части/6. Практические задания.md)

