### Часть 2: Составные типы и перечисления (5:00 - 12:00)

#### Основные концепции:

1. **Типы перечислений (ENUM)**:
   - **Определение**: Тип перечисления представляет собой упорядоченный набор значений.
   - **Характеристики**:
     - Значения хранятся как строки, но занимают всего 4 байта в базе данных.
     - Упорядоченность означает, что значения можно сравнивать (например, "шестерка" < "туз").
     - Регистр значений имеет значение, что необходимо учитывать при работе с ними.

2. **Создание типа перечисления**:
   - Используется команда `CREATE TYPE`.
   - Пример: создание типа перечисления для игральных карт:
     ```sql
     CREATE TYPE card_rank AS ENUM ('6', '7', '8', '9', '10', 'jack', 'queen', 'king', 'ace');
     CREATE TYPE card_suit AS ENUM ('hearts', 'diamonds', 'clubs', 'spades');
     ```
   - После создания типы становятся доступны в схеме `public` и могут быть использованы в запросах.

3. **Работа с типами перечислений**:
   - **Проверка значений**:
     - Можно получить первое и последнее значение перечисления с помощью функций `enum_first()` и `enum_last()`.
     - Пример:
       ```sql
       SELECT enum_first(NULL::card_rank); -- '6'
       SELECT enum_last(NULL::card_rank);  -- 'ace'
       ```
   - **Сравнение значений**:
     - Значения можно сравнивать благодаря их упорядоченности.
     - Пример:
       ```sql
       SELECT 'ace'::card_rank > '6'::card_rank; -- true
       ```

4. **Модификация типов перечислений**:
   - **Добавление значений**:
     - Новые значения можно добавить с помощью команды `ALTER TYPE`.
     - Пример: добавление "валета" перед "дамой":
       ```sql
       ALTER TYPE card_rank ADD VALUE 'jack' BEFORE 'queen';
       ```
   - **Ограничения**:
     - Удаление значений из перечисления невозможно.
     - Если требуется удалить значение, нужно создать новый тип перечисления.

5. **Составные типы на основе перечислений**:
   - Можно создавать составные типы, используя типы перечислений в качестве атрибутов.
   - Пример: создание типа "карта" с атрибутами "ранг" и "масть":
     ```sql
     CREATE TYPE card AS (
         rank card_rank,
         suit card_suit
     );
     ```
   - Пример использования:
     ```sql
     DO $$
     DECLARE
         my_card card;
     BEGIN
         my_card := ('ace', 'spades')::card;
         RAISE NOTICE 'Card: % of %', my_card.rank, my_card.suit;
     END $$;
     ```

#### Практические примеры:

6. **Перебор всех значений перечисления**:
   - PostgreSQL предоставляет функцию для получения всех значений перечисления в виде массива.
   - Пример:
     ```sql
     SELECT enum_range(NULL::card_rank);
     -- {'6','7','8','9','10','jack','queen','king','ace'}
     ```
   - Это позволяет легко перебирать все возможные значения, например, для генерации полной колоды карт:
     ```sql
     DO $$
     DECLARE
         rank card_rank;
         suit card_suit;
     BEGIN
         FOREACH rank IN ARRAY enum_range(NULL::card_rank) LOOP
             FOREACH suit IN ARRAY enum_range(NULL::card_suit) LOOP
                 RAISE NOTICE 'Card: % of %', rank, suit;
             END LOOP;
         END LOOP;
     END $$;
     ```

7. **Использование составных типов**:
   - Созданный составной тип `card` можно использовать в переменных и функциях.
   - Пример:
     ```sql
     DO $$
     DECLARE
         my_card card;
     BEGIN
         my_card := ('ace', 'spades')::card;
         RAISE NOTICE 'Card: % of %', my_card.rank, my_card.suit;
         
         IF my_card.rank = 'ace' THEN
             RAISE NOTICE 'This is an ace!';
         END IF;
     END $$;
     ```

#### Важные замечания:

8. **Упорядоченность перечислений**:
   - Упорядоченность позволяет выполнять сравнения и сортировку значений.
   - Однако важно помнить, что регистр значений имеет значение.

9. **Ограничения на модификацию**:
   - Добавление новых значений возможно только через `ALTER TYPE`.
   - Удаление значений невозможно — для этого нужно создавать новый тип.

10. **Применение составных типов**:
   - Составные типы удобны для работы со структурами данных, которые состоят из нескольких связанных атрибутов.
   - Они могут быть использованы в функциях, процедурах и переменных.

#### Заключение второй части:
- Типы перечислений предоставляют удобный способ работы с фиксированным набором значений.
- Составные типы позволяют создавать сложные структуры данных, объединяя несколько атрибутов.
- Возможность добавлять новые значения в перечисления делает их гибкими, но удаление значений требует создания нового типа.

Хотите перейти к подробному пересказу третьей части?

