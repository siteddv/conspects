### Часть 5: Детальная реализация обработчиков (20:01 - 25:00)

#### 5.1. Управление транзакциями

- **Проблема с длинными транзакциями**:
  - В предыдущей реализации вся обработка выполнялась в рамках одной большой транзакции.
  - Это приводит к тому, что горизонт событий для базы данных удерживается на одном уровне, что может мешать очистке старых данных и увеличивать нагрузку на систему.

- **Решение**:
  - Каждое сообщение должно обрабатываться в своей собственной транзакции.
  - После взятия сообщения из очереди нужно сразу зафиксировать транзакцию, чтобы освободить блокировки и продвинуть горизонт событий.

- **Модифицированная процедура обработки**:
  ```sql
  CREATE OR REPLACE PROCEDURE process_queue(current_process_id INT)
  LANGUAGE plpgsql
  AS $$
  DECLARE
      message RECORD;
  BEGIN
      LOOP
          -- Начало транзакции
          START TRANSACTION;

          SELECT * INTO message
          FROM get_next_message(current_process_id);

          IF NOT FOUND THEN
              COMMIT;
              EXIT;
          END IF;

          -- Фиксация взятия сообщения
          COMMIT;

          -- Обработка сообщения
          PERFORM pg_sleep(1); -- Имитация обработки

          -- Завершение обработки
          START TRANSACTION;
          CALL complete_message(message.id);
          COMMIT;
      END LOOP;
  END;
  $$;
  ```

#### 5.2. Преимущества управления транзакциями

- **Продвижение горизонта событий**:
  - После фиксации взятия сообщения горизонт событий продвигается, что позволяет системе эффективно управлять старыми данными.
  - Максимальное время задержки теперь ограничено временем обработки одного сообщения.

- **Параллельная обработка**:
  - Разные обработчики могут работать независимо, не мешая друг другу.
  - Пример: При обработке 10 сообщений двумя обработчиками общее время сокращается вдвое.

#### 5.3. Обработка ошибок и зависших сообщений

- **Проблема зависших сообщений**:
  - Если обработка сообщения завершается ошибкой, оно остается в таблице с указанным `process_id`.
  - Следующие обработчики не смогут его подхватить, так как поле `process_id` уже заполнено.

- **Решение**:
  - Проверка статуса процесса:
    ```sql
    SELECT pg_stat_activity WHERE pid = message.process_id;
    ```
  - Если процесс не существует, можно обнулить `process_id` и повторно попытаться обработать сообщение:
    ```sql
    UPDATE queue
    SET process_id = NULL
    WHERE id = message.id AND NOT EXISTS (
        SELECT 1 FROM pg_stat_activity WHERE pid = message.process_id
    );
    ```

#### 5.4. Сохранение результатов обработки

- **Добавление столбца для статуса**:
  - Для отслеживания статуса обработки добавляется новый столбец:
    ```sql
    ALTER TABLE queue ADD COLUMN status VARCHAR(20) DEFAULT 'pending';
    ```

- **Обновление статуса**:
  - После успешной обработки статус обновляется:
    ```sql
    UPDATE queue
    SET status = 'completed'
    WHERE id = message.id;
    ```

- **Сохранение результатов**:
  - Можно добавить столбец для хранения результатов обработки:
    ```sql
    ALTER TABLE queue ADD COLUMN result JSONB;
    ```

- **Пример обновления**:
    ```sql
    UPDATE queue
    SET status = 'completed', result = '{"success": true}'
    WHERE id = message.id;
    ```

#### 5.5. Очистка исторических данных

- **Проблема роста таблицы**:
  - По мере обработки сообщений таблица может расти, что увеличивает нагрузку на систему.

- **Решение**:
  - Создание процедуры для очистки старых сообщений:
    ```sql
    CREATE OR REPLACE PROCEDURE cleanup_queue()
    LANGUAGE plpgsql
    AS $$
    BEGIN
        DELETE FROM queue
        WHERE status = 'completed' AND created_at < NOW() - INTERVAL '7 days';
    END;
    $$;
    ```

- **Автоматическая очистка**:
  - Настройка автоматической очистки через cron или аналогичные инструменты.

---

Это завершает пятую часть конспекта. Если вы готовы, мы можем перейти к следующей части, где рассмотрим обработку ошибок и дополнительные улучшения.

