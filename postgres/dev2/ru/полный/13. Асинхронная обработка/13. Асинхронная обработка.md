# 13. Асинхронная обработка

## Описание

Эта глава посвящена асинхронной обработке в PostgreSQL. Мы рассмотрим введение в асинхронную обработку, обзор возможных решений для реализации очередей, анализ существующих систем очередей, реализацию собственной системы очередей, детальную реализацию обработчиков, обработку ошибок и дополнительные улучшения, а также практическое применение и задания.

## Части главы

- [[части/1. Введение в асинхронную обработку|1. Введение в асинхронную обработку]] [1. Введение в асинхронную обработку](части/1. Введение в асинхронную обработку.md)
- [[части/2. Обзор возможных решений для реализации очередей|2. Обзор возможных решений для реализации очередей]] [2. Обзор возможных решений для реализации очередей](части/2. Обзор возможных решений для реализации очередей.md)
- [[части/3. Анализ существующих систем очередей|3. Анализ существующих систем очередей]] [3. Анализ существующих систем очередей](части/3. Анализ существующих систем очередей.md)
- [[части/4. Реализация собственной системы очередей|4. Реализация собственной системы очередей]] [4. Реализация собственной системы очередей](части/4. Реализация собственной системы очередей.md)
- [[части/5. Детальная реализация обработчиков|5. Детальная реализация обработчиков]] [5. Детальная реализация обработчиков](части/5. Детальная реализация обработчиков.md)
- [[части/6. Обработка ошибок и дополнительные улучшения|6. Обработка ошибок и дополнительные улучшения]] [6. Обработка ошибок и дополнительные улучшения](части/6. Обработка ошибок и дополнительные улучшения.md)
- [[части/7. Практическое применение и задания|7. Практическое применение и задания]] [7. Практическое применение и задания](части/7. Практическое применение и задания.md)

---

Асинхронная обработка — это разделение времени между возникновением события и его обработкой. В отличие от синхронной обработки, где клиент отправляет запрос и ждет ответа, оставаясь заблокированным до получения результата, асинхронная обработка позволяет системе обрабатывать множество событий одновременно без блокировки основных процессов. Преимущества асинхронной обработки включают увеличение производительности и эффективности использования ресурсов, возможность легко масштабировать систему и гарантию того, что события будут обработаны даже при временных сбоях в системе.

Для реализации очередей можно использовать внешние системы обработки очередей (RabbitMQ, Kafka, ActiveMQ) или базу данных. Внешние системы являются специализированными решениями для обработки сообщений и обеспечивают высокую производительность и надежность, но требуют дополнительного администрирования и мониторинга, а также могут терять сообщения при сбоях в сети или системе. Использование базы данных для обработки очередей обеспечивает транзакционную целостность (гарантия того, что событие будет зафиксировано вместе с его обработкой) и отсутствие внешних зависимостей, но может иметь ограниченную производительность по сравнению со специализированными системами.

Существующая система очередей pgq/skytools существует давно и широко используется, но имеет недостатки: сообщения обрабатываются только пакетами (что может привести к повторной обработке всего пакета в случае ошибки), требует внешней программы-демона для периодического вызова и разработана для старых версий PostgreSQL. Реализация собственной системы очередей позволяет создать простое решение без внешних зависимостей, но требует тщательного тестирования и отладки.

Базовая структура таблицы очереди включает столбцы `id` (идентификатор события), `payload` (полезная нагрузка события, например, JSON) и `process_id` (идентификатор процесса, который обрабатывает событие, по умолчанию NULL). Для выбора сообщения для обработки используется запрос с `FOR UPDATE SKIP LOCKED`, который блокирует выбранную строку для других процессов, но позволяет другим процессам пропустить заблокированные строки и взять следующие. После выбора сообщения его состояние обновляется установкой `process_id` на текущий процесс.

Управление транзакциями является важным аспектом реализации системы очередей. Каждое сообщение должно обрабатываться в своей собственной транзакции. После взятия сообщения из очереди нужно сразу зафиксировать транзакцию, чтобы освободить блокировки и продвинуть горизонт событий. Это позволяет системе эффективно управлять старыми данными и обеспечивает параллельную обработку разными обработчиками.

Обработка ошибок и зависших сообщений требует проверки статуса процесса. Если процесс не существует, можно обнулить `process_id` и повторно попытаться обработать сообщение. Для отслеживания статуса обработки можно добавить столбец `status` и столбец `result` для хранения результатов обработки. Очистка исторических данных может быть реализована через процедуру, которая удаляет старые сообщения, и автоматическую очистку через cron или аналогичные инструменты.

