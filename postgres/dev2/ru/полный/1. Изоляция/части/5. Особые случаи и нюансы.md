### Часть 5: Особые случаи и нюансы

#### 1. **Работа с функциями**
В PostgreSQL функции могут вести себя по-разному в зависимости от их категории изменчивости (`VOLATILE`, `STABLE`, `IMMUTABLE`). Это особенно важно при работе с транзакциями на различных уровнях изоляции.

- **Категория `VOLATILE`**:
  - Функции с этой категорией могут видеть изменения, произведённые другими транзакциями, даже если сама транзакция работает на уровне `Read Committed`.
  - Пример: Если функция выполняет запрос внутри себя, она может увидеть изменения, которые были зафиксированы после начала выполнения внешнего оператора.
  - Это может привести к несогласованности данных, особенно если функция используется в запросах, которые выполняются долго.

- **Как решить проблему?**
  - Если функция не изменяет состояние базы данных (например, только читает данные), можно изменить её категорию изменчивости на `STABLE` или `IMMUTABLE`.
  - Это гарантирует, что функция будет видеть данные на момент начала выполнения внешнего оператора, а не текущее состояние базы данных.

##### Пример:
```sql
-- Создание функции с категорией VOLATILE
CREATE OR REPLACE FUNCTION get_light_state(lamp_name TEXT) RETURNS TEXT AS $$
BEGIN
    RETURN (SELECT state FROM lights WHERE lamp = lamp_name);
END;
$$ LANGUAGE plpgsql VOLATILE;

-- Изменение категории на STABLE
CREATE OR REPLACE FUNCTION get_light_state(lamp_name TEXT) RETURNS TEXT AS $$
BEGIN
    RETURN (SELECT state FROM lights WHERE lamp = lamp_name);
END;
$$ LANGUAGE plpgsql STABLE;
```

---

#### 2. **Потерянные обновления**
На уровне `Read Committed` возможны потерянные обновления, если транзакция разбивает операцию обновления на два шага:
1. Чтение данных.
2. Обновление данных на основе прочитанных значений.

##### Пример:
- **Транзакция 1**: Выключает красную лампу.
  ```sql
  BEGIN;
  UPDATE lights SET state = 'off' WHERE lamp = 'red';
  ```

- **Транзакция 2**: Проверяет состояние красной лампы и переключает её.
  ```sql
  BEGIN;
  SELECT state INTO current_state FROM lights WHERE lamp = 'red';
  IF current_state = 'on' THEN
      UPDATE lights SET state = 'off' WHERE lamp = 'red';
  ELSE
      UPDATE lights SET state = 'on' WHERE lamp = 'red';
  END IF;
  COMMIT;
  ```

- Если первая транзакция завершается раньше второй, вторая транзакция может проигнорировать изменения первой, что приведёт к потерянным обновлениям.

##### Как предотвратить?
- Использовать уровень `Repeatable Read` или выше.
- Не разбивать операции обновления на чтение и запись. Вместо этого выполнять всё в одном запросе:
  ```sql
  UPDATE lights SET state = CASE WHEN state = 'on' THEN 'off' ELSE 'on' END WHERE lamp = 'red';
  ```

---

#### 3. **Фантомное чтение**
Фантомное чтение происходит, когда между двумя запросами появляются новые строки, которые удовлетворяют условию запроса.

##### Пример:
- **Транзакция 1**: Читает все выключенные лампы.
  ```sql
  BEGIN ISOLATION LEVEL REPEATABLE READ;
  SELECT * FROM lights WHERE state = 'off';
  ```

- **Транзакция 2**: Добавляет новую строку — жёлтую лампу, которая также выключена.
  ```sql
  INSERT INTO lights (lamp, state) VALUES ('yellow', 'off');
  COMMIT;
  ```

- **Транзакция 1**: Повторно выполняет запрос.
  ```sql
  SELECT * FROM lights WHERE state = 'off';
  ```

  На уровне `Repeatable Read` в PostgreSQL фантомное чтение предотвращается, хотя стандарт SQL допускает его.

---

#### 4. **Конфликты сериализации**
На уровне `Serializable` транзакции могут завершаться с ошибкой сериализации, если невозможно выстроить их выполнение в правильном порядке.

##### Пример:
- **Транзакция 1**: Включает все выключенные лампы.
  ```sql
  BEGIN ISOLATION LEVEL SERIALIZABLE;
  UPDATE lights SET state = 'on' WHERE state = 'off';
  ```

- **Транзакция 2**: Выключает все включённые лампы.
  ```sql
  BEGIN ISOLATION LEVEL SERIALIZABLE;
  UPDATE lights SET state = 'off' WHERE state = 'on';
  ```

- Если обе транзакции попытаются зафиксировать изменения:
  ```sql
  COMMIT; -- Одна из транзакций завершится с ошибкой сериализации.
  ```

##### Как решить проблему?
- Перезапустить транзакцию, которая завершилась с ошибкой.
- Убедиться, что все конкурирующие транзакции работают на уровне `Serializable`.

---

#### Заключение
Особые случаи и нюансы реализации уровней изоляции в PostgreSQL требуют внимательного подхода. Например:
- Функции с категорией `VOLATILE` могут видеть изменения, произведённые другими транзакциями.
- На уровне `Read Committed` возможны потерянные обновления, если операция разбивается на чтение и запись.
- На уровне `Repeatable Read` в PostgreSQL предотвращается фантомное чтение, хотя стандарт SQL допускает его.
- На уровне `Serializable` транзакции могут завершаться с ошибкой сериализации, если невозможно выстроить их выполнение в правильном порядке.

Хотите перейти к шестой части — "Практические задания и выводы"?

