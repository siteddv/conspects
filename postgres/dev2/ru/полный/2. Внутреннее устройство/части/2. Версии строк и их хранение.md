### Часть 2: Версии строк и их хранение

#### 2.1 Структура версии строки
- **Заголовок строки**:
  - Каждая версия строки имеет заголовок, который занимает **24 байта** (с учетом выравнивания).
  - Заголовок содержит важную служебную информацию, включая поля `xmin` и `xmax`.

- **Поля `xmin` и `xmax`**:
  - **`xmin`**:
    - Хранит номер транзакции, которая создала данную версию строки.
    - Например, если строка была добавлена транзакцией с номером `100`, то `xmin = 100`.
  - **`xmax`**:
    - Хранит номер транзакции, которая удалила или изменила данную версию строки.
    - Если строка еще не удалена или изменена, то `xmax = 0`.

#### 2.2 Статус транзакций
- **Журнал транзакций (clog)**:
  - В PostgreSQL существует специальный журнал транзакций (clog), который хранит статус каждой транзакции.
  - Для каждой транзакции в журнале хранятся два признака:
    - **Зафиксирована ли транзакция**.
    - **Отменена ли транзакция**.
  - Если транзакция еще выполняется, то в журнале ничего не указано напротив этих признаков.

- **Биты информации о статусе**:
  - Помимо номеров транзакций (`xmin` и `xmax`), в заголовке строки хранятся биты, которые помогают определить статус транзакций.
  - Эти биты указывают, завершена ли транзакция, и если да, то была ли она успешной или отменена.

#### 2.3 Процесс фиксации изменений
- **Фиксация изменений**:
  - При выполнении команды `INSERT` новая строка добавляется в таблицу, а соответствующая запись появляется в индексе.
  - В момент фиксации изменений (`COMMIT`) происходит следующее:
    - В журнале статусов транзакций проставляется признак, что транзакция была зафиксирована.
    - Никакие изменения в данных таблицы или индекса не происходят.

- **Читающая транзакция**:
  - Когда другая транзакция пытается прочитать строку, она проверяет статус транзакции через журнал статусов транзакций.
  - Если транзакция была зафиксирована, читающая транзакция обновляет биты в заголовке строки, чтобы отметить это.
  - Это позволяет последующим транзакциям сразу видеть, что строка доступна, без необходимости обращаться к журналу транзакций.

#### 2.4 Удаление строк
- **Процесс удаления**:
  - При удалении строки текущая транзакция записывает свой номер в поле `xmax` строки.
  - Например, если транзакция с номером `101` удаляет строку, то `xmax = 101`.
  - До момента фиксации транзакции (`COMMIT`) строка считается заблокированной, так как её статус еще не определен.

- **Блокировка строк**:
  - Если другая транзакция попытается изменить или удалить ту же строку, она увидит, что поле `xmax` уже занято номером активной транзакции.
  - Это предотвращает конфликты и обеспечивает целостность данных.

#### 2.5 Обновление строк
- **Обычное обновление**:
  - При выполнении команды `UPDATE` создается новая версия строки, а старая версия помечается как удаленная.
  - В поле `xmax` старой версии записывается номер транзакции, выполнившей обновление.
  - Новая версия строки получает значение `xmin`, равное номеру транзакции, выполнившей обновление.

- **Оптимизация "HOT-обновления"**:
  - Если обновление не затрагивает индексируемые столбцы, PostgreSQL использует оптимизацию, называемую **HOT-обновление** (Heap-Only Tuple).
  - В этом случае:
    - В таблице создается новая версия строки.
    - В индексе остается только ссылка на старую версию строки.
    - Новая версия строки связывается со старой через специальную цепочку указателей.

#### 2.6 Практический пример
- Создана таблица `t` с двумя столбцами:
  - `id` (числовой).
  - `c` (строковый).
- Добавлена строка `(42, 'foo')`.
- Выполнено обновление строки: `(42, 'bar')`.
- Использовано расширение `pageinspect` для анализа:
  - В таблице видны две версии строки:
    - Первая версия: `xmin = 591`, `xmax = 592`.
    - Вторая версия: `xmin = 592`, `xmax = 0`.
  - В индексе остается только одна запись, указывающая на первую версию строки.

---

Это завершает вторую часть конспекта. Хотите продолжить с третьей частью?

