### Часть 4: Управление блокировками и ожиданиями

#### Немедленное получение ошибки при блокировке
В PostgreSQL существует возможность отказаться от ожидания освобождения блокировки, если ресурс уже заблокирован. Это особенно полезно в ситуациях, когда нужно сразу получить информацию о том, что ресурс недоступен, вместо того чтобы ждать его освобождения.

- **Ключевое слово `NOWAIT`**: 
  - Используется для немедленного получения ошибки, если блокировка не может быть захвачена.
  - Пример использования:
    ```sql
    BEGIN;
    LOCK TABLE accounts IN EXCLUSIVE MODE NOWAIT;
    ```
    - Если таблица уже заблокирована другой транзакцией, команда завершится с ошибкой: `ERROR: could not obtain lock on relation "accounts"`.
  
- **Практическое применение**:
  - Полезно в сценариях, где нужно быстро определить доступность ресурса и принять альтернативные решения.
  - Например, можно использовать `NOWAIT` для проверки доступности строки перед выполнением операции изменения данных.

##### Пример с `SELECT FOR UPDATE NOWAIT`:
```sql
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE NOWAIT;
```
- Если строка уже заблокирована другой транзакцией, команда завершится с ошибкой:
  ```
  ERROR: could not obtain lock on row in relation "accounts"
  ```

#### Использование `SKIP LOCKED`
`SKIP LOCKED` — это механизм, который позволяет пропустить уже заблокированные строки и перейти к тем, которые еще свободны. Это особенно полезно в сценариях конкурентной обработки данных, например, в очередях задач.

- **Пример использования**:
  ```sql
  SELECT * FROM accounts WHERE id = 1 FOR UPDATE SKIP LOCKED;
  ```
  - Если строка с `id = 1` уже заблокирована, команда пропустит её и выберет следующую доступную строку.

- **Практическое применение**:
  - В системах синхронной работы (например, очереди задач), где несколько процессов могут одновременно пытаться обработать одну и ту же строку.
  - Позволяет избежать длительного ожидания и повысить производительность за счет параллельной обработки.

##### Пример:
1. Транзакция A блокирует строку с `id = 1`.
2. Транзакция B выполняет запрос:
   ```sql
   SELECT * FROM accounts WHERE id IN (1, 2) FOR UPDATE SKIP LOCKED;
   ```
   - Результат: Транзакция B пропускает строку с `id = 1` и выбирает строку с `id = 2`.

#### Таймауты ожидания блокировок
PostgreSQL предоставляет параметр `lock_timeout`, который позволяет установить максимальное время ожидания освобождения блокировки. Если таймаут превышается, команда завершается с ошибкой.

- **Настройка таймаута**:
  ```sql
  SET lock_timeout = '1s';
  ```
  - Устанавливает таймаут ожидания блокировки на 1 секунду.

- **Пример использования**:
  ```sql
  BEGIN;
  ALTER TABLE accounts DROP COLUMN amount;
  ```
  - Если таблица уже заблокирована другой транзакцией, команда завершится с ошибкой через 1 секунду:
    ```
    ERROR: canceling statement due to lock timeout
    ```

- **Практическое применение**:
  - Полезно для предотвращения длительных простоев в случае, если блокировка не может быть захвачена.
  - Позволяет контролировать время ожидания и принимать решения о повторных попытках или альтернативных действиях.

#### Протокол очереди ожидания строк
Очередь ожидания блокировок строк в PostgreSQL имеет особенности, которые отличают её от очереди ожидания блокировок объектов. Основная сложность заключается в том, что очередь блокировок строк организована не так "честно", как очередь блокировок объектов.

##### Протокол ожидания:
1. **Захват блокировки типа `tuple`**:
   - Перед тем как работать со строкой, процесс должен захватить исключительную блокировку типа `tuple` (синоним версии строки).
   - Эта блокировка хранится в оперативной памяти и используется для организации очереди.

2. **Проверка поля `xmax`**:
   - После захвата блокировки типа `tuple`, процесс проверяет поле `xmax` строки:
     - Если поле `xmax` пустое (или содержит номер завершенной транзакции), процесс записывает свой номер в `xmax`.
     - Если поле `xmax` уже занято другим процессом, текущий процесс вынужден ждать освобождения блокировки.

3. **Освобождение блокировки типа `tuple`**:
   - После записи своего номера в `xmax`, процесс освобождает блокировку типа `tuple`.

##### Пример:
4. Транзакция A изменяет строку:
   - Захватывает блокировку типа `tuple`.
   - Записывает свой номер в `xmax`.
   - Освобождает блокировку типа `tuple`.

5. Транзакция B пытается изменить ту же строку:
   - Захватывает блокировку типа `tuple`.
   - Обнаруживает, что поле `xmax` уже занято транзакцией A.
   - Ждет освобождения блокировки транзакции A.

6. Транзакция C пытается изменить ту же строку:
   - Захватывает блокировку типа `tuple`.
   - Обнаруживает, что блокировка типа `tuple` уже удерживается транзакцией B.
   - Ждет освобождения блокировки типа `tuple`.

##### Особенности очереди:
- **Нечестная очередь**: В отличие от блокировок объектов, очередь блокировок строк может стать "бесформенной".
- **Гонка за блокировкой**: Когда транзакция освобождает блокировку, все процессы, стоящие в очереди, начинают гонку за новую блокировку.

---

### Ключевые моменты для Obsidian:

#### Немедленное получение ошибки при блокировке
- **`NOWAIT`**: Отказ от ожидания блокировки.
- **Ошибка**: Если блокировка не может быть захвачена, команда завершается с ошибкой.

#### Использование `SKIP LOCKED`
- **Пропуск заблокированных строк**: Позволяет выбрать только доступные строки.
- **Практическое применение**: Особенно полезно в системах синхронной обработки данных.

#### Таймауты ожидания блокировок
- **`lock_timeout`**: Настройка максимального времени ожидания блокировки.
- **Ошибка**: Если таймаут превышен, команда завершается с ошибкой.

#### Протокол очереди ожидания строк
- **Захват блокировки типа `tuple`**: Первый шаг перед работой со строкой.
- **Проверка поля `xmax`**: Определение, заблокирована ли строка.
- **Освобождение блокировки**: После записи номера транзакции в `xmax`.

#### Практические примеры
- **`NOWAIT`**: Использование для быстрой проверки доступности ресурса.
- **`SKIP LOCKED`**: Пропуск заблокированных строк в конкурентной обработке.
- **`lock_timeout`**: Контроль времени ожидания блокировки.

#### Важные термины
- **`NOWAIT`**: Ключевое слово для немедленного получения ошибки.
- **`SKIP LOCKED`**: Механизм пропуска заблокированных строк.
- **`lock_timeout`**: Параметр для настройки таймаута ожидания блокировки.
- **Блокировка типа `tuple`**: Блокировка версии строки.

---

Это завершает четвертую часть конспекта. Хотите перейти к пятой части?

