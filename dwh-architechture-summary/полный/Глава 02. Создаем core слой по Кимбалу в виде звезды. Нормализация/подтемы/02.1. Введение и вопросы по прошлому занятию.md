# 02.1. Введение и вопросы по прошлому занятию

### **2. Вопросы по прошлому занятию (01:03 – 14:47)**

**2.1. Проблема с отображением схемы базы данных** (01:03 – 05:19)

- **Вопрос:** После создания схемы она не отображается в списке.
- **Решение:** Нужно **обновить соединение** в PostgreSQL (перезагрузить схему).
- **Дополнительный вопрос:** Новые базы данных, созданные вчера, сегодня не видны.
- **Решение:** Нужно **создать новое подключение** в редакторе объекта соединения. Каждая база требует отдельного подключения.
- **Демонстрация:** Открытие соединения в PostgreSQL **(Sybase IQ, pgAdmin)**, создание нового подключения, настройка параметров.

---

**2.2. Получение списка баз данных** (05:19 – 07:03)

- Используется SQL-запрос:
    
    ```sql
    SELECT * FROM pg_database;
    ```
    
- Команда выводит список всех баз данных в PostgreSQL.
- **Важное замечание:** Каждая база данных имеет **свои параметры подключения (пользователь, пароль)**, которые необходимо помнить.
- В случае потери пароля можно воспользоваться `pg_restore` или методами восстановления пароля.

---

**2.3. Временные таблицы в PostgreSQL** (07:03 – 09:07)

- В PostgreSQL временные таблицы работают **аналогично обычным**, но с рядом преимуществ:
    1. **Автоматическое удаление** после завершения сессии.
    2. Возможность использования **"UNLOGGED"** (журнал транзакций не записывается, что ускоряет работу).
    3. В других СУБД (MS SQL, Oracle) временные таблицы работают **иначе** и могут быть более гибкими.
- **Ответ на вопрос:** Да, временные таблицы **аналогичны** созданию и последующему удалению обычных таблиц.

---

**2.4. Вопрос о типах данных** (09:07 – 14:47)

- **Вопрос:** Должны ли типы данных в разных таблицах **совпадать**, если они связаны?
- **Ответ:**
    - **Да, должны совпадать**, иначе возможны **проблемы с производительностью и хранением данных**.
    - Если, например, в одной таблице **film_id** – `INT4`, а в другой `INT8`, то выделяется **больше памяти**, но она **не используется**.
    - Особенно важно учитывать это при работе со строками (`VARCHAR`).
    - **Пример:** В исходных данных строка ограничена 255 символами, значит, **в хранилище** нужно оставить **255**, а не `TEXT`, чтобы **не тратить лишнюю память**.

---

### **3. Разбор домашнего задания (14:47 – 21:07)**

- **Вопрос:** Как было решено задание по заполнению таблицы случайными данными?
- **Решение участника (Ольги):**
    - Используется **рандомная сортировка строк (`ORDER BY RANDOM()`)**.
    - Создается три временные таблицы, в которых:
        1. Первое поле – `1` (единица),
        2. Второе поле – идентификаторы (`inventory_id`, `customer_id`, `staff_id`).
    - **Как это работает?**
        - Таблицы соединяются по полю **`1`**, создавая **все возможные случайные комбинации**.
        - Затем из них выбирается нужное количество строк (`LIMIT`).
    - **Лектор комментирует:**
        - Это **интересный и полезный подход**.
        - Однако создается **большая таблица**, что может быть **нерационально**.
        - Альтернативный вариант: использовать **`ORDER BY RANDOM() LIMIT X`**, **без временной таблицы**.

---

### **Итоги первой части**

- Были разобраны **вопросы участников**:  
    ✅ **Обновление схемы базы данных**.  
    ✅ **Создание новых подключений** в PostgreSQL.  
    ✅ **Получение списка баз данных** с помощью `pg_database`.  
    ✅ **Работа с временными таблицами** в PostgreSQL.  
    ✅ **Влияние типов данных** на производительность.
- Разобрано **домашнее задание**:
    - Использование **рандомного заполнения** таблицы.
    - Лектор предложил **альтернативный, более оптимальный вариант**.

