# Глава 03. Наполняем core слой полной перезаписью. Хранилище по Кимбалу

Третья глава курса посвящена практическому наполнению Core-слоя данными с использованием полной перезагрузки (Full Reload). Рассматривается создание и наполнение таблиц измерений и фактов, исправление ошибок с зависимостями и оптимизация процесса загрузки.

## Задача на сегодня и подготовка стейджинг-слоя

Основная задача — заполнить Core-слой данными. Используется полная перезагрузка: каждый раз загружаются все данные заново из источника в стейджинг-слой, затем из стейджинг-слоя в Core-слой. Это простой способ загрузки, но он нагружает систему. В будущем будет реализована инкрементальная загрузка.

Сначала пересоздается стейджинг-слой: удаляются и создаются таблицы заново. Создаются таблицы в стейджинг-слое для хранения данных из источника: `film`, `inventory`, `rental`, `payment`, `staff`, `address`, `city`. В таблицах `staff` и `address` загружаются не все поля, а только те, которые понадобятся в хранилище.

Создаются процедуры загрузки данных в стейджинг-слой: `LOAD_FILM()`, `LOAD_INVENTORY()`, `LOAD_RENTAL()`, `LOAD_PAYMENT()`, `LOAD_STAFF()`, `LOAD_ADDRESS()`, `LOAD_CITY()`. Каждая процедура удаляет все данные из таблицы стейджинг-слоя и загружает свежие данные из источника. Время загрузки составляет около 368 миллисекунд.

## Создание и наполнение Core-слоя

В Core-слое создаются 4 таблицы: измерение сотрудников (`dim_staff`), измерение фильмов и дисков (`dim_inventory`), факт платежей (`fact_payment`), факт аренды (`fact_rental`). Используется схема "Звезда": факты связаны с измерениями через суррогатные ключи.

Таблица `dim_inventory` содержит суррогатный ключ `inventory_pk`, идентификатор из источника `inventory_id`, идентификатор фильма `film_id`, название фильма `title`, продолжительность аренды `rental_duration`, ставку аренды `rental_rate`, рейтинг фильма `rating`. Процесс наполнения: удаление данных, загрузка из `staging.inventory`, соединение с `staging.film`, заполнение `dim_inventory`. Количество строк в `dim_inventory` = 4 584, совпадает с `staging.inventory`.

Таблица `dim_staff` содержит суррогатный ключ `staff_pk`, идентификатор сотрудника из источника `staff_id`, имя и фамилию сотрудника, адрес магазина, город магазина, регион. Процесс наполнения: удаление старых данных, соединение таблиц `staging.staff`, `staging.store`, `staging.address`, `staging.city`, заполнение `dim_staff`. Число строк = 2 (два сотрудника в базе).

Таблица `fact_payment` содержит суррогатный ключ `payment_pk`, идентификатор платежа `payment_id`, сумму платежа `amount`, дату платежа `payment_date`, ссылки на `dim_inventory` и `dim_staff`. Процесс наполнения: удаление старых данных, соединение таблиц `staging.payment`, `staging.rental`, `core.dim_inventory`, `core.dim_staff`, группировка данных по `inventory_fk`, `staff_fk` и `payment_date`, заполнение `fact_payment`. Число строк = 14 596, совпадает с `staging.payment`.

## Создание и наполнение таблиц фактов

Реализована полная загрузка `fact_payment`. Алгоритм загрузки: удаление старых данных, создание SQL-запроса для загрузки данных из `staging.payment`, присоединение `staging.rental` для получения связи платежа с арендой, присоединение `core.dim_inventory` и `core.dim_staff` для получения внешних ключей, группировка платежей по измерениям и дате, преобразование `payment_date` в формат "дата без времени". В таблицу `fact_payment` загружено 14 596 строк, совпадает с источником.

Для таблицы `fact_rental` задание для участников: самостоятельно написать SQL-запрос для загрузки. Алгоритм аналогичен `fact_payment`, но источник данных — `staging.rental`, присоединяются `core.dim_inventory` и `core.dim_staff`, группировка по `inventory_fk`, `staff_fk`, `rental_date`.

## Исправление ошибок и работа с зависимостями

При попытке удалить данные из `dim_inventory` или `dim_staff` возникает ошибка, так как таблицы фактов (`fact_payment`, `fact_rental`) ссылаются на измерения, и SQL-сервер не позволяет удалять строки, на которые есть ссылки. Решение: удалять данные из таблиц фактов перед загрузкой измерений.

Создается процедура `fact_delete()` для удаления данных из таблиц фактов перед их перезагрузкой. Процедура очищает таблицы `fact_payment` и `fact_rental`. Добавляется вызов `fact_delete()` в процедуру полной загрузки перед загрузкой измерений.

Исправляется ошибка: процедуры создаются в `public` вместо `core`. Явно указывается схема `core` при создании всех процедур. Пересоздаются все процедуры в `core`, проверяется схема в `pgAdmin`.

Выявлена необходимость оптимизации: полная загрузка данных выполняется около 9 секунд, при этом загрузка в `staging` занимает 0.3 секунды, а загрузка в `core` — 8.7 секунд. Это говорит о неэффективных SQL-запросах в `core`, скорее всего из-за сложных `JOIN` и отсутствия индексов. Будущая оптимизация: использование индексов для ускорения JOIN, переход к инкрементальной загрузке.

## Очистка данных перед загрузкой

При использовании полной перезагрузки данных перед каждой загрузкой нужно удалить старые данные, иначе они будут дублироваться. Порядок удаления важен, так как таблицы связаны внешними ключами.

Создается единая процедура `full_load()`, которая: удаляет данные из фактов (`fact_delete()`), перезагружает данные в измерения (`load_inventory()`, `load_staff()`), загружает факты (`load_fact_payment()`, `load_fact_rental()`). Теперь достаточно вызвать `full_load()`, чтобы полностью обновить данные. Все данные загружаются в правильном порядке, нет ошибок с внешними ключами, можно запускать раз в день/час для актуальности хранилища.

## Домашнее задание и обсуждение оптимизации

Домашнее задание включает: реализацию процедуры загрузки `fact_rental` (написать SQL-запрос, аналогичный `fact_payment`), создание SQL-скрипта для полного пересоздания `staging` и `core`-слоев (удаление всех таблиц и процедур, создание всех таблиц и процедур заново, вызов `full_load()` для проверки), тестирование полного цикла загрузки (добавить новые строки в `staging.rental`, запустить `full_load()`, проверить появление новых строк в `fact_rental`).

Планы на следующие занятия: построение отчетов (создание витрины данных, подготовка данных для аналитики, визуализация в Power BI), оптимизация хранилища (создание индексов, партиционирование, материализованные представления), переход к инкрементальной загрузке (загружать только новые или измененные данные вместо полной перезагрузки).

---

**Подробнее:** [[Глава 03. Наполняем core слой полной перезаписью. Хранилище по Кимбалу]] [Глава 03. Наполняем core слой полной перезаписью. Хранилище по Кимбалу](../полный/Глава 03. Наполняем core слой полной перезаписью. Хранилище по Кимбалу/Глава 03. Наполняем core слой полной перезаписью. Хранилище по Кимбалу.md)

