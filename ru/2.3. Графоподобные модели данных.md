Связи «многие-ко-многим» — ключевая характеристика моделей данных. Если в приложении преобладают «один-ко-многим» связи или они отсутствуют, хорошо подходит документная модель. Однако при частом возникновении сложных взаимосвязей эффективнее использовать графовые модели. Графы состоят из вершин (узлов) и ребер (связей) и могут моделировать различные типы данных. Примеры включают социальные графы, где вершины — люди, а ребра отражают знакомство; веб-графы, где вершины — страницы, а ребра — ссылки; и транспортные сети, где вершины — перекрестки, а ребра — дороги.

Для работы с графами применяются известные алгоритмы, например, для поиска кратчайшего пути или определения популярности страниц (алгоритм PageRank). Графы не ограничиваются однородными данными и могут хранить разные типы объектов. Например, Facebook использует единый граф с вершинами, представляющими людей и события, и ребрами, отражающими их связи. Это позволяет эффективно управлять сложными взаимосвязями между данными.

![[10. Graph example.png]]

Существует несколько подходов к структурированию графовых данных и выполнению запросов. В этом разделе рассматриваются модель графа свойств (property graph), используемая в СУБД, таких как Neo4j и Titan, и модель хранилища тройных кортежей (triple-store), реализованная в Datomic и AllegroGraph. Обсуждаются декларативные языки Cypher, SPARQL и Datalog, а также императивный язык Gremlin и фреймворк Pregel.

### Графы свойств

В модели графов свойств каждая вершина имеет уникальный идентификатор, множество исходящих и входящих ребер, а также коллекцию свойств в виде пар «ключ — значение». Каждое ребро также имеет уникальный идентификатор, начальную и конечную вершины, а также коллекцию свойств. Графовое хранилище можно представить в виде двух реляционных таблиц: одна для вершин, другая для ребер, где свойства хранятся в формате JSON.

Важные аспекты этой модели включают возможность соединения любой вершины с любой другой без ограничений, что позволяет находить входящие и исходящие ребра и выполнять обход графа. Использование различных меток для ребер позволяет хранить разные виды информации в одном графе, сохраняя структуру модели.

Графы предлагают гибкость в моделировании данных, позволяя легко добавлять новые связи и свойства. Например, можно указать аллергии пользователей, создавая вершины для аллергенов и соединяя их с соответствующими пользователями. Это позволяет выполнять запросы, чтобы узнать, какие продукты безопасны для определенных людей.

Кроме того, графы позволяют учесть сложные взаимосвязи, такие как разные административные единицы в разных странах или исторические особенности. Таким образом, расширение графа возможно при добавлении новых свойств и изменениях в структуре данных приложения, что делает его удобным инструментом для работы с динамичными и сложными наборами данных.

### Язык запросов Cypher

Cypher — это декларативный язык запросов, предназначенный для работы с графами свойств в графовой базе данных Neo4j. Он получил свое название в честь персонажа фильма «Матрица» и не имеет отношения к криптографическим шифрам.

Язык позволяет легко создавать и управлять вершинами и ребрами в графе. Например, запрос на вставку данных может выглядеть следующим образом:

```cypher
CREATE 
(NAmerica:Location {name:'North America', type:'continent'}), 
(USA:Location {name:'United States', type:'country'}), 
(Idaho:Location {name:'Idaho', type:'state'}), 
(Lucy:Person {name:'Lucy'}), 
(Idaho) -[:WITHIN]-> (USA), 
(Lucy) -[:BORN_IN]-> (Idaho)
```

После добавления данных можно задавать различные вопросы, такие как поиск людей, эмигрировавших из США в Европу. Пример запроса для этой задачи:

```cypher
MATCH 
(person) -[:BORN_IN]-> () -[:WITHIN*0..]-> (us:Location {name:'United States'}), 
(person) -[:LIVES_IN]-> () -[:WITHIN*0..]-> (eu:Location {name:'Europe'}) 
RETURN person.name
```

Запрос находит вершины `person`, у которых есть ребра `BORN_IN` и `LIVES_IN`, указывающие на соответствующие географические точки. Он возвращает свойство `name` для каждого найденного человека.

Cypher оптимизирует выполнение запросов автоматически, позволяя разработчикам не беспокоиться о деталях реализации. Запросы могут быть написаны так, чтобы начинать с людей или географических мест, а оптимизатор выберет наиболее эффективный путь выполнения, упрощая работу с графовыми данными и позволяя сосредоточиться на бизнес-логике приложения.

### Хранилища тройных кортежей и SPARQL

