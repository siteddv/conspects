Программы работают с данными в двух представлениях: в памяти и в виде последовательности байтов. В памяти данные хранятся в оптимизированных структурах (объекты, списки и т. д.), удобных для CPU. При записи или передаче данные кодируются в последовательность байтов (например, JSON). Процесс преобразования из памяти в байтовую последовательность называется кодированием (или сериализацией), а обратный процесс — декодированием (или десериализацией). В книге используется термин «кодирование», чтобы избежать путаницы. Существует множество библиотек и форматов для этой задачи.

### Форматы, ориентированные на конкретные языки

Во многих языках программирования есть встроенные средства кодирования объектов в байтовые последовательности (например, Java — java.io.Serializable, Ruby — Marshal, Python — pickle). Эти библиотеки удобны, но имеют серьезные недостатки:

**Языковая привязка:** Кодирование зависит от конкретного языка, что затрудняет интеграцию с другими системами.

**Безопасность:** Декодирование может создавать экземпляры произвольных классов, что открывает возможности для атак.

**Контроль версий:** Многие библиотеки игнорируют проблемы совместимости, что усложняет поддержку старых и новых версий.

**Эффективность:** Производительность и объем памяти часто не учитываются, что делает встроенные средства неэффективными.

Из-за этих проблем использование таких средств для долгосрочных целей обычно нецелесообразно.

### JSON, XML и двоичные типы данных

Стандартизованные форматы кодирования, такие как JSON и XML, широко поддерживаются, но имеют свои недостатки. XML критикуют за "многословность", а JSON популярен благодаря встроенной поддержке в браузерах и простоте. CSV также распространен, но имеет ограниченные возможности.

Все три формата сталкиваются с проблемами кодирования чисел: в XML и CSV трудно различить числа и строки, в то время как JSON не поддерживает точность для целых и дробных чисел. Проблема больших чисел (более 2^53) в JavaScript также актуальна. В API Twitter идентификаторы твитов возвращаются и как JSON-числа, и как строки, чтобы избежать неточностей.

JSON и XML поддерживают строки в кодировке Unicode, но не двоичные строки, что требует кодирования двоичных данных через Base64, увеличивая объем на 33%. Оба формата поддерживают схемы, что усложняет их использование. CSV не имеет схемы, что затрудняет обработку изменений в данных.

Несмотря на недостатки, JSON, XML и CSV остаются популярными для обмена данными между предприятиями, поскольку главное — согласие о формате.

Для внутренних данных можно выбирать более эффективные двоичные форматы, такие как MessagePack и BSON. Эти форматы расширяют типы данных, но не задают схемы, поэтому все имена полей должны быть включены в закодированные данные. Например, в MessagePack объект из JSON занимает 66 байт, что меньше 81 байта текстового JSON. Однако вопрос о потере удобочитаемости ради экономии места остается открытым.

### Thrift и Protocol Buffers

