Репликация в системах управления базами данных обеспечивает отказоустойчивость, масштабируемость и снижение времени ожидания. Архитектура с ведущим и ведомыми узлами позволяет распределять запросы на чтение, что снижает нагрузку на ведущий узел. Однако асинхронная репликация может привести к устареванию данных на ведомых узлах, вызывая временную несогласованность. Эта несогласованность, известная как конечная согласованность, возникает, когда данные на ведомом узле отстают от ведущего. Задержка репликации может варьироваться от долей секунды до минут, что создает практические проблемы для приложений. В таких условиях важно учитывать риски, связанные с устаревшими данными, и разрабатывать механизмы для минимизации влияния задержек на пользовательский опыт и целостность данных.

### Читаем свои же записи

Многие приложения позволяют пользователям отправлять данные и затем просматривать их, например, записи в БД или комментарии. Новые данные сначала отправляются на ведущий узел, но при просмотре могут читаться с ведомых узлов. Проблема возникает в случае асинхронной репликации: если пользователь пытается просмотреть данные сразу после записи, они могут еще не быть доступны на реплике, что вызывает опасения по поводу потери информации.

![[24. Read yourself replication.png]]

Для решения этой проблемы необходима согласованность типа «чтение после записи» (read-after-write consistency), которая гарантирует, что пользователь увидит свои изменения. Существует несколько подходов к реализации этой согласованности:

1. **Чтение с ведущего узла**: Данные, измененные пользователем, читаются с ведущего узла, в то время как остальная информация может запрашиваться с ведомых узлов. Это эффективно, если пользователи редактируют только свои данные.

2. **Отслеживание времени обновления**: Если пользователь может редактировать множество данных, можно использовать временные метки, чтобы в течение определенного времени (например, минуты) запрашивать информацию с ведущего узла.

3. **Использование меток времени**: Пользователь может хранить метку времени последней записи. При чтении система проверяет актуальность реплики, и, если она устарела, перенаправляет запрос или ждет обновления.

4. **Геораспределенные реплики**: Запросы к ведущему узлу должны маршрутизироваться в соответствующий центр обработки данных (ЦОД), чтобы обеспечить согласованность.

5. **Множественные устройства**: При доступе с разных устройств необходимо централизованно хранить метаданные обновлений, а также маршрутизировать запросы от всех устройств в один ЦОД для достижения согласованности. 

Таким образом, при проектировании систем важно учитывать эти аспекты для обеспечения надежного пользовательского опыта.

### Монотонные чтения

При чтении данных с асинхронных ведомых узлов может возникнуть аномалия, когда пользователь наблюдает "движение во времени назад". Это происходит, если пользователь выполняет несколько запросов к различным репликам, и первый запрос возвращает данные, которые не видны при втором запросе к более запаздывающей реплике. Например, если пользователь 2345 сначала получает комментарий от пользователя 1234 с актуального узла, а затем запрашивает данные с устаревшего узла, он может не увидеть этот комментарий, создавая впечатление, что информация исчезает.

![[25. Monothonic replication.png]]

Для предотвращения этой аномалии необходимо реализовать монотонное чтение записей, которое гарантирует, что в последовательных операциях чтения старые данные не будут возвращены после новых. Один из способов достижения этого — обеспечить чтение с одной и той же реплики для каждого пользователя, используя хеш идентификатора пользователя для выбора реплики.

### Согласованное префиксное чтение

Третья аномалия задержки репликации касается нарушения причинно-следственной связи. Например, в диалоге между мистером Пунсом и миссис Кейк ответ миссис Кейк зависит от вопроса мистера Пунса. Если разговор слышит третий человек через ведомые узлы с разной задержкой репликации, он может услышать ответ до вопроса, создавая иллюзию экстрасенсорных способностей.

![[26. Consistent replicaation.png]]

Чтобы избежать таких аномалий, необходимо реализовать согласованное префиксное чтение (consistent prefix reads), что гарантирует, что операции записи будут прочитаны в том же порядке, в котором они выполнялись. Это особенно сложно в секционированных базах данных, где операции могут происходить независимо, и пользователи могут видеть разные состояния базы данных. Одно из решений — записывать связанные операции в одну секцию, однако это не всегда возможно. Также существуют алгоритмы для отслеживания причинно-следственных зависимостей.

### Решения проблемы задержки репликации