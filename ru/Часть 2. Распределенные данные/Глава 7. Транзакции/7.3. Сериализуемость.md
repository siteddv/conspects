Глава обсуждает проблемы гонок состояний в транзакциях, включая асимметрию записи и фантомы. Уровни изоляции данных реализуются по-разному в разных БД, что делает их использование сложным. Отсутствие инструментов для выявления состояний гонки усложняет тестирование. Решением является использование сериализуемости, которая гарантирует правильность выполнения транзакций как при последовательном, так и при конкурентном их выполнении. Рассматриваются три метода реализации сериализуемости: последовательное выполнение, двухфазная блокировка и оптимистическое управление конкурентным доступом.

### Последовательное выполнение

Простейший способ избежать проблем с конкурентным доступом — выполнять транзакции последовательно, в одном потоке. Этот подход стал популярным в 2007 году, когда дешевые RAM и осознание, что OLTP-транзакции обычно короткие, позволили эффективно работать с данными в памяти. Системы, использующие однопоточное выполнение, такие как VoltDB, Redis и Datomic, часто показывают лучшую производительность, чем многопоточные, так как не тратят ресурсы на блокировки. Однако их пропускная способность ограничена одним ядром CPU, что требует особой организации транзакций.

### Инкапсуляция транзакций в хранимых процедурах

В начале эры баз данных транзакции предполагалось делать атомарными для целых процессов, например, бронирования авиабилетов. Однако, когда транзакция включает ожидание ввода данных пользователем, это требует поддержания множества конкурентных транзакций, что не всегда эффективно. В результате, большинство OLTP-приложений сокращают продолжительность транзакций, исключая ожидания в интерактивном режиме. В веб-технологиях это означает, что каждая новая HTTP-запрос инициирует отдельную транзакцию.

В интерактивном режиме транзакции выполняются пошагово, что увеличивает время на обмен сетевыми сообщениями между приложением и базой данных. Для повышения производительности требуется обработка нескольких транзакций одновременно. Поэтому в системах с однопоточным выполнением транзакций интерактивные многооператорные транзакции исключены. Вместо них транзакции выполняются через хранимые процедуры, что значительно ускоряет процесс, так как данные уже находятся в оперативной памяти и не требуется ожидание ввода/вывода.

### Достоинства и недостатки хранимых процедур

