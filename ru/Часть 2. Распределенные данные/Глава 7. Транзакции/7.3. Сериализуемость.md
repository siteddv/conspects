Глава обсуждает проблемы гонок состояний в транзакциях, включая асимметрию записи и фантомы. Уровни изоляции данных реализуются по-разному в разных БД, что делает их использование сложным. Отсутствие инструментов для выявления состояний гонки усложняет тестирование. Решением является использование сериализуемости, которая гарантирует правильность выполнения транзакций как при последовательном, так и при конкурентном их выполнении. Рассматриваются три метода реализации сериализуемости: последовательное выполнение, двухфазная блокировка и оптимистическое управление конкурентным доступом.

### Последовательное выполнение

Простейший способ избежать проблем с конкурентным доступом — выполнять транзакции последовательно, в одном потоке. Этот подход стал популярным в 2007 году, когда дешевые RAM и осознание, что OLTP-транзакции обычно короткие, позволили эффективно работать с данными в памяти. Системы, использующие однопоточное выполнение, такие как VoltDB, Redis и Datomic, часто показывают лучшую производительность, чем многопоточные, так как не тратят ресурсы на блокировки. Однако их пропускная способность ограничена одним ядром CPU, что требует особой организации транзакций.

### Инкапсуляция транзакций в хранимых процедурах

В начале эры баз данных транзакции предполагалось делать атомарными для целых процессов, например, бронирования авиабилетов. Однако, когда транзакция включает ожидание ввода данных пользователем, это требует поддержания множества конкурентных транзакций, что не всегда эффективно. В результате, большинство OLTP-приложений сокращают продолжительность транзакций, исключая ожидания в интерактивном режиме. В веб-технологиях это означает, что каждая новая HTTP-запрос инициирует отдельную транзакцию.

В интерактивном режиме транзакции выполняются пошагово, что увеличивает время на обмен сетевыми сообщениями между приложением и базой данных. Для повышения производительности требуется обработка нескольких транзакций одновременно. Поэтому в системах с однопоточным выполнением транзакций интерактивные многооператорные транзакции исключены. Вместо них транзакции выполняются через хранимые процедуры, что значительно ускоряет процесс, так как данные уже находятся в оперативной памяти и не требуется ожидание ввода/вывода.

![[44. Stored procedure vs interactive transaction.png]]

### Достоинства и недостатки хранимых процедур

Хранимые процедуры, являющиеся частью стандарта SQL с 1999 года, долго имели плохую репутацию из-за различных языков реализации (PL/SQL, T-SQL, PL/pgSQL) и ограниченной поддержки новшеств. Эти языки отставали от современных языков программирования и не имели широких библиотек. Также выполнение кода в базе данных сложнее структурировать и отлаживать, а ошибки в хранимых процедурах могут серьезно повлиять на производительность БД. Современные СУБД, такие как VoltDB, Datomic и Redis, используют универсальные языки (Java, Lua), что улучшает гибкость. Хранимые процедуры в таких системах позволяют выполнять транзакции в одном потоке, обеспечивая высокую производительность без ожидания ввода/вывода и блокировок. В VoltDB хранимые процедуры также используются для репликации данных, требуя детерминированных результатов.

### Секционирование

