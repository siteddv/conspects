Конкурентный доступ к данным возникает, когда транзакции одновременно читают или изменяют одни и те же данные. Это может привести к ошибкам, которые трудно воспроизвести, особенно при работе с большими приложениями. Для минимизации таких проблем базы данных используют изоляцию транзакций, которая гарантирует последовательное выполнение транзакций (сериализуемость). Однако на практике сериализуемая изоляция требует больших затрат, и многие системы применяют более слабые уровни изоляции, что может приводить к сложным ошибкам. Понимание этих уровней и умение предотвращать состояния гонки критично для создания надежных приложений.

### Чтение зафиксированных данных

Уровень изоляции "чтение зафиксированных данных" гарантирует, что при чтении из базы данных клиент видит только зафиксированные данные, а при записи можно перезаписать только зафиксированные данные. Более слабый уровень — "чтение незафиксированных данных" — предотвращает только грязные записи, но не грязные чтения.

### Никаких «грязных» операций чтения

При уровне изоляции "read committed" (чтение зафиксированных данных) предотвращается чтение незафиксированных данных, что исключает "грязные" операции чтения. Это значит, что данные, записанные в транзакции, становятся видимыми другим транзакциям только после её фиксации. «Грязные» чтения могут привести к ошибкам, если транзакция обновляет несколько объектов: другие транзакции могут увидеть частично обновленные данные, что создает путаницу и приводит к неправильным решениям. Кроме того, если транзакция прервана, данные, которые не были зафиксированы, могут быть возвращены в базу, что делает такие операции опасными.

### Никаких «грязных» операций записи

Когда две транзакции пытаются одновременно обновить один объект в базе, более поздняя запись обычно перезаписывает более раннюю. Однако если более ранняя операция записи еще не зафиксирована, это может привести к «грязной» операции записи, когда одна транзакция перезаписывает незафиксированное значение другой. Уровень изоляции "чтение зафиксированных данных" предотвращает такие ошибки, откладывая запись до фиксации или прерывания первой транзакции. Но этот уровень не решает проблемы, связанные с состояниями гонки, например, при одновременном увеличении счетчика.

### Реализация чтения зафиксированных данных

Чтение зафиксированных данных — популярный уровень изоляции в базах данных, таких как Oracle, PostgreSQL и SQL Server. Для предотвращения "грязных" операций записи используются блокировки строк: транзакция должна установить блокировку на объект перед его модификацией. Однако для предотвращения "грязных" операций чтения применяют метод, при котором база хранит старое и новое значение объекта. Читающим транзакциям возвращается старое значение, а новое доступно только после фиксации. Это решение помогает избежать задержек, вызванных ожиданием блокировок при чтении.

### Изоляция снимков состояния и воспроизводимое чтение

Уровень изоляции "чтение зафиксированных данных" предотвращает чтение промежуточных результатов транзакций, что помогает избежать «грязных» операций. Однако этот уровень изоляции не решает все проблемы конкурентного доступа. Пример: при переводе денег между счетами Алиса может увидеть неконсистентные данные — один баланс до операции, другой — после. 

![[43. Isolated transactions.png]]

Это называется асимметрией чтения (или невоспроизводимым чтением), когда транзакции читают данные, которые могут быть изменены другими в процессе выполнения. Такой эффект допустим на уровне "чтения зафиксированных данных", но может быть проблемным для некоторых случаев, например, при резервном копировании или аналитических запросах.

Для решения проблемы используется изоляция снимков состояния: каждая транзакция работает с согласованным снимком базы данных, который фиксируется на момент её начала. Это предотвращает чтение данных, изменённых другими транзакциями в процессе работы. Изоляция снимков состояния особенно полезна для долгосрочных запросов, таких как создание резервных копий или аналитика, поскольку гарантирует согласованность данных в течение всего времени выполнения запроса. Этот механизм поддерживается в таких СУБД, как PostgreSQL, MySQL (InnoDB), Oracle и SQL Server.

### Реализация изоляции снимков состояния

Изоляция снимков состояния (Snapshot Isolation) использует блокировки записи для предотвращения «грязных» операций записи, но не блокирует операции чтения. Это позволяет базе данных обрабатывать долгосрочные запросы на чтение и операции записи одновременно без конкуренции за блокировки, что улучшает производительность. Изоляция снимков состояния реализуется через многоверсионное управление конкурентным доступом (MVCC), где база данных хранит несколько версий объекта для разных транзакций, каждая из которых может видеть данные на момент её начала.

Для реализации MVCC база данных присваивает транзакциям уникальный идентификатор (txid), который используется для пометки строк, вставляемых или изменяемых транзакциями. Строки, удалённые транзакцией, не удаляются физически, а помечаются для удаления, и только после того, как убедятся, что ни одна транзакция больше не обращается к этим данным, они удаляются сборщиком мусора.

Пример: если транзакция изменяет баланс счета, она фактически создаёт новую строку с новым значением, а старую строку помечает для удаления. Таким образом, каждая транзакция видит данные, как они были на момент её начала, независимо от изменений, произошедших в других транзакциях. Это позволяет избегать проблем с асимметрией чтения и обеспечивает согласованность данных в долгих аналитических запросах или при создании резервных копий.

### Правила видимости для согласованных снимков состояния


