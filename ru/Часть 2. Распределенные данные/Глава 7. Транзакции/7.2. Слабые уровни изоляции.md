Конкурентный доступ к данным возникает, когда транзакции одновременно читают или изменяют одни и те же данные. Это может привести к ошибкам, которые трудно воспроизвести, особенно при работе с большими приложениями. Для минимизации таких проблем базы данных используют изоляцию транзакций, которая гарантирует последовательное выполнение транзакций (сериализуемость). Однако на практике сериализуемая изоляция требует больших затрат, и многие системы применяют более слабые уровни изоляции, что может приводить к сложным ошибкам. Понимание этих уровней и умение предотвращать состояния гонки критично для создания надежных приложений.

### Чтение зафиксированных данных

Уровень изоляции "чтение зафиксированных данных" гарантирует, что при чтении из базы данных клиент видит только зафиксированные данные, а при записи можно перезаписать только зафиксированные данные. Более слабый уровень — "чтение незафиксированных данных" — предотвращает только грязные записи, но не грязные чтения.

### Никаких «грязных» операций чтения

При уровне изоляции "read committed" (чтение зафиксированных данных) предотвращается чтение незафиксированных данных, что исключает "грязные" операции чтения. Это значит, что данные, записанные в транзакции, становятся видимыми другим транзакциям только после её фиксации. «Грязные» чтения могут привести к ошибкам, если транзакция обновляет несколько объектов: другие транзакции могут увидеть частично обновленные данные, что создает путаницу и приводит к неправильным решениям. Кроме того, если транзакция прервана, данные, которые не были зафиксированы, могут быть возвращены в базу, что делает такие операции опасными.

### Никаких «грязных» операций записи

Когда две транзакции пытаются одновременно обновить один объект в базе, более поздняя запись обычно перезаписывает более раннюю. Однако если более ранняя операция записи еще не зафиксирована, это может привести к «грязной» операции записи, когда одна транзакция перезаписывает незафиксированное значение другой. Уровень изоляции "чтение зафиксированных данных" предотвращает такие ошибки, откладывая запись до фиксации или прерывания первой транзакции. Но этот уровень не решает проблемы, связанные с состояниями гонки, например, при одновременном увеличении счетчика.

### Реализация чтения зафиксированных данных

Чтение зафиксированных данных — популярный уровень изоляции в базах данных, таких как Oracle, PostgreSQL и SQL Server. Для предотвращения "грязных" операций записи используются блокировки строк: транзакция должна установить блокировку на объект перед его модификацией. Однако для предотвращения "грязных" операций чтения применяют метод, при котором база хранит старое и новое значение объекта. Читающим транзакциям возвращается старое значение, а новое доступно только после фиксации. Это решение помогает избежать задержек, вызванных ожиданием блокировок при чтении.

### Изоляция снимков состояния и воспроизводимое чтение

Уровень изоляции "чтение зафиксированных данных" предотвращает чтение промежуточных результатов транзакций, что помогает избежать «грязных» операций. Однако этот уровень изоляции не решает все проблемы конкурентного доступа. Пример: при переводе денег между счетами Алиса может увидеть неконсистентные данные — один баланс до операции, другой — после. 

![[43. Isolated transactions.png]]

Это называется асимметрией чтения (или невоспроизводимым чтением), когда транзакции читают данные, которые могут быть изменены другими в процессе выполнения. Такой эффект допустим на уровне "чтения зафиксированных данных", но может быть проблемным для некоторых случаев, например, при резервном копировании или аналитических запросах.

Для решения проблемы используется изоляция снимков состояния: каждая транзакция работает с согласованным снимком базы данных, который фиксируется на момент её начала. Это предотвращает чтение данных, изменённых другими транзакциями в процессе работы. Изоляция снимков состояния особенно полезна для долгосрочных запросов, таких как создание резервных копий или аналитика, поскольку гарантирует согласованность данных в течение всего времени выполнения запроса. Этот механизм поддерживается в таких СУБД, как PostgreSQL, MySQL (InnoDB), Oracle и SQL Server.

### Реализация изоляции снимков состояния

Изоляция снимков состояния (Snapshot Isolation) использует блокировки записи для предотвращения «грязных» операций записи, но не блокирует операции чтения. Это позволяет базе данных обрабатывать долгосрочные запросы на чтение и операции записи одновременно без конкуренции за блокировки, что улучшает производительность. Изоляция снимков состояния реализуется через многоверсионное управление конкурентным доступом (MVCC), где база данных хранит несколько версий объекта для разных транзакций, каждая из которых может видеть данные на момент её начала.

Для реализации MVCC база данных присваивает транзакциям уникальный идентификатор (txid), который используется для пометки строк, вставляемых или изменяемых транзакциями. Строки, удалённые транзакцией, не удаляются физически, а помечаются для удаления, и только после того, как убедятся, что ни одна транзакция больше не обращается к этим данным, они удаляются сборщиком мусора.

Пример: если транзакция изменяет баланс счета, она фактически создаёт новую строку с новым значением, а старую строку помечает для удаления. Таким образом, каждая транзакция видит данные, как они были на момент её начала, независимо от изменений, произошедших в других транзакциях. Это позволяет избегать проблем с асимметрией чтения и обеспечивает согласованность данных в долгих аналитических запросах или при создании резервных копий.

### Правила видимости для согласованных снимков состояния

При выполнении операций чтения транзакция использует идентификаторы других транзакций, чтобы определить, какие объекты она может видеть, а какие — нет. База данных создает согласованный снимок состояния, применяя следующие правила видимости:

1. Все изменения, выполненные транзакциями, которые ещё не зафиксированы или прерваны, игнорируются.
2. Операции записи транзакций с более поздним идентификатором (начавшихся после текущей) не видны.
3. Операции записи прерванных транзакций также игнорируются.
4. Все изменения, выполненные транзакциями, которые уже зафиксированы на момент начала текущей транзакции, видны.

Таким образом, объект считается видимым, если:
- Транзакция, создавшая объект, была зафиксирована на момент начала чтения.
- Объект не помечен для удаления или транзакция, запросившая удаление, ещё не зафиксирована.

Длительные транзакции могут работать с согласованным снимком состояния, читая значения, которые уже были изменены или удалены с точки зрения других транзакций. Этот механизм минимизирует дополнительные затраты при поддержке многоверсионности (MVCC).

### Индексы и изоляция снимков состояния

В многоверсионных базах данных индексы могут указывать на все версии объекта, фильтруя те, которые не видны текущей транзакции. Старые версии, больше не видимые, удаляются процессом сборки мусора, и соответствующие индексы обновляются. В PostgreSQL оптимизировано обновление индексов, если несколько версий объекта помещаются на одну страницу. В СУБД, таких как CouchDB, Datomic и LMDB, используется схема дописывания данных (append-only/copy-on-write), где при обновлении создаются новые копии страниц B-дерева, а неизменённые страницы остаются. Каждая транзакция записи создаёт новую корневую вершину B-дерева, что устраняет необходимость фильтрации по идентификаторам транзакций. Однако такой подход требует фонового процесса для уплотнения данных и удаления мусора.

### Воспроизводимое чтение и путаница с названиями

Изоляция снимков состояния — это удобный уровень изоляции, особенно для транзакций только для чтения, но различные базы данных используют разные названия для этого уровня. В Oracle это называется уровнем сериализации, а в PostgreSQL и MySQL — воспроизводимым чтением. Стандарт SQL, основанный на уровнях изоляции СУБД System R, не включает концепцию изоляции снимков состояния, а вместо этого определяет воспроизводимое чтение, что вызывает путаницу. Реализации воспроизводимого чтения в разных СУБД могут значительно отличаться, несмотря на заявленную стандартизацию, и даже IBM DB2 называет это сериализуемостью.

### Предотвращение потери обновлений

Проблема потерянного обновления возникает, когда две транзакции одновременно читают, изменяют и записывают одно и то же значение, не учитывая изменения друг друга. Это может привести к потере одного из обновлений, когда более поздняя операция записи затирает более раннюю. Проблема встречается при увеличении счетчиков, обновлении балансов, изменении составных значений (например, в JSON-документах) или одновременном редактировании контента (например, на страницах Википедии). Для её решения разработано множество методов.

### Атомарные операции записи

Многие базы данных поддерживают атомарные операции записи, позволяя избежать циклов чтения-изменения-записи в приложении. Это оптимальное решение для таких задач, как увеличение счетчиков или модификация частей JSON-документов в MongoDB. Пример атомарной операции: UPDATE counters SET value = value + 1 WHERE key = 'foo'. Атомарные операции обычно реализуются через эксклюзивные блокировки объекта при чтении (чтение по курсору) или выполнение операций в отдельном потоке. Однако, при использовании объектно-реляционного отображения, легко ошибиться и использовать небезопасные циклы чтения-изменения-записи, что может привести к ошибкам.

### Явные блокировки

Для предотвращения потери обновлений, если атомарных операций недостаточно, можно использовать явные блокировки объектов на уровне приложения. Это позволяет безопасно выполнить цикл чтения — изменения — записи. Например, в многопользовательской игре блокировка одной фигуры предотвращает одновременное перемещение её двумя игроками. В SQL это реализуется с помощью `SELECT ... FOR UPDATE`, который блокирует строки до завершения транзакции. Однако этот метод требует осторожности, чтобы избежать забытых блокировок и состояния гонки.

### Автоматическое обнаружение потери обновлений

Для предотвращения потери обновлений можно разрешить конкурентное выполнение циклов чтения — изменения — записи, с последующим прерыванием транзакции при обнаружении потери обновления и принудительным повтором операции. Этот подход эффективен при изоляции снимков состояния, поскольку позволяет автоматически выявлять и прерывать проблемные транзакции. В СУБД PostgreSQL, Oracle и SQL Server потеря обновлений обнаруживается автоматически, но MySQL/InnoDB не выполняет такую проверку. Это улучшает надежность, снижая риск ошибок из-за забытых блокировок или атомарных операций.

### Сравнение с обменом

Операция «сравнение с обменом» (compare-and-set) используется для предотвращения потери обновлений, позволяя обновить значение только в случае, если оно не изменилось с момента последнего чтения. Например, при редактировании страницы «Википедии» обновление будет выполнено только если содержимое страницы не изменилось. Однако такая операция может быть небезопасной, если база данных позволяет использовать старый снимок состояния, что приведет к потере обновлений. Поэтому перед использованием операции важно удостовериться в ее безопасности в контексте конкретной СУБД.

### Разрешение конфликтов и репликация

В реплицируемых базах данных предотвращение потери обновлений усложняется из-за асинхронной репликации и одновременных операций записи на разных узлах. Блокировки и операции сравнения с обменом не подходят в таких системах, так как не гарантируют наличие одной актуальной копии данных. Вместо этого используются методы, позволяющие создавать несколько конфликтующих версий данных, которые затем сливаются приложением или с помощью специализированных структур данных. Атомарные операции, особенно коммутативные (например, приращение счетчика), хорошо подходят для репликации. Однако метод «выигрывает последний» (LWW) может привести к потере обновлений и часто используется по умолчанию.

### Асимметрия записи и фантомы

В случае конкурентных операций записи могут возникать более сложные состояния гонки. Примером является ситуация с врачами, работающими по сменам в больнице. Алиса и Боб, оба дежурных врача, одновременно решают взять отгул. Приложение проверяет, что в данный момент есть два дежурных врача, и обе проверки проходят успешно. Однако, из-за изоляции снимков состояния, обе транзакции продолжаются, и в результате оба врача получают отгул, нарушая требование, что хотя бы один должен оставаться на дежурстве.

### Характеристики асимметрии записи

Асимметрия записи (write skew) — это аномалия, возникающая при конкурентном выполнении транзакций, когда они обновляют разные объекты, но в результате возникает состояние гонки. В отличие от потери обновлений, здесь транзакции не перезаписывают друг друга, однако, при их последовательном выполнении, результат был бы иной (например, второй врач не получил бы отгула). Асимметрию записи можно рассматривать как расширение проблемы потери обновлений, где транзакции могут читать одни и те же данные и обновлять разные объекты.

Автоматические средства защиты от потери обновлений не помогают в случае асимметрии записи, так как она не выявляется в обычных системах изоляции (например, в PostgreSQL, MySQL, Oracle и SQL Server). Решением может быть использование сериализуемости транзакций, создание ограничений целостности или блокировка строк с помощью SQL-запросов, таких как `FOR UPDATE`, чтобы избежать одновременного изменения данных.

### Дополнительные примеры асимметрии записи

Асимметрия записи может возникать в различных ситуациях, когда несколько транзакций конкурентно изменяют данные, не сталкиваясь непосредственно, но создавая непредсказуемые результаты. Например, в системе бронирования конференц-залов два пользователя могут одновременно запросить бронирование на одно и то же время, не заметив друг друга, если используется изоляция снимков состояния. Чтобы предотвратить такие ситуации, необходимо использовать изоляцию уровня сериализуемости.

Другие примеры включают многопользовательские игры, где блокировки могут не предотвратить нарушающие правила ходы (например, перемещение двух фигур на одно поле), или регистрацию уникальных имен пользователей, где конкурирующие запросы могут привести к нарушению уникальности. В таких случаях помогает ограничение уникальности, которое прерывает транзакцию при попытке создания дублирующей записи.

В сервисах для списания средств асимметрия записи может привести к тому, что два пользователя одновременно потратят больше, чем у них есть, если их транзакции не видят друг друга. Эти проблемы можно решить через ограничения целостности, использование сериализуемости или блокировки на уровне строк.

### Асимметрия записи вследствие фантомов

Все приведенные примеры следуют схеме из трех шагов: сначала выполняется запрос SELECT для проверки условия (например, доступность врача, отсутствие бронирования, наличие средств и т.д.), затем в зависимости от результата приложение решает, продолжить ли операцию или прервать её, и в случае продолжения выполняется запись (INSERT, UPDATE, DELETE) в базу данных, изменяя состояние данных.

Однако в некоторых случаях, когда операция записи изменяет условия поиска для следующего запроса, результат может стать другим. Например, после бронирования конференц-зала изменяется его доступность, а после перемещения фигуры — позиция на доске. Этот эффект называется фантомом (phantom), и он может привести к асимметрии записи. Изоляция снимков состояния предотвращает фантомы в запросах только для чтения, но в транзакциях с чтением и записью фантомы могут вызвать сложные ошибки, такие как конкурентные изменения данных, что делает их трудными для предотвращения.

### Материализация конфликтов

