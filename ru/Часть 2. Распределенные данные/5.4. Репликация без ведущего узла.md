Репликация в СУБД может быть с одним ведущим узлом или без него. В первом случае клиент отправляет запрос на запись ведущему, который дублирует его на ведомых. Во втором случае клиент может направлять записи сразу на несколько реплик, что обеспечивает большую гибкость, но усложняет порядок обработки операций. Примеры безведомых систем — Dynamo, Riak, Cassandra и Voldemort.

### Запись в базу данных при отказе одного из узлов

В схеме репликации без ведущего узла при недоступности одной из реплик операции записи могут быть подтверждены большинством реплик (кворумом). Например, если одна из трех реплик недоступна, достаточно, чтобы две из оставшихся реплик приняли запись, и клиент получит подтверждения от этих двух. Однако при восстановлении недоступной реплики может возникнуть проблема с устаревшими данными, так как она не получила информацию о произошедших операциях записи. Чтобы избежать получения устаревших значений, клиенты отправляют запросы сразу к нескольким репликам, получая разные ответы. Для определения актуальности данных используется система номеров версий.

![[31. Insert by cvorum.png]]

### Разрешение конфликтов при чтении и антиэнтропия

В Dynamo-подобных системах данные синхронизируются между репликами с использованием двух механизмов.

* Разрешение конфликтов при чтении: Клиент, читающий данные с нескольких реплик, обнаруживает устаревшие значения (например, версию 6 на реплике 3) и записывает актуальные данные на реплику (например, версию 7).

* Процесс противодействия энтропии: Фоновый процесс синхронизирует данные между репликами, выискивая различия и копируя отсутствующие данные, но без определённого порядка операций, что может вызвать задержку.

Не все системы, как Voldemort, имеют оба этих механизма, что может снижать доступность данных, если процесс противодействия энтропии отсутствует.

### Операции записи и чтения по кворуму

В системах с репликацией без ведущего узла, для обеспечения согласованности данных используется концепция кворума, которая определяет минимальное количество узлов, которые должны подтвердить операцию записи или чтения. 

Для успешной операции записи требуется, чтобы данные были подтверждены как минимум на **w** узлах, а для успешного чтения — данные должны быть получены хотя бы с **r** узлов. Важно, чтобы **w + r > n**, где **n** — общее количество реплик. Это условие гарантирует, что хотя бы одна из реплик, к которой осуществляется чтение, содержит актуальную информацию. Например, в системе с **n = 3** репликами, где **w = 2** и **r = 2**, можно быть уверенным, что хотя бы одна из двух читаемых реплик вернёт актуальные данные, даже если третья реплика недоступна.

![[32. Read and write by cvorum.png]]

Если количество доступных узлов меньше, чем **w** или **r**, операция записи или чтения возвращает ошибку. Это условие обеспечивает устойчивость системы к отказам: например, при **n = 5**, **w = 3** и **r = 3** система может терпеть два недоступных узла. 

Параметры **w** и **r** можно настраивать в зависимости от нагрузки и требований к системе. Для ускорения чтения можно установить **w = n** и **r = 1**, что уменьшит время ответа при риске потери данных в случае отказа узла. 

Кроме того, для больших наборов данных возможно их секционирование, что позволяет использовать большее количество узлов, чем указано в параметре **n**.

### Ограничения согласованности по кворуму

При использовании репликации в распределённых базах данных параметры w (количество узлов для записи) и r (количество узлов для чтения) важны для обеспечения актуальности данных. Условие w + r > n (где n — общее количество узлов) помогает гарантировать, что множество узлов для чтения пересекается с множеством узлов для записи, минимизируя вероятность чтения устаревших данных. Однако это не исключает случаев, когда старое значение может быть возвращено, особенно при нестрогих кворумах, параллельных записях или сбоях узлов.

При меньших значениях w и r, когда w + r ≤ n, возможно более быстрое выполнение операций, но увеличивается риск получения устаревших данных, так как не все узлы с актуальными данными будут охвачены операциями. Это повышает доступность, но снижает согласованность.

В сложных сценариях, например, при параллельных записях или сбоях узлов, возможна ситуация, когда обновление данных не успевает отразиться на всех репликах, что нарушает гарантии актуальности. Даже при соблюдении условия w + r > n существует риск получения устаревших значений из-за различных факторов: ошибок хронометража, рассинхронизации узлов, или из-за сбоев в репликации.

Для мониторинга актуальности данных важно отслеживать задержку репликации. В базах данных с ведущим узлом это делается через метрики, показывающие разницу в позициях журналов записи. В системах без ведущего узла оценить устарелость данных сложнее. Исследования показывают, что для адекватного мониторинга необходимо учитывать степень устарелости, но это редко включается в стандартные метрики БД.

### Нестрогие кворумы и направленная передача

Базы данных с репликацией без ведущего узла и кворумом могут выдерживать отказы отдельных узлов и сетевые сбои, обеспечивая высокую доступность и низкую задержку. При этом достаточно, чтобы ответили **w** или **r** узлов, а не все **n**. Однако сбои сети могут привести к тому, что клиент не сможет достичь кворума, если доступно меньше чем **w** или **r** узлов. В таких случаях возможны два подхода:

1. Возврат ошибок, если не удается достичь кворума.
2. Использование нестрогого кворума (sloppy quorum), когда операции записи выполняются на доступных узлах, даже если они не входят в стандартное множество **n** узлов. Такие записи позже передаются на «родные» узлы при восстановлении связи (направленная передача).

Нестрогий кворум повышает доступность записей, но не гарантирует актуальности данных при чтении, так как актуальные значения могут находиться на недоступных узлах. Этот подход используется в Dynamo-подобных БД, таких как Riak, Cassandra и Voldemort, где в зависимости от настроек он может быть включен или отключен.

Для эксплуатации с несколькими ЦОДами репликация без ведущего узла также эффективна. В таких системах реплики распределяются между ЦОДами, а клиент может ожидать подтверждения от кворума в локальном ЦОДе, минимизируя задержки и сбои между ЦОДами.

### Обнаружение конкурентных операций записи

В Dynamo-подобных базах данных возможны конкурентные записи для одного ключа несколькими клиентами, что может привести к конфликтам, даже при использовании строгих кворумов. Это связано с различными сетевыми задержками и частичными отказами, из-за которых события могут поступать на узлы в разном порядке. Например, один узел может сначала получить запись от клиента A, а затем от клиента B, или наоборот.

![[33. sloppy quorum.png]]

Для достижения конечной согласованности реплики должны согласовать свои данные. Однако большинство реализаций не решают эту проблему автоматически, и разработчики должны понимать, как база данных разрешает конфликты записи, чтобы избежать потери данных.

### «Выигрывает последний» (отбраковка конкурентных операций записи)

Один из методов достижения конвергентности в распределённых базах данных — это использование подхода «выигрывает последний» (last write wins, LWW), при котором реплики хранят только самое «свежее» значение, определяемое меткой времени. Если две записи для одного ключа имеют разные метки, операция с более поздней меткой считается актуальной, а более ранняя — проигнорирована. Этот метод разрешения конфликтов используется в СУБД, таких как Cassandra и Riak.

LWW позволяет добиться конвергентности, но при этом возможна потеря данных, так как только одна запись будет учтена, а остальные игнорируются. Такой подход хорош, когда потеря части данных допустима (например, при кэшировании), но если потеря данных неприемлема, LWW не является лучшим решением. Для безопасного использования LWW рекомендуется обеспечить, чтобы каждый ключ записывался только один раз, например, используя уникальные UUID для ключей.

### Связь типа «происходит до» и конкурентный доступ

Чтобы определить, конкурентны ли две операции записи, нужно проверить, зависит ли одна операция от другой. Если одна операция основана на другой (например, изменяет её результат), то они не конкурентны. Если же операции не знают о существовании друг друга, то они считаются конкурентными. Важно, что для двух операций A и B есть три варианта: A происходит до B, B происходит до A, или они конкурентны. Время выполнения не имеет значения — операции считаются конкурентными, если они не взаимодействуют между собой из-за сетевых задержек или других факторов.

### Обнаружение связей типа «происходит до»

![[34. What happens before.png]]

Алгоритм, определяющий конкурентность операций записи, можно понять на примере базы данных с одной репликой. Рассмотрим два клиента, которые параллельно добавляют товары в корзину заказов. Когда клиент 1 добавляет товар (например, milk), сервер присваивает операции номер версии 1 и сохраняет её. Клиент 2, не зная о действии клиента 1, добавляет другой товар (eggs), сервер присваивает этой операции номер версии 2.

Затем, клиент 1 пытается добавить другой товар (flour), не зная о записи клиента 2. Сервер понимает, что операция клиент 1 с номером версии 1 конфликтует с данными, добавленными клиентом 2. В результате создается новый набор значений (milk, flour), а значение eggs сохраняется в версии 2. Клиент 2, в свою очередь, добавляет товар (ham), не зная о действии клиента 1. Его операция приводит к созданию новой версии (eggs, milk, ham).

Алгоритм работает так: сервер хранит номера версий для всех ключей и увеличивает их при каждой записи. При чтении клиент получает все неперезаписанные значения и последний номер версии. Для записи клиент должен указать номер версии из предыдущей операции и объединить все текущие значения. Сервер, получив операцию записи, сохраняет все значения с номерами версий выше, а значения с меньшими номерами (слитые в новой записи) перезаписывает.

Таким образом, использование номеров версий позволяет серверу определить, являются ли операции конкурентными. Каждая запись включает номер версии предыдущего состояния, и если операция не включает номер версии, она считается конкурентной относительно других записей. Этот механизм позволяет избежать потери данных, а устаревшие значения заменяются новыми в случае слияния.