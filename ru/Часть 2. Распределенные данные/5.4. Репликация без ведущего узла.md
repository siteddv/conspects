Репликация в СУБД может быть с одним ведущим узлом или без него. В первом случае клиент отправляет запрос на запись ведущему, который дублирует его на ведомых. Во втором случае клиент может направлять записи сразу на несколько реплик, что обеспечивает большую гибкость, но усложняет порядок обработки операций. Примеры безведомых систем — Dynamo, Riak, Cassandra и Voldemort.

### Запись в базу данных при отказе одного из узлов

В схеме репликации без ведущего узла при недоступности одной из реплик операции записи могут быть подтверждены большинством реплик (кворумом). Например, если одна из трех реплик недоступна, достаточно, чтобы две из оставшихся реплик приняли запись, и клиент получит подтверждения от этих двух. Однако при восстановлении недоступной реплики может возникнуть проблема с устаревшими данными, так как она не получила информацию о произошедших операциях записи. Чтобы избежать получения устаревших значений, клиенты отправляют запросы сразу к нескольким репликам, получая разные ответы. Для определения актуальности данных используется система номеров версий.

![[31. Insert by cvorum.png]]

### Разрешение конфликтов при чтении и антиэнтропия

В Dynamo-подобных системах данные синхронизируются между репликами с использованием двух механизмов.

* Разрешение конфликтов при чтении: Клиент, читающий данные с нескольких реплик, обнаруживает устаревшие значения (например, версию 6 на реплике 3) и записывает актуальные данные на реплику (например, версию 7).

* Процесс противодействия энтропии: Фоновый процесс синхронизирует данные между репликами, выискивая различия и копируя отсутствующие данные, но без определённого порядка операций, что может вызвать задержку.

Не все системы, как Voldemort, имеют оба этих механизма, что может снижать доступность данных, если процесс противодействия энтропии отсутствует.

### Операции записи и чтения по кворуму

В системах с репликацией без ведущего узла, для обеспечения согласованности данных используется концепция кворума, которая определяет минимальное количество узлов, которые должны подтвердить операцию записи или чтения. 

Для успешной операции записи требуется, чтобы данные были подтверждены как минимум на **w** узлах, а для успешного чтения — данные должны быть получены хотя бы с **r** узлов. Важно, чтобы **w + r > n**, где **n** — общее количество реплик. Это условие гарантирует, что хотя бы одна из реплик, к которой осуществляется чтение, содержит актуальную информацию. Например, в системе с **n = 3** репликами, где **w = 2** и **r = 2**, можно быть уверенным, что хотя бы одна из двух читаемых реплик вернёт актуальные данные, даже если третья реплика недоступна.

Если количество доступных узлов меньше, чем **w** или **r**, операция записи или чтения возвращает ошибку. Это условие обеспечивает устойчивость системы к отказам: например, при **n = 5**, **w = 3** и **r = 3** система может терпеть два недоступных узла. 

Параметры **w** и **r** можно настраивать в зависимости от нагрузки и требований к системе. Для ускорения чтения можно установить **w = n** и **r = 1**, что уменьшит время ответа при риске потери данных в случае отказа узла. 

Кроме того, для больших наборов данных возможно их секционирование, что позволяет использовать большее количество узлов, чем указано в параметре **n**.