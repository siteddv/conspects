Репликация в СУБД может быть с одним ведущим узлом или без него. В первом случае клиент отправляет запрос на запись ведущему, который дублирует его на ведомых. Во втором случае клиент может направлять записи сразу на несколько реплик, что обеспечивает большую гибкость, но усложняет порядок обработки операций. Примеры безведомых систем — Dynamo, Riak, Cassandra и Voldemort.

### Запись в базу данных при отказе одного из узлов

В схеме репликации без ведущего узла при недоступности одной из реплик операции записи могут быть подтверждены большинством реплик (кворумом). Например, если одна из трех реплик недоступна, достаточно, чтобы две из оставшихся реплик приняли запись, и клиент получит подтверждения от этих двух. Однако при восстановлении недоступной реплики может возникнуть проблема с устаревшими данными, так как она не получила информацию о произошедших операциях записи. Чтобы избежать получения устаревших значений, клиенты отправляют запросы сразу к нескольким репликам, получая разные ответы. Для определения актуальности данных используется система номеров версий.

![[31. Insert by cvorum.png]]

### Разрешение конфликтов при чтении и антиэнтропия

В Dynamo-подобных системах данные синхронизируются между репликами с использованием двух механизмов.

* Разрешение конфликтов при чтении: Клиент, читающий данные с нескольких реплик, обнаруживает устаревшие значения (например, версию 6 на реплике 3) и записывает актуальные данные на реплику (например, версию 7).

* Процесс противодействия энтропии: Фоновый процесс синхронизирует данные между репликами, выискивая различия и копируя отсутствующие данные, но без определённого порядка операций, что может вызвать задержку.

Не все системы, как Voldemort, имеют оба этих механизма, что может снижать доступность данных, если процесс противодействия энтропии отсутствует.

### Операции записи и чтения по кворуму

