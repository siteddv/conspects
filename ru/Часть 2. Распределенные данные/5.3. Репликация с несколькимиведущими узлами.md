Глава посвящена альтернативам архитектуры репликации с одним ведущим узлом, которая имеет недостаток: все операции записи зависят от единственного узла, что создает риски при его недоступности. Решением является схема репликации с несколькими ведущими узлами (multi-leader replication), где несколько узлов могут обрабатывать записи и обмениваться изменениями. Эта модель, известная как «главный — главный» или «активный/активный», обеспечивает большую доступность и устойчивость системы, позволяя каждому узлу быть как ведущим, так и ведомым.

### Сценарии использования репликации с несколькими ведущими узлами

Репликация с несколькими ведущими узлами в одном ЦОД редко оправдана из-за усложнений, но в некоторых случаях может быть целесообразной.

### Эксплуатация с несколькими ЦОДами

В главе рассматривается архитектура репликации баз данных с несколькими ведущими узлами в разных ЦОДах для повышения устойчивости к сбоям и улучшения производительности. В обычной схеме с одним ведущим узлом все записи проходят через один ЦОД, что может замедлять операции из-за сетевых задержек. В схеме с несколькими ведущими узлами каждый ЦОД имеет своего ведущего узла, что позволяет обрабатывать записи локально и асинхронно реплицировать изменения в другие ЦОДы, минимизируя задержки.

Преимущества схемы с несколькими ведущими узлами включают независимость ЦОДов при сбоях, устойчивость к сетевым проблемам и улучшение субъективной производительности. Однако существуют и недостатки, такие как возможность возникновения конфликтов записи, когда данные модифицируются одновременно в разных ЦОДах, что требует разрешения конфликтов. Эта схема может также столкнуться с проблемами настройки и взаимодействия с другими функциями баз данных, поэтому её использование следует тщательно обдумывать.

![[27. Multi-master replication.png]]

### Офлайн-клиенты

Репликация с несколькими ведущими узлами также подходит для приложений, которые должны функционировать без постоянного подключения к Интернету. Примером могут служить приложения-календари на мобильных устройствах, где пользователи могут просматривать и добавлять события независимо от наличия соединения. В этом случае каждое устройство имеет локальную базу данных, принимающую запросы на запись, и происходит асинхронная репликация между устройствами при следующем подключении к сети.

Задержка репликации может варьироваться от часов до дней, в зависимости от доступа к Интернету. Эта архитектура по сути является расширением схемы с несколькими ведущими узлами, где каждое устройство выступает в роли "ЦОДа" с ненадежным соединением. Реализация такой схемы может быть сложной, как показывает практика неудачных попыток синхронизации календарей. Для упрощения этого процесса существуют специализированные инструменты, такие как СУБД CouchDB.

### Совместное редактирование

Приложения для совместного редактирования, такие как Etherpad и Google Docs, позволяют нескольким пользователям одновременно работать над документом. Изменения мгновенно применяются к локальной версии документа и асинхронно реплицируются на сервер и другим пользователям. Хотя совместное редактирование не считается задачей репликации баз данных, оно схоже с офлайн-редактированием.

Для предотвращения конфликтов редактирования приложение может блокировать документ перед его изменением. В этом случае другие пользователи должны подождать, пока первый завершит редактирование. Это соответствует модели с одним ведущим узлом. Однако для повышения скорости совместной работы следует уменьшить размер блоков изменений, что позволяет нескольким пользователям редактировать одновременно, но при этом возникают проблемы, связанные с репликацией и необходимостью разрешения конфликтов.

### Обработка конфликтов записи

Основная проблема репликации с несколькими ведущими узлами — конфликты записи. Например, если два пользователя одновременно изменяют название страницы «Википедии» на разные значения, возникает конфликт при асинхронной репликации, чего не случилось бы при репликации с одним ведущим узлом.

![[28. Replication conflict example.png]]

### Асинхронное и синхронное обнаружение конфликтов

В базе данных с одним ведущим узлом операции записи блокируются до завершения предыдущих или требуют повторного выполнения. В схеме с несколькими ведущими узлами обе операции успешно завершаются, но конфликты могут быть обнаружены позднее, что затрудняет их разрешение для пользователей. Синхронное обнаружение конфликтов, при котором репликация операций ожидает завершения на всех узлах, уничтожает главное преимущество этой схемы — независимую обработку операций. В этом случае лучше использовать модель с одним ведущим узлом.

### Предотвращение конфликтов

Простейший способ избежать конфликтов в репликации — гарантировать, что все операции изменения конкретной записи проходят через один ведущий узел. Это устраняет возможность конфликтов, что особенно важно, поскольку многие реализации репликации с несколькими ведущими узлами не справляются с ними эффективно. Например, если пользователь редактирует свои данные, запросы должны направляться на один и тот же ЦОД, используя локальный ведущий узел для чтения и записи.

Однако в случае сбоя ЦОДа или изменения местоположения пользователя необходимо переключить ведущий узел. В таких ситуациях предотвращение конфликтов уже невозможно, и возникает необходимость разрешения конкурирующих операций записи на разных ведущих узлах, что требует дополнительных стратегий управления конфликтами.

### Сходимость к согласованному состоянию

В базе данных с одним ведущим узлом операции записи применяются последовательно, и последнее изменение определяет итоговое значение поля. В схеме с несколькими ведущими узлами порядок операций не установлен, что делает итоговое значение неопределенным. Например, в одном узле значение изменяется на B, а в другом — на C. Это приводит к несогласованности данных, что недопустимо для репликации.

Для решения конфликтов необходимо обеспечить, чтобы все реплики сошлись к одному значению после репликации. Существуют несколько подходов к конвергентному разрешению конфликтов:

* Last Write Wins (LWW): каждой операции присваивается уникальный идентификатор, и выбирается операция с максимальным значением. Этот метод может привести к потере данных.

* Уникальные идентификаторы присваиваются репликам, где записи от реплик с большим номером имеют приоритет. Это также может вызвать потерю данных.

* Значения можно объединять, например, в алфавитном порядке.

* Конфликты могут быть зафиксированы в специальной структуре данных для последующего разрешения, возможно, с участием пользователя.

### Пользовательская логика разрешения конфликтов

Для разрешения конфликтов в системах репликации с несколькими ведущими узлами разработчики могут реализовать логику конфликтов в коде приложения, выполняемом при записи или чтении.

* При записи: При обнаружении конфликта вызывается обработчик, который, например, в Bucardo может быть написан на Perl. Такой обработчик должен работать быстро и не может взаимодействовать с пользователем.

* При чтении: При конфликте система сохраняет все версии данных. При следующем чтении приложение может вернуть пользователю все версии и разрешить конфликт автоматически или с его участием, как в CouchDB.

Разрешение конфликтов, как правило, выполняется на уровне строк или документов, а не транзакций. Это может усложнить логику и привести к ошибкам, как в случае с Amazon, где удаленные товары могут повторно появляться в корзине.

Интересные подходы к автоматическому разрешению конфликтов включают:

* CRDT: Структуры данных, которые автоматически разрешают конфликты.
* Объединяемые структуры данных: Отслеживают историю изменений, как в системах контроля версий.
* Операциональное преобразование: Алгоритм, используемый в приложениях совместного редактирования, например, в Etherpad и Google Docs.

Автоматическое разрешение конфликтов упрощает синхронизацию данных, хотя реализации этих алгоритмов еще не окончательны.

### Что такое конфликт

Некоторые конфликты в системах легко заметить, как, например, одновременные изменения одного поля записи. Однако другие конфликты могут быть менее очевидными. Например, в системе бронирования конференц-залов возможен конфликт, если два разных бронирования пытаются занять одно и то же время для одного и того же зала, даже если приложение проверяет доступность. Такой конфликт может возникнуть при выполнении операций на разных ведущих узлах. Шаблонного решения для этих случаев нет, но в будущем мы рассмотрим примеры конфликтов и подходы к их обнаружению и разрешению.

### Топологии репликации с несколькими ведущими узлами

Топология репликации определяет пути, по которым операции записи распространяются между узлами. Для двух ведущих узлов существует единственная логичная топология: каждый узел отправляет данные другому. При добавлении узлов становятся возможны различные топологии, такие как «каждый с каждым», «кольцо» и «звезда». В топологии «каждый с каждым» каждый узел делится данными со всеми остальными, в то время как в «кольце» и «звезде» сообщения передаются через несколько узлов.

![[29. Replication topology.png]]

В «кольце» и «звезде» операции записи должны пройти через несколько узлов, что требует уникальных идентификаторов для предотвращения бесконечных циклов. Однако если один узел откажет, это может прервать поток сообщений между остальными узлами. Топология «каждый с каждым» более устойчива к сбоям, так как сообщения могут обходить отказавшие узлы, но может столкнуться с проблемами при нарушении порядка сообщений.

![[30. Replication bottlenecks.png]]

Проблема заключается в том, что операции могут приходить в неправильном порядке. Например, если обновление поступает перед вставкой, узел может получить ошибочные данные. Для решения этой проблемы используются методы, такие как векторы версий, однако многие системы, такие как BDR для PostgreSQL и Tungsten Replicator для MySQL, не поддерживают причинно-следственную упорядоченность. При использовании систем с репликацией важно внимательно изучить документацию и тщательно тестировать функциональность базы данных, чтобы убедиться в ее надежности и способности гарантировать правильную обработку операций записи.